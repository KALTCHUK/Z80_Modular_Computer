0001   0000             ;****************************************************************
0002   0000             ;*
0003   0000             ;*             C P / M   version   2 . 2 1
0004   0000             ;* This version has a new built-in command - TPA, which executes
0005   0000             ;*  a jump to TPA (0100h). This allows us to download a program
0006   0000             ;*  with the Monitor xmodem command, reboot to CP/M and run the
0007   0000             ;*       program from memory. No need to fetch from disk.
0008   0000             ;*
0009   0000             ;*   Reconstructed from memory image on February 27, 1981
0010   0000             ;*
0011   0000             ;*                by Clark A. Calkins
0012   0000             ;*
0013   0000             ;****************************************************************
0014   0000             ;
0015   0000             ;   Set memory limit here. This is the amount of contigeous
0016   0000             ; ram starting from 0000. CP/M will reside at the end of this space.
0017   0000             ;
0018   0000             
0019   0000             BIOS		.EQU	0E600H		;BIOS start address
0020   0000             IOBYTE	.EQU	3			;i/o definition byte.
0021   0000             TDRIVE	.EQU	4			;current drive name and user number.
0022   0000             ENTRY		.EQU	5			;entry point for the cp/m bdos.
0023   0000             TFCB		.EQU	5CH			;default file control block.
0024   0000             TBUFF		.EQU	80H			;i/o buffer and command line storage.
0025   0000             TBASE		.EQU	100H			;transiant program storage area.
0026   0000             ;
0027   0000             ;   Set control character equates.
0028   0000             ;
0029   0000             CNTRLC	.EQU	3			;control-c
0030   0000             CNTRLE	.EQU	05H			;control-e
0031   0000             BS		.EQU	08H			;backspace
0032   0000             TAB		.EQU	09H			;tab
0033   0000             LF		.EQU	0AH			;line feed
0034   0000             FF		.EQU	0CH			;form feed
0035   0000             CR		.EQU	0DH			;carriage return
0036   0000             CNTRLP	.EQU	10H			;control-p
0037   0000             CNTRLR	.EQU	12H			;control-r
0038   0000             CNTRLS	.EQU	13H			;control-s
0039   0000             CNTRLU	.EQU	15H			;control-u
0040   0000             CNTRLX	.EQU	18H			;control-x
0041   0000             CNTRLZ	.EQU	1AH			;control-z (end-of-file mark)
0042   0000             DEL		.EQU	7FH			;rubout
0043   0000             ;
0044   0000             ;   Set origin for CP/M
0045   0000             ;
0046   D000             		.ORG	0D000H
0047   D000             ;
0048   D000 C3 60 D3    CBASE:	JP	COMMAND		;execute command processor (ccp).
0049   D003 C3 5C D3    		JP	CLEARBUF		;entry to empty input buffer before starting ccp.
0050   D006             
0051   D006             ;
0052   D006             ;   Standard cp/m ccp input buffer. Format is (max length),
0053   D006             ; (actual length), (char #1), (char #2), (char #3), etc.
0054   D006             ;
0055   D006 7F          INBUFF:	.DB	127			;length of input buffer.
0056   D007 00          		.DB	0			;current length of contents.
0057   D008 43 6F 70 79 		.TEXT	"Copyright"
0057   D00C 72 69 67 68 
0057   D010 74 
0058   D011 20 31 39 37 		.TEXT	" 1979 (c) by Digital Research      "
0058   D015 39 20 28 63 
0058   D019 29 20 62 79 
0058   D01D 20 44 69 67 
0058   D021 69 74 61 6C 
0058   D025 20 52 65 73 
0058   D029 65 61 72 63 
0058   D02D 68 20 20 20 
0058   D031 20 20 20 
0059   D034 00 00 00 00 		.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0059   D038 00 00 00 00 
0059   D03C 00 00 00 00 
0059   D040 00 00 00 00 
0059   D044 00 00 00 00 
0059   D048 00 00 00 
0060   D04B 00 00 00 00 		.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0060   D04F 00 00 00 00 
0060   D053 00 00 00 00 
0060   D057 00 00 00 00 
0060   D05B 00 00 00 00 
0060   D05F 00 00 00 
0061   D062 00 00 00 00 		.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0061   D066 00 00 00 00 
0061   D06A 00 00 00 00 
0061   D06E 00 00 00 00 
0061   D072 00 00 00 00 
0061   D076 00 00 00 
0062   D079 00 00 00 00 		.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0062   D07D 00 00 00 00 
0062   D081 00 00 00 00 
0062   D085 00 00 00 
0063   D088 08 D0       INPOINT:	.DW	INBUFF+2		;input line pointer
0064   D08A 00 00       NAMEPNT:	.DW	0			;input line pointer used for error message. Points to
0065   D08C             ;						;start of name in error.
0066   D08C             ;
0067   D08C             ;   Routine to print (A) on the console. All registers used.
0068   D08C             ;
0069   D08C 5F          PRINT:	LD	E,A			;setup bdos call.
0070   D08D 0E 02       		LD	C,2
0071   D08F C3 05 00    		JP	ENTRY
0072   D092             ;
0073   D092             ;   Routine to print (A) on the console and to save (BC).
0074   D092             ;
0075   D092 C5          PRINTB:	PUSH	BC
0076   D093 CD 8C D0    		CALL	PRINT
0077   D096 C1          		POP	BC
0078   D097 C9          		RET	
0079   D098             ;
0080   D098             ;   Routine to send a carriage return, line feed combination
0081   D098             ; to the console.
0082   D098             ;
0083   D098 3E 0D       CRLF:		LD	A,CR
0084   D09A CD 92 D0    		CALL	PRINTB
0085   D09D 3E 0A       		LD	A,LF
0086   D09F C3 92 D0    		JP	PRINTB
0087   D0A2             ;
0088   D0A2             ;   Routine to send one space to the console and save (BC).
0089   D0A2             ;
0090   D0A2 3E 20       SPACE:	LD	A,' '
0091   D0A4 C3 92 D0    		JP	PRINTB
0092   D0A7             ;
0093   D0A7             ;   Routine to print character string pointed to be (BC) on the
0094   D0A7             ; console. It must terminate with a null byte.
0095   D0A7             ;
0096   D0A7 C5          PLINE:	PUSH	BC
0097   D0A8 CD 98 D0    		CALL	CRLF
0098   D0AB E1          		POP	HL
0099   D0AC 7E          PLINE2:	LD	A,(HL)
0100   D0AD B7          		OR	A
0101   D0AE C8          		RET	Z
0102   D0AF 23          		INC	HL
0103   D0B0 E5          		PUSH	HL
0104   D0B1 CD 8C D0    		CALL	PRINT
0105   D0B4 E1          		POP	HL
0106   D0B5 C3 AC D0    		JP	PLINE2
0107   D0B8             ;
0108   D0B8             ;   Routine to reset the disk system.
0109   D0B8             ;
0110   D0B8 0E 0D       RESDSK:	LD	C,13
0111   D0BA C3 05 00    		JP	ENTRY
0112   D0BD             ;
0113   D0BD             ;   Routine to select disk (A).
0114   D0BD             ;
0115   D0BD 5F          DSKSEL:	LD	E,A
0116   D0BE 0E 0E       		LD	C,14
0117   D0C0 C3 05 00    		JP	ENTRY
0118   D0C3             ;
0119   D0C3             ;   Routine to call bdos and save the return code. The zero
0120   D0C3             ; flag is set on a return of 0ffh.
0121   D0C3             ;
0122   D0C3 CD 05 00    ENTRY1:	CALL	ENTRY
0123   D0C6 32 F4 D7    		LD	(RTNCODE),A	;save return code.
0124   D0C9 3C          		INC	A			;set zero if 0ffh returned.
0125   D0CA C9          		RET	
0126   D0CB             ;
0127   D0CB             ;   Routine to open a file. (DE) must point to the FCB.
0128   D0CB             ;
0129   D0CB 0E 0F       OPEN:		LD	C,15
0130   D0CD C3 C3 D0    		JP	ENTRY1
0131   D0D0             ;
0132   D0D0             ;   Routine to open file at (FCB).
0133   D0D0             ;
0134   D0D0 AF          OPENFCB:	XOR	A			;clear the record number byte at fcb+32
0135   D0D1 32 F3 D7    		LD	(FCB+32),A
0136   D0D4 11 D3 D7    		LD	DE,FCB
0137   D0D7 C3 CB D0    		JP	OPEN
0138   D0DA             ;
0139   D0DA             ;   Routine to close a file. (DE) points to FCB.
0140   D0DA             ;
0141   D0DA 0E 10       CLOSE:	LD	C,16
0142   D0DC C3 C3 D0    		JP	ENTRY1
0143   D0DF             ;
0144   D0DF             ;   Routine to search for the first file with ambigueous name
0145   D0DF             ; (DE).
0146   D0DF             ;
0147   D0DF 0E 11       SRCHFST:	LD	C,17
0148   D0E1 C3 C3 D0    		JP	ENTRY1
0149   D0E4             ;
0150   D0E4             ;   Search for the next ambigeous file name.
0151   D0E4             ;
0152   D0E4 0E 12       SRCHNXT:	LD	C,18
0153   D0E6 C3 C3 D0    		JP	ENTRY1
0154   D0E9             ;
0155   D0E9             ;   Search for file at (FCB).
0156   D0E9             ;
0157   D0E9 11 D3 D7    SRCHFCB:	LD	DE,FCB
0158   D0EC C3 DF D0    		JP	SRCHFST
0159   D0EF             ;
0160   D0EF             ;   Routine to delete a file pointed to by (DE).
0161   D0EF             ;
0162   D0EF 0E 13       DELETE:	LD	C,19
0163   D0F1 C3 05 00    		JP	ENTRY
0164   D0F4             ;
0165   D0F4             ;   Routine to call the bdos and set the zero flag if a zero
0166   D0F4             ; status is returned.
0167   D0F4             ;
0168   D0F4 CD 05 00    ENTRY2:	CALL	ENTRY
0169   D0F7 B7          		OR	A			;set zero flag if appropriate.
0170   D0F8 C9          		RET	
0171   D0F9             ;
0172   D0F9             ;   Routine to read the next record from a sequential file.
0173   D0F9             ; (DE) points to the FCB.
0174   D0F9             ;
0175   D0F9 0E 14       RDREC:	LD	C,20
0176   D0FB C3 F4 D0    		JP	ENTRY2
0177   D0FE             ;
0178   D0FE             ;   Routine to read file at (FCB).
0179   D0FE             ;
0180   D0FE 11 D3 D7    READFCB:	LD	DE,FCB
0181   D101 C3 F9 D0    		JP	RDREC
0182   D104             ;
0183   D104             ;   Routine to write the next record of a sequential file.
0184   D104             ; (DE) points to the FCB.
0185   D104             ;
0186   D104 0E 15       WRTREC:	LD	C,21
0187   D106 C3 F4 D0    		JP	ENTRY2
0188   D109             ;
0189   D109             ;   Routine to create the file pointed to by (DE).
0190   D109             ;
0191   D109 0E 16       CREATE:	LD	C,22
0192   D10B C3 C3 D0    		JP	ENTRY1
0193   D10E             ;
0194   D10E             ;   Routine to rename the file pointed to by (DE). Note that
0195   D10E             ; the new name starts at (DE+16).
0196   D10E             ;
0197   D10E 0E 17       RENAM:	LD	C,23
0198   D110 C3 05 00    		JP	ENTRY
0199   D113             ;
0200   D113             ;   Get the current user code.
0201   D113             ;
0202   D113 1E FF       GETUSR:	LD	E,0FFH
0203   D115             ;
0204   D115             ;   Routne to get or set the current user code.
0205   D115             ; If (E) is FF then this is a GET, else it is a SET.
0206   D115             ;
0207   D115 0E 20       GETSETUC: 	LD	C,32
0208   D117 C3 05 00    		JP	ENTRY
0209   D11A             ;
0210   D11A             ;   Routine to set the current drive byte at (TDRIVE).
0211   D11A             ;
0212   D11A CD 13 D1    SETCDRV:	CALL	GETUSR		;get user number
0213   D11D 87          		ADD	A,A			;and shift into the upper 4 bits.
0214   D11E 87          		ADD	A,A
0215   D11F 87          		ADD	A,A
0216   D120 87          		ADD	A,A
0217   D121 21 F5 D7    		LD	HL,CDRIVE		;now add in the current drive number.
0218   D124 B6          		OR	(HL)
0219   D125 32 04 00    		LD	(TDRIVE),A		;and save.
0220   D128 C9          		RET	
0221   D129             ;
0222   D129             ;   Move currently active drive down to (TDRIVE).
0223   D129             ;
0224   D129 3A F5 D7    MOVECD:	LD	A,(CDRIVE)
0225   D12C 32 04 00    		LD	(TDRIVE),A
0226   D12F C9          		RET	
0227   D130             ;
0228   D130             ;   Routine to convert (A) into upper case ascii. Only letters
0229   D130             ; are affected.
0230   D130             ;
0231   D130 FE 61       UPPER:	CP	'a'			;check for letters in the range of 'a' to 'z'.
0232   D132 D8          		RET	C
0233   D133 FE 7B       		CP	'{'
0234   D135 D0          		RET	NC
0235   D136 E6 5F       		AND	5FH			;convert it if found.
0236   D138 C9          		RET	
0237   D139             ;
0238   D139             ;   Routine to get a line of input. We must check to see if the
0239   D139             ; user is in (BATCH) mode. If so, then read the input from file
0240   D139             ; ($$$.SUB). At the end, reset to console input.
0241   D139             ;
0242   D139 3A B1 D7    GETINP:	LD	A,(BATCH)		;if =0, then use console input.
0243   D13C B7          		OR	A
0244   D13D CA 96 D1    		JP	Z,GETINP1
0245   D140             ;
0246   D140             ;   Use the submit file ($$$.sub) which is prepared by a
0247   D140             ; SUBMIT run. It must be on drive (A) and it will be deleted
0248   D140             ; if and error occures (like eof).
0249   D140             ;
0250   D140 3A F5 D7    		LD	A,(CDRIVE)		;select drive 0 if need be.
0251   D143 B7          		OR	A
0252   D144 3E 00       		LD	A,0			;always use drive A for submit.
0253   D146 C4 BD D0    		CALL	NZ,DSKSEL		;select it if required.
0254   D149 11 B2 D7    		LD	DE,BATCHFCB
0255   D14C CD CB D0    		CALL	OPEN			;look for it.
0256   D14F CA 96 D1    		JP	Z,GETINP1		;if not there, use normal input.
0257   D152 3A C1 D7    		LD	A,(BATCHFCB+15)	;get last record number+1.
0258   D155 3D          		DEC	A
0259   D156 32 D2 D7    		LD	(BATCHFCB+32),A
0260   D159 11 B2 D7    		LD	DE,BATCHFCB
0261   D15C CD F9 D0    		CALL	RDREC			;read last record.
0262   D15F C2 96 D1    		JP	NZ,GETINP1		;quit on end of file.
0263   D162             ;
0264   D162             ;   Move this record into input buffer.
0265   D162             ;
0266   D162 11 07 D0    		LD	DE,INBUFF+1
0267   D165 21 80 00    		LD	HL,TBUFF		;data was read into buffer here.
0268   D168 06 80       		LD	B,128			;all 128 characters may be used.
0269   D16A CD 48 D4    		CALL	HL2DE			;(HL) to (DE), (B) bytes.
0270   D16D 21 C0 D7    	LD	HL,BATCHFCB+14
0271   D170 36 00       	LD	(HL),0		;zero out the 's2' byte.
0272   D172 23          	INC	HL			;and decrement the record count.
0273   D173 35          	DEC	(HL)
0274   D174 11 B2 D7    	LD	DE,BATCHFCB	;close the batch file now.
0275   D177 CD DA D0    	CALL	CLOSE
0276   D17A CA 96 D1    	JP	Z,GETINP1		;quit on an error.
0277   D17D 3A F5 D7    	LD	A,(CDRIVE)		;re-select previous drive if need be.
0278   D180 B7          	OR	A
0279   D181 C4 BD D0    	CALL	NZ,DSKSEL		;don't do needless selects.
0280   D184             ;
0281   D184             ;   Print line just read on console.
0282   D184             ;
0283   D184 21 08 D0    	LD	HL,INBUFF+2
0284   D187 CD AC D0    	CALL	PLINE2
0285   D18A CD C2 D1    	CALL	CHKCON		;check console, quit on a key.
0286   D18D CA A7 D1    	JP	Z,GETINP2		;jump if no key is pressed.
0287   D190             ;
0288   D190             ;   Terminate the submit job on any keyboard input. Delete this
0289   D190             ; file such that it is not re-started and jump to normal keyboard
0290   D190             ; input section.
0291   D190             ;
0292   D190 CD DD D1    	CALL	DELBATCH		;delete the batch file.
0293   D193 C3 86 D3    	JP	CMMND1		;and restart command input.
0294   D196             ;
0295   D196             ;   Get here for normal keyboard input. Delete the submit file
0296   D196             ; incase there was one.
0297   D196             ;
0298   D196 CD DD D1    GETINP1:	CALL	DELBATCH		;delete file ($$$.sub).
0299   D199 CD 1A D1    	CALL	SETCDRV		;reset active disk.
0300   D19C 0E 0A       	LD	C,10			;get line from console device.
0301   D19E 11 06 D0    	LD	DE,INBUFF
0302   D1A1 CD 05 00    	CALL	ENTRY
0303   D1A4 CD 29 D1    	CALL	MOVECD		;reset current drive (again).
0304   D1A7             ;
0305   D1A7             ;   Convert input line to upper case.
0306   D1A7             ;
0307   D1A7 21 07 D0    GETINP2:	LD	HL,INBUFF+1
0308   D1AA 46          		LD	B,(HL)		;(B)=character counter.
0309   D1AB 23          GETINP3:	INC	HL
0310   D1AC 78          	LD	A,B			;end of the line?
0311   D1AD B7          	OR	A
0312   D1AE CA BA D1    	JP	Z,GETINP4
0313   D1B1 7E          	LD	A,(HL)		;convert to upper case.
0314   D1B2 CD 30 D1    	CALL	UPPER
0315   D1B5 77          	LD	(HL),A
0316   D1B6 05          	DEC	B			;adjust character count.
0317   D1B7 C3 AB D1    	JP	GETINP3
0318   D1BA 77          GETINP4:	LD	(HL),A		;add trailing null.
0319   D1BB 21 08 D0    	LD	HL,INBUFF+2
0320   D1BE 22 88 D0    	LD	(INPOINT),HL	;reset input line pointer.
0321   D1C1 C9          	RET	
0322   D1C2             ;
0323   D1C2             ;   Routine to check the console for a key pressed. The zero
0324   D1C2             ; flag is set is none, else the character is returned in (A).
0325   D1C2             ;
0326   D1C2 0E 0B       CHKCON:	LD	C,11			;check console.
0327   D1C4 CD 05 00    	CALL	ENTRY
0328   D1C7 B7          	OR	A
0329   D1C8 C8          	RET	Z			;return if nothing.
0330   D1C9 0E 01       	LD	C,1			;else get character.
0331   D1CB CD 05 00    	CALL	ENTRY
0332   D1CE B7          	OR	A			;clear zero flag and return.
0333   D1CF C9          	RET	
0334   D1D0             ;
0335   D1D0             ;   Routine to get the currently active drive number.
0336   D1D0             ;
0337   D1D0 0E 19       GETDSK:	LD	C,25
0338   D1D2 C3 05 00    		JP	ENTRY
0339   D1D5             ;
0340   D1D5             ;   Set the stabdard dma address.
0341   D1D5             ;
0342   D1D5 11 80 00    STDDMA:	LD	DE,TBUFF
0343   D1D8             ;
0344   D1D8             ;   Routine to set the dma address to (DE).
0345   D1D8             ;
0346   D1D8 0E 1A       DMASET:	LD	C,26
0347   D1DA C3 05 00    		JP	ENTRY
0348   D1DD             ;
0349   D1DD             ;  Delete the batch file created by SUBMIT.
0350   D1DD             ;
0351   D1DD 21 B1 D7    DELBATCH: 	LD	HL,BATCH		;is batch active?
0352   D1E0 7E          	LD	A,(HL)
0353   D1E1 B7          	OR	A
0354   D1E2 C8          	RET	Z
0355   D1E3 36 00       	LD	(HL),0		;yes, de-activate it.
0356   D1E5 AF          	XOR	A
0357   D1E6 CD BD D0    	CALL	DSKSEL		;select drive 0 for sure.
0358   D1E9 11 B2 D7    	LD	DE,BATCHFCB	;and delete this file.
0359   D1EC CD EF D0    	CALL	DELETE
0360   D1EF 3A F5 D7    	LD	A,(CDRIVE)		;reset current drive.
0361   D1F2 C3 BD D0    	JP	DSKSEL
0362   D1F5             ;
0363   D1F5             ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
0364   D1F5             ; the same or we halt....
0365   D1F5             ;
0366   D1F5 11 2C D3    VERIFY:	LD	DE,PATTRN1		;these are the serial number bytes.
0367   D1F8 21 06 D8    	LD	HL,PATTRN2		;ditto, but how could they be different?
0368   D1FB 06 06       	LD	B,6			;6 bytes each.
0369   D1FD 1A          VERIFY1:	LD	A,(DE)
0370   D1FE BE          	CP	(HL)
0371   D1FF C2 D5 D3    	JP	NZ,HALT		;jump to halt routine.
0372   D202 13          	INC	DE
0373   D203 23          	INC	HL
0374   D204 05          	DEC	B
0375   D205 C2 FD D1    	JP	NZ,VERIFY1
0376   D208 C9          	RET	
0377   D209             ;
0378   D209             ;   Print back file name with a '?' to indicate a syntax error.
0379   D209             ;
0380   D209 CD 98 D0    SYNERR:	CALL	CRLF			;end current line.
0381   D20C 2A 8A D0    		LD	HL,(NAMEPNT)	;this points to name in error.
0382   D20F 7E          SYNERR1:	LD	A,(HL)		;print it until a space or null is found.
0383   D210 FE 20       	CP	' '
0384   D212 CA 22 D2    	JP	Z,SYNERR2
0385   D215 B7          	OR	A
0386   D216 CA 22 D2    	JP	Z,SYNERR2
0387   D219 E5          	PUSH	HL
0388   D21A CD 8C D0    	CALL	PRINT
0389   D21D E1          	POP	HL
0390   D21E 23          	INC	HL
0391   D21F C3 0F D2    	JP	SYNERR1
0392   D222 3E 3F       SYNERR2:	LD	A,'?'			;add trailing '?'.
0393   D224 CD 8C D0    	CALL	PRINT
0394   D227 CD 98 D0    	CALL	CRLF
0395   D22A CD DD D1    	CALL	DELBATCH		;delete any batch file.
0396   D22D C3 86 D3    	JP	CMMND1		;and restart from console input.
0397   D230             ;
0398   D230             ;   Check character at (DE) for legal command input. Note that the
0399   D230             ; zero flag is set if the character is a delimiter.
0400   D230             ;
0401   D230 1A          CHECK:	LD	A,(DE)
0402   D231 B7          	OR	A
0403   D232 C8          	RET	Z
0404   D233 FE 20       	CP	' '			;control characters are not legal here.
0405   D235 DA 09 D2    	JP	C,SYNERR
0406   D238 C8          	RET	Z			;check for valid delimiter.
0407   D239 FE 3D       	CP	'='
0408   D23B C8          	RET	Z
0409   D23C FE 5F       	CP	'_'
0410   D23E C8          	RET	Z
0411   D23F FE 2E       	CP	'.'
0412   D241 C8          	RET	Z
0413   D242 FE 3A       	CP	':'
0414   D244 C8          	RET	Z
0415   D245 FE 3B       	CP	03BH ; ';'
0416   D247 C8          	RET	Z
0417   D248 FE 3C       	CP	'<'
0418   D24A C8          	RET	Z
0419   D24B FE 3E       	CP	'>'
0420   D24D C8          	RET	Z
0421   D24E C9          	RET	
0422   D24F             ;
0423   D24F             ;   Get the next non-blank character from (DE).
0424   D24F             ;
0425   D24F 1A          NONBLANK: 	LD	A,(DE)
0426   D250 B7          	OR	A			;string ends with a null.
0427   D251 C8          	RET	Z
0428   D252 FE 20       	CP	' '
0429   D254 C0          	RET	NZ
0430   D255 13          	INC	DE
0431   D256 C3 4F D2    	JP	NONBLANK
0432   D259             ;
0433   D259             ;   Add (HL)=(HL)+(A)
0434   D259             ;
0435   D259 85          ADDHL:	ADD	A,L
0436   D25A 6F          	LD	L,A
0437   D25B D0          	RET	NC			;take care of any carry.
0438   D25C 24          	INC	H
0439   D25D C9          	RET	
0440   D25E             ;
0441   D25E             ;   Convert the first name in (FCB).
0442   D25E             ;
0443   D25E 3E 00       CONVFST:	LD	A,0
0444   D260             ;
0445   D260             ;   Format a file name (convert * to '?', etc.). On return,
0446   D260             ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
0447   D260             ; the position within the fcb for the name (either 0 or 16).
0448   D260             ;
0449   D260 21 D3 D7    CONVERT:	LD	HL,FCB
0450   D263 CD 59 D2    	CALL	ADDHL
0451   D266 E5          	PUSH	HL
0452   D267 E5          	PUSH	HL
0453   D268 AF          	XOR	A
0454   D269 32 F6 D7    	LD	(CHGDRV),A		;initialize drive change flag.
0455   D26C 2A 88 D0    	LD	HL,(INPOINT)	;set (HL) as pointer into input line.
0456   D26F EB          	EX	DE,HL
0457   D270 CD 4F D2    	CALL	NONBLANK		;get next non-blank character.
0458   D273 EB          	EX	DE,HL
0459   D274 22 8A D0    	LD	(NAMEPNT),HL	;save pointer here for any error message.
0460   D277 EB          	EX	DE,HL
0461   D278 E1          	POP	HL
0462   D279 1A          	LD	A,(DE)		;get first character.
0463   D27A B7          	OR	A
0464   D27B CA 89 D2    	JP	Z,CONVRT1
0465   D27E DE 40       	SBC	A,'A'-1		;might be a drive name, convert to binary.
0466   D280 47          	LD	B,A			;and save.
0467   D281 13          	INC	DE			;check next character for a ':'.
0468   D282 1A          	LD	A,(DE)
0469   D283 FE 3A       	CP	':'
0470   D285 CA 90 D2    	JP	Z,CONVRT2
0471   D288 1B          	DEC	DE			;nope, move pointer back to the start of the line.
0472   D289 3A F5 D7    CONVRT1:	LD	A,(CDRIVE)
0473   D28C 77          	LD	(HL),A
0474   D28D C3 96 D2    	JP	CONVRT3
0475   D290 78          CONVRT2:	LD	A,B
0476   D291 32 F6 D7    	LD	(CHGDRV),A		;set change in drives flag.
0477   D294 70          	LD	(HL),B
0478   D295 13          	INC	DE
0479   D296             ;
0480   D296             ;   Convert the basic file name.
0481   D296             ;
0482   D296 06 08       CONVRT3:	LD	B,08H
0483   D298 CD 30 D2    CONVRT4:	CALL	CHECK
0484   D29B CA B9 D2    	JP	Z,CONVRT8
0485   D29E 23          	INC	HL
0486   D29F FE 2A       	CP	'*'			;note that an '*' will fill the remaining
0487   D2A1 C2 A9 D2    	JP	NZ,CONVRT5		;field with '?'.
0488   D2A4 36 3F       	LD	(HL),'?'
0489   D2A6 C3 AB D2    	JP	CONVRT6
0490   D2A9 77          CONVRT5:	LD	(HL),A
0491   D2AA 13          		INC	DE
0492   D2AB 05          CONVRT6:	DEC	B
0493   D2AC C2 98 D2    		JP	NZ,CONVRT4
0494   D2AF CD 30 D2    CONVRT7:	CALL	CHECK			;get next delimiter.
0495   D2B2 CA C0 D2    	JP	Z,GETEXT
0496   D2B5 13          	INC	DE
0497   D2B6 C3 AF D2    	JP	CONVRT7
0498   D2B9 23          CONVRT8:	INC	HL			;blank fill the file name.
0499   D2BA 36 20       	LD	(HL),' '
0500   D2BC 05          	DEC	B
0501   D2BD C2 B9 D2    	JP	NZ,CONVRT8
0502   D2C0             ;
0503   D2C0             ;   Get the extension and convert it.
0504   D2C0             ;
0505   D2C0 06 03       GETEXT:	LD	B,03H
0506   D2C2 FE 2E       		CP	'.'
0507   D2C4 C2 E9 D2    		JP	NZ,GETEXT5
0508   D2C7 13          		INC	DE
0509   D2C8 CD 30 D2    GETEXT1:	CALL	CHECK
0510   D2CB CA E9 D2    	JP	Z,GETEXT5
0511   D2CE 23          	INC	HL
0512   D2CF FE 2A       	CP	'*'
0513   D2D1 C2 D9 D2    	JP	NZ,GETEXT2
0514   D2D4 36 3F       	LD	(HL),'?'
0515   D2D6 C3 DB D2    	JP	GETEXT3
0516   D2D9 77          GETEXT2:	LD	(HL),A
0517   D2DA 13          		INC	DE
0518   D2DB 05          GETEXT3:	DEC	B
0519   D2DC C2 C8 D2    		JP	NZ,GETEXT1
0520   D2DF CD 30 D2    GETEXT4:	CALL	CHECK
0521   D2E2 CA F0 D2    	JP	Z,GETEXT6
0522   D2E5 13          	INC	DE
0523   D2E6 C3 DF D2    	JP	GETEXT4
0524   D2E9 23          GETEXT5:	INC	HL
0525   D2EA 36 20       	LD	(HL),' '
0526   D2EC 05          	DEC	B
0527   D2ED C2 E9 D2    	JP	NZ,GETEXT5
0528   D2F0 06 03       GETEXT6:	LD	B,3
0529   D2F2 23          GETEXT7:	INC	HL
0530   D2F3 36 00       	LD	(HL),0
0531   D2F5 05          	DEC	B
0532   D2F6 C2 F2 D2    	JP	NZ,GETEXT7
0533   D2F9 EB          	EX	DE,HL
0534   D2FA 22 88 D0    	LD	(INPOINT),HL	;save input line pointer.
0535   D2FD E1          	POP	HL
0536   D2FE             ;
0537   D2FE             ;   Check to see if this is an ambigeous file name specification.
0538   D2FE             ; Set the (A) register to non zero if it is.
0539   D2FE             ;
0540   D2FE 01 0B 00    		LD	BC,11			;set name length.
0541   D301 23          GETEXT8:	INC	HL
0542   D302 7E          	LD	A,(HL)
0543   D303 FE 3F       	CP	'?'			;any question marks?
0544   D305 C2 09 D3    	JP	NZ,GETEXT9
0545   D308 04          	INC	B			;count them.
0546   D309 0D          GETEXT9:	DEC	C
0547   D30A C2 01 D3    	JP	NZ,GETEXT8
0548   D30D 78          	LD	A,B
0549   D30E B7          	OR	A
0550   D30F C9          	RET	
0551   D310             ;
0552   D310             ;   CP/M command table. Note commands can be either 3 or 4 characters long.
0553   D310             ;
0554   D310             NUMCMDS .EQU	7			;number of commands
0555   D310 44 49 52 20 CMDTBL:	.TEXT	"DIR "
0556   D314 45 52 41 20 		.TEXT	"ERA "
0557   D318 54 59 50 45 		.TEXT	"TYPE"
0558   D31C 53 41 56 45 		.TEXT	"SAVE"
0559   D320 52 45 4E 20 		.TEXT	"REN "
0560   D324 55 53 45 52 		.TEXT	"USER"
0561   D328 54 50 41 20 		.TEXT	"TPA "
0562   D32C             ;
0563   D32C             ;   The following six bytes must agree with those at (PATTRN2)
0564   D32C             ; or cp/m will HALT. Why?
0565   D32C             ;
0566   D32C 00 16 00 00 PATTRN1:	.DB	0,22,0,0,0,0	;(* serial number bytes *).
0566   D330 00 00 
0567   D332             ;
0568   D332             ;   Search the command table for a match with what has just
0569   D332             ; been entered. If a match is found, then we jump to the
0570   D332             ; proper section. Else jump to (UNKNOWN).
0571   D332             ; On return, the (C) register is set to the command number
0572   D332             ; that matched (or NUMCMDS+1 if no match).
0573   D332             ;
0574   D332 21 10 D3    SEARCH:	LD	HL,CMDTBL
0575   D335 0E 00       		LD	C,0
0576   D337 79          SEARCH1:	LD	A,C
0577   D338 FE 07       	CP	NUMCMDS		;this commands exists.
0578   D33A D0          	RET	NC
0579   D33B 11 D4 D7    	LD	DE,FCB+1		;check this one.
0580   D33E 06 04       	LD	B,4			;max command length.
0581   D340 1A          SEARCH2:	LD	A,(DE)	
0582   D341 BE          	CP	(HL)
0583   D342 C2 53 D3    	JP	NZ,SEARCH3		;not a match.
0584   D345 13          	INC	DE
0585   D346 23          	INC	HL
0586   D347 05          	DEC	B
0587   D348 C2 40 D3    	JP	NZ,SEARCH2
0588   D34B 1A          	LD	A,(DE)		;allow a 3 character command to match.
0589   D34C FE 20       	CP	' '
0590   D34E C2 58 D3    	JP	NZ,SEARCH4
0591   D351 79          	LD	A,C			;set return register for this command.
0592   D352 C9          	RET	
0593   D353 23          SEARCH3:	INC	HL
0594   D354 05          		DEC	B
0595   D355 C2 53 D3    		JP	NZ,SEARCH3
0596   D358 0C          SEARCH4:	INC	C
0597   D359 C3 37 D3    		JP	SEARCH1
0598   D35C             ;
0599   D35C             ;   Set the input buffer to empty and then start the command
0600   D35C             ; processor (ccp).
0601   D35C             ;
0602   D35C AF          CLEARBUF: 	XOR	A
0603   D35D 32 07 D0    		LD	(INBUFF+1),A	;second byte is actual length.
0604   D360             ;
0605   D360             ;**************************************************************
0606   D360             ;*
0607   D360             ;*
0608   D360             ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
0609   D360             ;*
0610   D360             ;**************************************************************
0611   D360             ;*
0612   D360 31 B1 D7    COMMAND:	LD	SP,CCPSTACK	;setup stack area.
0613   D363 C5          	PUSH	BC			;note that (C) should be equal to:
0614   D364 79          	LD	A,C			;(uuuudddd) where 'uuuu' is the user number
0615   D365 1F          	RRA				;and 'dddd' is the drive number.
0616   D366 1F          	RRA	
0617   D367 1F          	RRA	
0618   D368 1F          	RRA	
0619   D369 E6 0F       	AND	0FH			;isolate the user number.
0620   D36B 5F          	LD	E,A
0621   D36C CD 15 D1    	CALL	GETSETUC		;and set it.
0622   D36F CD B8 D0    	CALL	RESDSK		;reset the disk system.
0623   D372 32 B1 D7    	LD	(BATCH),A		;clear batch mode flag.
0624   D375 C1          	POP	BC
0625   D376 79          	LD	A,C
0626   D377 E6 0F       	AND	0FH			;isolate the drive number.
0627   D379 32 F5 D7    	LD	(CDRIVE),A		;and save.
0628   D37C CD BD D0    	CALL	DSKSEL		;...and select.
0629   D37F 3A 07 D0    	LD	A,(INBUFF+1)
0630   D382 B7          	OR	A			;anything in input buffer already?
0631   D383 C2 9C D3    	JP	NZ,CMMND2		;yes, we just process it.
0632   D386             ;
0633   D386             ;   Entry point to get a command line from the console.
0634   D386             ;
0635   D386 31 B1 D7    CMMND1:	LD	SP,CCPSTACK	;set stack straight.
0636   D389 CD 98 D0    	CALL	CRLF			;start a new line on the screen.
0637   D38C CD D0 D1    	CALL	GETDSK		;get current drive.
0638   D38F C6 41       	ADD	A,'A'
0639   D391 CD 8C D0    	CALL	PRINT			;print current drive.
0640   D394 3E 3E       	LD	A,'>'
0641   D396 CD 8C D0    	CALL	PRINT			;and add prompt.
0642   D399 CD 39 D1    	CALL	GETINP		;get line from user.
0643   D39C             ;
0644   D39C             ;   Process command line here.
0645   D39C             ;
0646   D39C 11 80 00    CMMND2:	LD	DE,TBUFF
0647   D39F CD D8 D1    	CALL	DMASET		;set standard dma address.
0648   D3A2 CD D0 D1    	CALL	GETDSK
0649   D3A5 32 F5 D7    	LD	(CDRIVE),A		;set current drive.
0650   D3A8 CD 5E D2    	CALL	CONVFST		;convert name typed in.
0651   D3AB C4 09 D2    	CALL	NZ,SYNERR		;wild cards are not allowed.
0652   D3AE 3A F6 D7    	LD	A,(CHGDRV)		;if a change in drives was indicated,
0653   D3B1 B7          	OR	A			;then treat this as an unknown command
0654   D3B2 C2 AB D6    	JP	NZ,UNKNOWN		;which gets executed.
0655   D3B5 CD 32 D3    	CALL	SEARCH		;else search command table for a match.
0656   D3B8             ;
0657   D3B8             ;   Note that an unknown command returns
0658   D3B8             ; with (A) pointing to the last address
0659   D3B8             ; in our table which is (UNKNOWN).
0660   D3B8             ;
0661   D3B8 21 C5 D3    	LD	HL,CMDADR		;now, look thru our address table for command (A).
0662   D3BB 5F          	LD	E,A			;set (DE) to command number.
0663   D3BC 16 00       	LD	D,0
0664   D3BE 19          	ADD	HL,DE
0665   D3BF 19          	ADD	HL,DE			;(HL)=(CMDADR)+2*(command number).
0666   D3C0 7E          	LD	A,(HL)		;now pick out this address.
0667   D3C1 23          	INC	HL
0668   D3C2 66          	LD	H,(HL)
0669   D3C3 6F          	LD	L,A
0670   D3C4 E9          	JP	(HL)			;now execute it.
0671   D3C5             ;
0672   D3C5             ;   CP/M command address table.
0673   D3C5             ;
0674   D3C5 7D D4 25 D5 CMDADR:	.DW	DIRECT,ERASE,TYPE,SAVE
0674   D3C9 63 D5 B3 D5 
0675   D3CD 16 D6 94 D6 		.DW	RENAME,USER,TBASE,UNKNOWN
0675   D3D1 00 01 AB D6 
0676   D3D5             ;
0677   D3D5             ;   Halt the system. Reason for this is unknown at present.
0678   D3D5             ;
0679   D3D5 21 F3 76    HALT:		LD	HL,76F3H		;'DI HLT' instructions.
0680   D3D8 22 00 D0    	LD	(CBASE),HL
0681   D3DB 21 00 D0    	LD	HL,CBASE
0682   D3DE E9          	JP	(HL)
0683   D3DF             ;
0684   D3DF             ;   Read error while TYPEing a file.
0685   D3DF             ;
0686   D3DF 01 E5 D3    RDERROR:	LD	BC,RDERR
0687   D3E2 C3 A7 D0    		JP	PLINE
0688   D3E5 52 65 61 64 RDERR:	.TEXT	"Read error"
0688   D3E9 20 65 72 72 
0688   D3ED 6F 72 
0689   D3EF 00          		.DB	0
0690   D3F0             ;
0691   D3F0             ;   Required file was not located.
0692   D3F0             ;
0693   D3F0 01 F6 D3    NONE:		LD	BC,NOFILE
0694   D3F3 C3 A7 D0    		JP	PLINE
0695   D3F6 4E 6F 20 66 NOFILE:	.TEXT	"No file"
0695   D3FA 69 6C 65 
0696   D3FD 00          		.DB	0
0697   D3FE             ;
0698   D3FE             ;   Decode a command of the form 'A>filename number{ filename}.
0699   D3FE             ; Note that a drive specifier is not allowed on the first file
0700   D3FE             ; name. On return, the number is in register (A). Any error
0701   D3FE             ; causes 'filename?' to be printed and the command is aborted.
0702   D3FE             ;
0703   D3FE CD 5E D2    DECODE:	CALL	CONVFST		;convert filename.
0704   D401 3A F6 D7    	LD	A,(CHGDRV)		;do not allow a drive to be specified.
0705   D404 B7          	OR	A
0706   D405 C2 09 D2    	JP	NZ,SYNERR
0707   D408 21 D4 D7    	LD	HL,FCB+1		;convert number now.
0708   D40B 01 0B 00    	LD	BC,11			;(B)=sum register, (C)=max digit count.
0709   D40E 7E          DECODE1:	LD	A,(HL)
0710   D40F FE 20       	CP	' '			;a space terminates the numeral.
0711   D411 CA 39 D4    	JP	Z,DECODE3
0712   D414 23          	INC	HL
0713   D415 D6 30       	SUB	'0'			;make binary from ascii.
0714   D417 FE 0A       	CP	10			;legal digit?
0715   D419 D2 09 D2    	JP	NC,SYNERR
0716   D41C 57          	LD	D,A			;yes, save it in (D).
0717   D41D 78          	LD	A,B			;compute (B)=(B)*10 and check for overflow.
0718   D41E E6 E0       	AND	0E0H
0719   D420 C2 09 D2    	JP	NZ,SYNERR
0720   D423 78          	LD	A,B
0721   D424 07          	RLCA	
0722   D425 07          	RLCA	
0723   D426 07          	RLCA				;(A)=(B)*8
0724   D427 80          	ADD	A,B			;.......*9
0725   D428 DA 09 D2    	JP	C,SYNERR
0726   D42B 80          	ADD	A,B			;.......*10
0727   D42C DA 09 D2    	JP	C,SYNERR
0728   D42F 82          	ADD	A,D			;add in new digit now.
0729   D430 DA 09 D2    DECODE2:	JP	C,SYNERR
0730   D433 47          	LD	B,A			;and save result.
0731   D434 0D          	DEC	C			;only look at 11 digits.
0732   D435 C2 0E D4    	JP	NZ,DECODE1
0733   D438 C9          	RET	
0734   D439 7E          DECODE3:	LD	A,(HL)		;spaces must follow (why?).
0735   D43A FE 20       	CP	' '
0736   D43C C2 09 D2    	JP	NZ,SYNERR
0737   D43F 23          	INC	HL
0738   D440 0D          DECODE4:	DEC	C
0739   D441 C2 39 D4    	JP	NZ,DECODE3
0740   D444 78          	LD	A,B			;set (A)=the numeric value entered.
0741   D445 C9          	RET	
0742   D446             ;
0743   D446             ;   Move 3 bytes from (HL) to (DE). Note that there is only
0744   D446             ; one reference to this at (A2D5h).
0745   D446             ;
0746   D446 06 03       MOVE3:	LD	B,3
0747   D448             ;
0748   D448             ;   Move (B) bytes from (HL) to (DE).
0749   D448             ;
0750   D448 7E          HL2DE:	LD	A,(HL)
0751   D449 12          	LD	(DE),A
0752   D44A 23          	INC	HL
0753   D44B 13          	INC	DE
0754   D44C 05          	DEC	B
0755   D44D C2 48 D4    	JP	NZ,HL2DE
0756   D450 C9          	RET	
0757   D451             ;
0758   D451             ;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
0759   D451             ;
0760   D451 21 80 00    EXTRACT:	LD	HL,TBUFF
0761   D454 81          	ADD	A,C
0762   D455 CD 59 D2    	CALL	ADDHL
0763   D458 7E          	LD	A,(HL)
0764   D459 C9          	RET	
0765   D45A             ;
0766   D45A             ;  Check drive specified. If it means a change, then the new
0767   D45A             ; drive will be selected. In any case, the drive byte of the
0768   D45A             ; fcb will be set to null (means use current drive).
0769   D45A             ;
0770   D45A AF          DSELECT:	XOR	A			;null out first byte of fcb.
0771   D45B 32 D3 D7    	LD	(FCB),A	
0772   D45E 3A F6 D7    	LD	A,(CHGDRV)		;a drive change indicated?
0773   D461 B7          	OR	A
0774   D462 C8          	RET	Z
0775   D463 3D          	DEC	A			;yes, is it the same as the current drive?
0776   D464 21 F5 D7    	LD	HL,CDRIVE
0777   D467 BE          	CP	(HL)
0778   D468 C8          	RET	Z
0779   D469 C3 BD D0    	JP	DSKSEL		;no. Select it then.
0780   D46C             ;
0781   D46C             ;   Check the drive selection and reset it to the previous
0782   D46C             ; drive if it was changed for the preceeding command.
0783   D46C             ;
0784   D46C 3A F6 D7    RESETDR:	LD	A,(CHGDRV)		;drive change indicated?
0785   D46F B7          	OR	A
0786   D470 C8          	RET	Z
0787   D471 3D          	DEC	A			;yes, was it a different drive?
0788   D472 21 F5 D7    	LD	HL,CDRIVE
0789   D475 BE          	CP	(HL)
0790   D476 C8          	RET	Z
0791   D477 3A F5 D7    	LD	A,(CDRIVE)		;yes, re-select our old drive.
0792   D47A C3 BD D0    	JP	DSKSEL
0793   D47D             ;
0794   D47D             ;**************************************************************
0795   D47D             ;*
0796   D47D             ;*           D I R E C T O R Y   C O M M A N D
0797   D47D             ;*
0798   D47D             ;**************************************************************
0799   D47D             ;
0800   D47D CD 5E D2    DIRECT:	CALL	CONVFST		;convert file name.
0801   D480 CD 5A D4    	CALL	DSELECT		;select indicated drive.
0802   D483 21 D4 D7    	LD	HL,FCB+1		;was any file indicated?
0803   D486 7E          	LD	A,(HL)
0804   D487 FE 20       	CP	' '
0805   D489 C2 95 D4    	JP	NZ,DIRECT2
0806   D48C 06 0B       	LD	B,11			;no. Fill field with '?' - same as *.*.
0807   D48E 36 3F       DIRECT1:	LD	(HL),'?'
0808   D490 23          	INC	HL
0809   D491 05          	DEC	B
0810   D492 C2 8E D4    	JP	NZ,DIRECT1
0811   D495 1E 00       DIRECT2:	LD	E,0			;set initial cursor position.
0812   D497 D5          	PUSH	DE
0813   D498 CD E9 D0    	CALL	SRCHFCB		;get first file name.
0814   D49B CC F0 D3    	CALL	Z,NONE		;none found at all?
0815   D49E CA 21 D5    DIRECT3:	JP	Z,DIRECT9		;terminate if no more names.
0816   D4A1 3A F4 D7    	LD	A,(RTNCODE)	;get file's position in segment (0-3).
0817   D4A4 0F          	RRCA	
0818   D4A5 0F          	RRCA	
0819   D4A6 0F          	RRCA	
0820   D4A7 E6 60       	AND	60H			;(A)=position*32
0821   D4A9 4F          	LD	C,A
0822   D4AA 3E 0A       	LD	A,10
0823   D4AC CD 51 D4    	CALL	EXTRACT		;extract the tenth entry in fcb.
0824   D4AF 17          	RLA				;check system file status bit.
0825   D4B0 DA 15 D5    	JP	C,DIRECT8		;we don't list them.
0826   D4B3 D1          	POP	DE
0827   D4B4 7B          	LD	A,E			;bump name count.
0828   D4B5 1C          	INC	E
0829   D4B6 D5          	PUSH	DE
0830   D4B7 E6 03       	AND	03H			;at end of line?
0831   D4B9 F5          	PUSH	AF
0832   D4BA C2 D2 D4    	JP	NZ,DIRECT4
0833   D4BD CD 98 D0    	CALL	CRLF			;yes, end this line and start another.
0834   D4C0 C5          	PUSH	BC
0835   D4C1 CD D0 D1    	CALL	GETDSK		;start line with ('A:').
0836   D4C4 C1          	POP	BC
0837   D4C5 C6 41       	ADD	A,'A'
0838   D4C7 CD 92 D0    	CALL	PRINTB
0839   D4CA 3E 3A       	LD	A,':'
0840   D4CC CD 92 D0    	CALL	PRINTB
0841   D4CF C3 DA D4    	JP	DIRECT5
0842   D4D2 CD A2 D0    DIRECT4:	CALL	SPACE			;add seperator between file names.
0843   D4D5 3E 3A       	LD	A,':'
0844   D4D7 CD 92 D0    	CALL	PRINTB
0845   D4DA CD A2 D0    DIRECT5:	CALL	SPACE
0846   D4DD 06 01       		LD	B,1			;'extract' each file name character at a time.
0847   D4DF 78          DIRECT6:	LD	A,B
0848   D4E0 CD 51 D4    	CALL	EXTRACT
0849   D4E3 E6 7F       	AND	7FH			;strip bit 7 (status bit).
0850   D4E5 FE 20       	CP	' '			;are we at the end of the name?
0851   D4E7 C2 FF D4    	JP	NZ,DRECT65
0852   D4EA F1          	POP	AF			;yes, don't print spaces at the end of a line.
0853   D4EB F5          	PUSH	AF
0854   D4EC FE 03       	CP	3
0855   D4EE C2 FD D4    	JP	NZ,DRECT63
0856   D4F1 3E 09       	LD	A,9			;first check for no extension.
0857   D4F3 CD 51 D4    	CALL	EXTRACT
0858   D4F6 E6 7F       	AND	7FH
0859   D4F8 FE 20       	CP	' '
0860   D4FA CA 14 D5    	JP	Z,DIRECT7		;don't print spaces.
0861   D4FD 3E 20       DRECT63:	LD	A,' '			;else print them.
0862   D4FF CD 92 D0    DRECT65:	CALL	PRINTB
0863   D502 04          	INC	B			;bump to next character psoition.
0864   D503 78          	LD	A,B
0865   D504 FE 0C       	CP	12			;end of the name?
0866   D506 D2 14 D5    	JP	NC,DIRECT7
0867   D509 FE 09       	CP	9			;nope, starting extension?
0868   D50B C2 DF D4    	JP	NZ,DIRECT6
0869   D50E CD A2 D0    	CALL	SPACE			;yes, add seperating space.
0870   D511 C3 DF D4    	JP	DIRECT6
0871   D514 F1          DIRECT7:	POP	AF			;get the next file name.
0872   D515 CD C2 D1    DIRECT8:	CALL	CHKCON		;first check console, quit on anything.
0873   D518 C2 21 D5    	JP	NZ,DIRECT9
0874   D51B CD E4 D0    	CALL	SRCHNXT		;get next name.
0875   D51E C3 9E D4    	JP	DIRECT3		;and continue with our list.
0876   D521 D1          DIRECT9:	POP	DE			;restore the stack and return to command level.
0877   D522 C3 8C D7    		JP	GETBACK
0878   D525             ;
0879   D525             ;**************************************************************
0880   D525             ;*
0881   D525             ;*                E R A S E   C O M M A N D
0882   D525             ;*
0883   D525             ;**************************************************************
0884   D525             ;
0885   D525 CD 5E D2    ERASE:	CALL	CONVFST		;convert file name.
0886   D528 FE 0B       	CP	11			;was '*.*' entered?
0887   D52A C2 48 D5    	JP	NZ,ERASE1
0888   D52D 01 58 D5    	LD	BC,YESNO		;yes, ask for confirmation.
0889   D530 CD A7 D0    	CALL	PLINE
0890   D533 CD 39 D1    	CALL	GETINP
0891   D536 21 07 D0    	LD	HL,INBUFF+1
0892   D539 35          	DEC	(HL)			;must be exactly 'y'.
0893   D53A C2 86 D3    	JP	NZ,CMMND1
0894   D53D 23          	INC	HL
0895   D53E 7E          	LD	A,(HL)
0896   D53F FE 59       	CP	'Y'
0897   D541 C2 86 D3    	JP	NZ,CMMND1
0898   D544 23          	INC	HL
0899   D545 22 88 D0    	LD	(INPOINT),HL	;save input line pointer.
0900   D548 CD 5A D4    ERASE1:	CALL	DSELECT		;select desired disk.
0901   D54B 11 D3 D7    	LD	DE,FCB
0902   D54E CD EF D0    	CALL	DELETE		;delete the file.
0903   D551 3C          	INC	A
0904   D552 CC F0 D3    	CALL	Z,NONE		;not there?
0905   D555 C3 8C D7    	JP	GETBACK		;return to command level now.
0906   D558 41 6C 6C 20 YESNO:	.TEXT	"All (y/n)?"
0906   D55C 28 79 2F 6E 
0906   D560 29 3F 
0907   D562 00          		.DB	0
0908   D563             ;
0909   D563             ;**************************************************************
0910   D563             ;*
0911   D563             ;*            T Y P E   C O M M A N D
0912   D563             ;*
0913   D563             ;**************************************************************
0914   D563             ;
0915   D563 CD 5E D2    TYPE:		CALL	CONVFST		;convert file name.
0916   D566 C2 09 D2    	JP	NZ,SYNERR		;wild cards not allowed.
0917   D569 CD 5A D4    	CALL	DSELECT		;select indicated drive.
0918   D56C CD D0 D0    	CALL	OPENFCB		;open the file.
0919   D56F CA AD D5    	JP	Z,TYPE5		;not there?
0920   D572 CD 98 D0    	CALL	CRLF			;ok, start a new line on the screen.
0921   D575 21 F7 D7    	LD	HL,NBYTES		;initialize byte counter.
0922   D578 36 FF       	LD	(HL),0FFH		;set to read first sector.
0923   D57A 21 F7 D7    TYPE1:	LD	HL,NBYTES
0924   D57D 7E          TYPE2:	LD	A,(HL)		;have we written the entire sector?
0925   D57E FE 80       	CP	128
0926   D580 DA 8D D5    	JP	C,TYPE3
0927   D583 E5          	PUSH	HL			;yes, read in the next one.
0928   D584 CD FE D0    	CALL	READFCB
0929   D587 E1          	POP	HL
0930   D588 C2 A6 D5    	JP	NZ,TYPE4		;end or error?
0931   D58B AF          	XOR	A			;ok, clear byte counter.
0932   D58C 77          	LD	(HL),A
0933   D58D 34          TYPE3:	INC	(HL)			;count this byte.
0934   D58E 21 80 00    	LD	HL,TBUFF		;and get the (A)th one from the buffer (TBUFF).
0935   D591 CD 59 D2    	CALL	ADDHL
0936   D594 7E          	LD	A,(HL)
0937   D595 FE 1A       	CP	CNTRLZ		;end of file mark?
0938   D597 CA 8C D7    	JP	Z,GETBACK
0939   D59A CD 8C D0    	CALL	PRINT			;no, print it.
0940   D59D CD C2 D1    	CALL	CHKCON		;check console, quit if anything ready.
0941   D5A0 C2 8C D7    	JP	NZ,GETBACK
0942   D5A3 C3 7A D5    	JP	TYPE1
0943   D5A6             ;
0944   D5A6             ;   Get here on an end of file or read error.
0945   D5A6             ;
0946   D5A6 3D          TYPE4:	DEC	A			;read error?
0947   D5A7 CA 8C D7    	JP	Z,GETBACK	
0948   D5AA CD DF D3    	CALL	RDERROR		;yes, print message.
0949   D5AD CD 6C D4    TYPE5:	CALL	RESETDR		;and reset proper drive
0950   D5B0 C3 09 D2    		JP	SYNERR		;now print file name with problem.
0951   D5B3             ;
0952   D5B3             ;**************************************************************
0953   D5B3             ;*
0954   D5B3             ;*            S A V E   C O M M A N D
0955   D5B3             ;*
0956   D5B3             ;**************************************************************
0957   D5B3             ;
0958   D5B3 CD FE D3    SAVE:		CALL	DECODE		;get numeric number that follows SAVE.
0959   D5B6 F5          	PUSH	AF			;save number of pages to write.
0960   D5B7 CD 5E D2    	CALL	CONVFST		;convert file name.
0961   D5BA C2 09 D2    	JP	NZ,SYNERR		;wild cards not allowed.
0962   D5BD CD 5A D4    	CALL	DSELECT		;select specified drive.
0963   D5C0 11 D3 D7    	LD	DE,FCB		;now delete this file.
0964   D5C3 D5          	PUSH	DE
0965   D5C4 CD EF D0    	CALL	DELETE
0966   D5C7 D1          	POP	DE
0967   D5C8 CD 09 D1    	CALL	CREATE		;and create it again.
0968   D5CB CA 01 D6    	JP	Z,SAVE3		;can't create?
0969   D5CE AF          	XOR	A			;clear record number byte.
0970   D5CF 32 F3 D7    	LD	(FCB+32),A
0971   D5D2 F1          	POP	AF			;convert pages to sectors.
0972   D5D3 6F          	LD	L,A
0973   D5D4 26 00       	LD	H,0
0974   D5D6 29          	ADD	HL,HL			;(HL)=number of sectors to write.
0975   D5D7 11 00 01    	LD	DE,TBASE		;and we start from here.
0976   D5DA 7C          SAVE1:	LD	A,H			;done yet?
0977   D5DB B5          	OR	L
0978   D5DC CA F7 D5    	JP	Z,SAVE2
0979   D5DF 2B          	DEC	HL			;nope, count this and compute the start
0980   D5E0 E5          	PUSH	HL			;of the next 128 byte sector.
0981   D5E1 21 80 00    	LD	HL,128
0982   D5E4 19          	ADD	HL,DE
0983   D5E5 E5          	PUSH	HL			;save it and set the transfer address.
0984   D5E6 CD D8 D1    	CALL	DMASET
0985   D5E9 11 D3 D7    	LD	DE,FCB		;write out this sector now.
0986   D5EC CD 04 D1    	CALL	WRTREC
0987   D5EF D1          	POP	DE			;reset (DE) to the start of the last sector.
0988   D5F0 E1          	POP	HL			;restore sector count.
0989   D5F1 C2 01 D6    	JP	NZ,SAVE3		;write error?
0990   D5F4 C3 DA D5    	JP	SAVE1
0991   D5F7             ;
0992   D5F7             ;   Get here after writing all of the file.
0993   D5F7             ;
0994   D5F7 11 D3 D7    SAVE2:	LD	DE,FCB		;now close the file.
0995   D5FA CD DA D0    	CALL	CLOSE
0996   D5FD 3C          	INC	A			;did it close ok?
0997   D5FE C2 07 D6    	JP	NZ,SAVE4
0998   D601             ;
0999   D601             ;   Print out error message (no space).
1000   D601             ;
1001   D601 01 0D D6    SAVE3:	LD	BC,NOSPACE
1002   D604 CD A7 D0    		CALL	PLINE
1003   D607 CD D5 D1    SAVE4:	CALL	STDDMA		;reset the standard dma address.
1004   D60A C3 8C D7    		JP	GETBACK
1005   D60D 4E 6F 20 73 NOSPACE:	.TEXT	"No space"
1005   D611 70 61 63 65 
1006   D615 00          		.DB	0
1007   D616             ;
1008   D616             ;**************************************************************
1009   D616             ;*
1010   D616             ;*           R E N A M E   C O M M A N D
1011   D616             ;*
1012   D616             ;**************************************************************
1013   D616             ;
1014   D616 CD 5E D2    RENAME:	CALL	CONVFST		;convert first file name.
1015   D619 C2 09 D2    	JP	NZ,SYNERR		;wild cards not allowed.
1016   D61C 3A F6 D7    	LD	A,(CHGDRV)		;remember any change in drives specified.
1017   D61F F5          	PUSH	AF
1018   D620 CD 5A D4    	CALL	DSELECT		;and select this drive.
1019   D623 CD E9 D0    	CALL	SRCHFCB		;is this file present?
1020   D626 C2 7F D6    	JP	NZ,RENAME6		;yes, print error message.
1021   D629 21 D3 D7    	LD	HL,FCB		;yes, move this name into second slot.
1022   D62C 11 E3 D7    	LD	DE,FCB+16
1023   D62F 06 10       	LD	B,16
1024   D631 CD 48 D4    	CALL	HL2DE
1025   D634 2A 88 D0    	LD	HL,(INPOINT)	;get input pointer.
1026   D637 EB          	EX	DE,HL
1027   D638 CD 4F D2    	CALL	NONBLANK		;get next non blank character.
1028   D63B FE 3D       	CP	'='			;only allow an '=' or '_' seperator.
1029   D63D CA 45 D6    	JP	Z,RENAME1
1030   D640 FE 5F       	CP	'_'
1031   D642 C2 79 D6    	JP	NZ,RENAME5
1032   D645 EB          RENAME1:	EX	DE,HL
1033   D646 23          	INC	HL			;ok, skip seperator.
1034   D647 22 88 D0    	LD	(INPOINT),HL	;save input line pointer.
1035   D64A CD 5E D2    	CALL	CONVFST		;convert this second file name now.
1036   D64D C2 79 D6    	JP	NZ,RENAME5		;again, no wild cards.
1037   D650 F1          	POP	AF			;if a drive was specified, then it
1038   D651 47          	LD	B,A			;must be the same as before.
1039   D652 21 F6 D7    	LD	HL,CHGDRV
1040   D655 7E          	LD	A,(HL)
1041   D656 B7          	OR	A
1042   D657 CA 5F D6    	JP	Z,RENAME2
1043   D65A B8          	CP	B
1044   D65B 70          	LD	(HL),B
1045   D65C C2 79 D6    	JP	NZ,RENAME5		;they were different, error.
1046   D65F 70          RENAME2:	LD	(HL),B		;	reset as per the first file specification.
1047   D660 AF          	XOR	A
1048   D661 32 D3 D7    	LD	(FCB),A		;clear the drive byte of the fcb.
1049   D664 CD E9 D0    RENAME3:	CALL	SRCHFCB		;and go look for second file.
1050   D667 CA 73 D6    	JP	Z,RENAME4		;doesn't exist?
1051   D66A 11 D3 D7    	LD	DE,FCB
1052   D66D CD 0E D1    	CALL	RENAM			;ok, rename the file.
1053   D670 C3 8C D7    	JP	GETBACK
1054   D673             ;
1055   D673             ;   Process rename errors here.
1056   D673             ;
1057   D673 CD F0 D3    RENAME4:	CALL	NONE			;file not there.
1058   D676 C3 8C D7    		JP	GETBACK
1059   D679 CD 6C D4    RENAME5:	CALL	RESETDR		;bad command format.
1060   D67C C3 09 D2    		JP	SYNERR
1061   D67F 01 88 D6    RENAME6:	LD	BC,EXISTS		;destination file already exists.
1062   D682 CD A7 D0    	CALL	PLINE
1063   D685 C3 8C D7    	JP	GETBACK
1064   D688 46 69 6C 65 EXISTS:	.TEXT	"File exists"
1064   D68C 20 65 78 69 
1064   D690 73 74 73 
1065   D693 00          		.DB	0
1066   D694             ;
1067   D694             ;**************************************************************
1068   D694             ;*
1069   D694             ;*             U S E R   C O M M A N D
1070   D694             ;*
1071   D694             ;**************************************************************
1072   D694             ;
1073   D694 CD FE D3    USER:		CALL	DECODE		;get numeric value following command.
1074   D697 FE 10       	CP	16			;legal user number?
1075   D699 D2 09 D2    	JP	NC,SYNERR
1076   D69C 5F          	LD	E,A			;yes but is there anything else?
1077   D69D 3A D4 D7    	LD	A,(FCB+1)
1078   D6A0 FE 20       	CP	' '
1079   D6A2 CA 09 D2    	JP	Z,SYNERR		;yes, that is not allowed.
1080   D6A5 CD 15 D1    	CALL	GETSETUC		;ok, set user code.
1081   D6A8 C3 8F D7    	JP	GETBACK1
1082   D6AB             ;
1083   D6AB             ;**************************************************************
1084   D6AB             ;*
1085   D6AB             ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
1086   D6AB             ;*
1087   D6AB             ;**************************************************************
1088   D6AB             ;
1089   D6AB CD F5 D1    UNKNOWN:	CALL	VERIFY		;check for valid system (why?).
1090   D6AE 3A D4 D7    	LD	A,(FCB+1)		;anything to execute?
1091   D6B1 FE 20       	CP	' '
1092   D6B3 C2 CA D6    	JP	NZ,UNKWN1
1093   D6B6 3A F6 D7    	LD	A,(CHGDRV)		;nope, only a drive change?
1094   D6B9 B7          	OR	A
1095   D6BA CA 8F D7    	JP	Z,GETBACK1		;neither???
1096   D6BD 3D          	DEC	A
1097   D6BE 32 F5 D7    	LD	(CDRIVE),A		;ok, store new drive.
1098   D6C1 CD 29 D1    	CALL	MOVECD		;set (TDRIVE) also.
1099   D6C4 CD BD D0    	CALL	DSKSEL		;and select this drive.
1100   D6C7 C3 8F D7    	JP	GETBACK1		;then return.
1101   D6CA             ;
1102   D6CA             ;   Here a file name was typed. Prepare to execute it.
1103   D6CA             ;
1104   D6CA 11 DC D7    UNKWN1:	LD	DE,FCB+9		;an extension specified?
1105   D6CD 1A          	LD	A,(DE)
1106   D6CE FE 20       	CP	' '
1107   D6D0 C2 09 D2    	JP	NZ,SYNERR		;yes, not allowed.
1108   D6D3 D5          UNKWN2:	PUSH	DE
1109   D6D4 CD 5A D4    	CALL	DSELECT		;select specified drive.
1110   D6D7 D1          	POP	DE
1111   D6D8 21 89 D7    	LD	HL,COMFILE		;set the extension to 'COM'.
1112   D6DB CD 46 D4    	CALL	MOVE3
1113   D6DE CD D0 D0    	CALL	OPENFCB		;and open this file.
1114   D6E1 CA 71 D7    	JP	Z,UNKWN9		;not present?
1115   D6E4             ;
1116   D6E4             ;   Load in the program.
1117   D6E4             ;
1118   D6E4 21 00 01    		LD	HL,TBASE		;store the program starting here.
1119   D6E7 E5          UNKWN3:	PUSH	HL
1120   D6E8 EB          	EX	DE,HL
1121   D6E9 CD D8 D1    	CALL	DMASET		;set transfer address.
1122   D6EC 11 D3 D7    	LD	DE,FCB		;and read the next record.
1123   D6EF CD F9 D0    	CALL	RDREC
1124   D6F2 C2 07 D7    	JP	NZ,UNKWN4		;end of file or read error?
1125   D6F5 E1          	POP	HL			;nope, bump pointer for next sector.
1126   D6F6 11 80 00    	LD	DE,128
1127   D6F9 19          	ADD	HL,DE
1128   D6FA 11 00 D0    	LD	DE,CBASE		;enough room for the whole file?
1129   D6FD 7D          	LD	A,L
1130   D6FE 93          	SUB	E
1131   D6FF 7C          	LD	A,H
1132   D700 9A          	SBC	A,D
1133   D701 D2 77 D7    	JP	NC,UNKWN0		;no, it can't fit.
1134   D704 C3 E7 D6    	JP	UNKWN3
1135   D707             ;
1136   D707             ;   Get here after finished reading.
1137   D707             ;
1138   D707 E1          UNKWN4:	POP	HL
1139   D708 3D          	DEC	A			;normal end of file?
1140   D709 C2 77 D7    	JP	NZ,UNKWN0
1141   D70C CD 6C D4    	CALL	RESETDR		;yes, reset previous drive.
1142   D70F CD 5E D2    	CALL	CONVFST		;convert the first file name that follows
1143   D712 21 F6 D7    	LD	HL,CHGDRV		;command name.
1144   D715 E5          	PUSH	HL
1145   D716 7E          	LD	A,(HL)		;set drive code in default fcb.
1146   D717 32 D3 D7    	LD	(FCB),A
1147   D71A 3E 10       	LD	A,16			;put second name 16 bytes later.
1148   D71C CD 60 D2    	CALL	CONVERT		;convert second file name.
1149   D71F E1          	POP	HL
1150   D720 7E          	LD	A,(HL)		;and set the drive for this second file.
1151   D721 32 E3 D7    	LD	(FCB+16),A
1152   D724 AF          	XOR	A			;clear record byte in fcb.
1153   D725 32 F3 D7    	LD	(FCB+32),A
1154   D728 11 5C 00    	LD	DE,TFCB		;move it into place at(005Ch).
1155   D72B 21 D3 D7    	LD	HL,FCB
1156   D72E 06 21       	LD	B,33
1157   D730 CD 48 D4    	CALL	HL2DE
1158   D733 21 08 D0    	LD	HL,INBUFF+2	;now move the remainder of the input
1159   D736 7E          UNKWN5:	LD	A,(HL)		;line down to (0080h). Look for a non blank.
1160   D737 B7          	OR	A			;or a null.
1161   D738 CA 44 D7    	JP	Z,UNKWN6
1162   D73B FE 20       	CP	' '
1163   D73D CA 44 D7    	JP	Z,UNKWN6
1164   D740 23          	INC	HL
1165   D741 C3 36 D7    	JP	UNKWN5
1166   D744             ;
1167   D744             ;   Do the line move now. It ends in a null byte.
1168   D744             ;
1169   D744 06 00       UNKWN6:	LD	B,0			;keep a character count.
1170   D746 11 81 00    		LD	DE,TBUFF+1		;data gets put here.
1171   D749 7E          UNKWN7:	LD	A,(HL)		;move it now.
1172   D74A 12          	LD	(DE),A
1173   D74B B7          	OR	A
1174   D74C CA 55 D7    	JP	Z,UNKWN8
1175   D74F 04          	INC	B
1176   D750 23          	INC	HL
1177   D751 13          	INC	DE
1178   D752 C3 49 D7    	JP	UNKWN7
1179   D755 78          UNKWN8:	LD	A,B			;now store the character count.
1180   D756 32 80 00    	LD	(TBUFF),A
1181   D759 CD 98 D0    	CALL	CRLF			;clean up the screen.
1182   D75C CD D5 D1    	CALL	STDDMA		;set standard transfer address.
1183   D75F CD 1A D1    	CALL	SETCDRV		;reset current drive.
1184   D762 CD 00 01    	CALL	TBASE			;and execute the program.
1185   D765             ;
1186   D765             ;   Transiant programs return here (or reboot).
1187   D765             ;
1188   D765 31 B1 D7    	LD	SP,BATCH		;set stack first off.
1189   D768 CD 29 D1    	CALL	MOVECD		;move current drive into place (TDRIVE).
1190   D76B CD BD D0    	CALL	DSKSEL		;and reselect it.
1191   D76E C3 86 D3    	JP	CMMND1		;back to comand mode.
1192   D771             ;
1193   D771             ;   Get here if some error occured.
1194   D771             ;
1195   D771 CD 6C D4    UNKWN9:	CALL	RESETDR		;inproper format.
1196   D774 C3 09 D2    		JP	SYNERR
1197   D777 01 80 D7    UNKWN0:	LD	BC,BADLOAD		;read error or won't fit.
1198   D77A CD A7 D0    	CALL	PLINE
1199   D77D C3 8C D7    	JP	GETBACK
1200   D780 42 61 64 20 BADLOAD:	.TEXT	"Bad load"
1200   D784 6C 6F 61 64 
1201   D788 00          		.DB	0
1202   D789 43 4F 4D    COMFILE:	.TEXT	"COM"			;command file extension.
1203   D78C             ;
1204   D78C             ;   Get here to return to command level. We will reset the
1205   D78C             ; previous active drive and then either return to command
1206   D78C             ; level directly or print error message and then return.
1207   D78C             ;
1208   D78C CD 6C D4    GETBACK:	CALL	RESETDR		;reset previous drive.
1209   D78F CD 5E D2    GETBACK1: 	CALL	CONVFST		;convert first name in (FCB).
1210   D792 3A D4 D7    	LD	A,(FCB+1)		;if this was just a drive change request,
1211   D795 D6 20       	SUB	' '			;make sure it was valid.
1212   D797 21 F6 D7    	LD	HL,CHGDRV
1213   D79A B6          	OR	(HL)
1214   D79B C2 09 D2    	JP	NZ,SYNERR
1215   D79E C3 86 D3    	JP	CMMND1		;ok, return to command level.
1216   D7A1             ;
1217   D7A1             ;   ccp stack area.
1218   D7A1             ;
1219   D7A1 00 00 00 00 		.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1219   D7A5 00 00 00 00 
1219   D7A9 00 00 00 00 
1219   D7AD 00 00 00 00 
1220   D7B1             CCPSTACK 	.EQU	$	;end of ccp stack area.
1221   D7B1             ;
1222   D7B1             ;   Batch (or SUBMIT) processing information storage.
1223   D7B1             ;
1224   D7B1 00          BATCH:	.DB	0			;batch mode flag (0=not active).
1225   D7B2 00          BATCHFCB: 	.DB	0,
1226   D7B3 24 24 24 20 	.TEXT "$$$     SUB"
1226   D7B7 20 20 20 20 
1226   D7BB 53 55 42 
1227   D7BE 00 00 00 00 	.DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1227   D7C2 00 00 00 00 
1227   D7C6 00 00 00 00 
1227   D7CA 00 00 00 00 
1227   D7CE 00 00 00 00 
1227   D7D2 00 
1228   D7D3             ;
1229   D7D3             ;   File control block setup by the CCP.
1230   D7D3             ;
1231   D7D3 00          FCB:		.DB	0
1232   D7D4 20 20 20 20 	.TEXT	"           "
1232   D7D8 20 20 20 20 
1232   D7DC 20 20 20 
1233   D7DF 00 00 00 00 	.DB	0,0,0,0,0
1233   D7E3 00 
1234   D7E4 20 20 20 20 	.TEXT	"           "
1234   D7E8 20 20 20 20 
1234   D7EC 20 20 20 
1235   D7EF 00 00 00 00 	.DB	0,0,0,0,0
1235   D7F3 00 
1236   D7F4 00          RTNCODE:	.DB	0			;status returned from bdos call.
1237   D7F5 00          CDRIVE:	.DB	0			;currently active drive.
1238   D7F6 00          CHGDRV:	.DB	0			;change in drives flag (0=no change).
1239   D7F7 00 00       NBYTES:	.DW	0			;byte counter used by TYPE.
1240   D7F9             ;
1241   D7F9             ;   Room for expansion?
1242   D7F9             ;
1243   D7F9 00 00 00 00 		.DB	0,0,0,0,0,0,0,0,0,0,0,0,0
1243   D7FD 00 00 00 00 
1243   D801 00 00 00 00 
1243   D805 00 
1244   D806             ;
1245   D806             ;   Note that the following six bytes must match those at
1246   D806             ; (PATTRN1) or cp/m will HALT. Why?
1247   D806             ;
1248   D806 00 16 00 00 PATTRN2:	.DB	0,22,0,0,0,0	;(* serial number bytes *).
1248   D80A 00 00 
1249   D80C             ;
1250   D80C             ;**************************************************************
1251   D80C             ;*
1252   D80C             ;*                    B D O S   E N T R Y
1253   D80C             ;*
1254   D80C             ;**************************************************************
1255   D80C             ;
1256   D80C C3 17 D8    FBASE:	JP	FBASE1
1257   D80F             ;
1258   D80F             ;   Bdos error table.
1259   D80F             ;
1260   D80F 9F D8       BADSCTR:	.DW	ERROR1		;bad sector on read or write.
1261   D811 AB D8       BADSLCT:	.DW	ERROR2		;bad disk select.
1262   D813 B1 D8       RODISK:	.DW	ERROR3		;disk is read only.
1263   D815 B7 D8       ROFILE:	.DW	ERROR4		;file is read only.
1264   D817             ;
1265   D817             ;   Entry into bdos. (DE) or (E) are the parameters passed. The
1266   D817             ; function number desired is in register (C).
1267   D817             ;
1268   D817 EB          FBASE1:	EX	DE,HL			;save the (DE) parameters.
1269   D818 22 49 DB    	LD	(PARAMS),HL
1270   D81B EB          	EX	DE,HL
1271   D81C 7B          	LD	A,E			;and save register (E) in particular.
1272   D81D 32 DC E5    	LD	(EPARAM),A
1273   D820 21 00 00    	LD	HL,0
1274   D823 22 4B DB    	LD	(STATUS),HL	;clear return status.
1275   D826 39          	ADD	HL,SP
1276   D827 22 15 DB    	LD	(USRSTACK),HL	;save users stack pointer.
1277   D82A 31 47 DB    	LD	SP,STKAREA		;and set our own.
1278   D82D AF          	XOR	A			;clear auto select storage space.
1279   D82E 32 E6 E5    	LD	(AUTOFLAG),A
1280   D831 32 E4 E5    	LD	(AUTO),A
1281   D834 21 7A E5    	LD	HL,GOBACK		;set return address.
1282   D837 E5          	PUSH	HL
1283   D838 79          	LD	A,C			;get function number.
1284   D839 FE 29       	CP	NFUNCTS		;valid function number?
1285   D83B D0          	RET	NC
1286   D83C 4B          	LD	C,E			;keep single register function here.
1287   D83D 21 4D D8    	LD	HL,FUNCTNS		;now look thru the function table.
1288   D840 5F          	LD	E,A
1289   D841 16 00       	LD	D,0			;(DE)=function number.
1290   D843 19          	ADD	HL,DE
1291   D844 19          	ADD	HL,DE			;(HL)=(start of table)+2*(function number).
1292   D845 5E          	LD	E,(HL)
1293   D846 23          	INC	HL
1294   D847 56          	LD	D,(HL)		;now (DE)=address for this function.
1295   D848 2A 49 DB    	LD	HL,(PARAMS)	;retrieve parameters.
1296   D84B EB          	EX	DE,HL			;now (DE) has the original parameters.
1297   D84C E9          	JP	(HL)			;execute desired function.
1298   D84D             ;
1299   D84D             ;   BDOS function jump table.
1300   D84D             ;
1301   D84D             NFUNCTS 	.EQU	41			;number of functions in followin table.
1302   D84D             ;
1303   D84D 03 E6 CE DA FUNCTNS:	.DW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
1303   D851 96 D9 D4 DA 
1303   D855 12 E6 0F E6 
1303   D859 DA DA F3 DA 
1304   D85D F9 DA FE DA 	.DW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
1304   D861 E7 D9 04 DB 
1304   D865 84 E4 89 E4 
1304   D869 4B E4 A2 E4 
1305   D86D AB E4 B1 E4 	.DW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
1305   D871 CE E4 DD E4 
1305   D875 E6 E4 EC E4 
1305   D879 F2 E4 
1306   D87B FB E4 04 E5 	.DW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
1306   D87F 0A E5 10 E5 
1306   D883 17 E5 32 DD 
1306   D887 1D E5 23 E5 
1307   D88B 2C E5 33 E5 	.DW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
1307   D88F 47 E5 4D E5 
1307   D893 53 E5 14 E4 
1307   D897 59 E5 0A DB 
1308   D89B 0A DB A1 E5 	.DW	RTN,WTSPECL
1309   D89F             ;
1310   D89F             ;   Bdos error message section.
1311   D89F             ;
1312   D89F 21 D0 D8    ERROR1:	LD	HL,BADSEC		;bad sector message.
1313   D8A2 CD EB D8    	CALL	PRTERR		;print it and get a 1 char responce.
1314   D8A5 FE 03       	CP	CNTRLC		;re-boot request (control-c)?
1315   D8A7 CA 00 00    	JP	Z,0			;yes.
1316   D8AA C9          	RET				;no, return to retry i/o function.
1317   D8AB             ;
1318   D8AB 21 DB D8    ERROR2:	LD	HL,BADSEL		;bad drive selected.
1319   D8AE C3 BA D8    		JP	ERROR5
1320   D8B1             ;
1321   D8B1 21 E7 D8    ERROR3:	LD	HL,DISKRO		;disk is read only.
1322   D8B4 C3 BA D8    		JP	ERROR5
1323   D8B7             ;
1324   D8B7 21 E2 D8    ERROR4:	LD	HL,FILERO		;file is read only.
1325   D8BA             ;
1326   D8BA CD EB D8    ERROR5:	CALL	PRTERR
1327   D8BD C3 00 00    		JP	0			;always reboot on these errors.
1328   D8C0             ;
1329   D8C0 42 64 6F 73 BDOSERR:	.TEXT	"Bdos Err On "
1329   D8C4 20 45 72 72 
1329   D8C8 20 4F 6E 20 
1330   D8CC 20 3A 20 24 BDOSDRV:	.TEXT	" : $"
1331   D8D0 42 61 64 20 BADSEC:	.TEXT	"Bad Sector$"
1331   D8D4 53 65 63 74 
1331   D8D8 6F 72 24 
1332   D8DB 53 65 6C 65 BADSEL:	.TEXT	"Select$"
1332   D8DF 63 74 24 
1333   D8E2 46 69 6C 65 FILERO:	.TEXT	"File "
1333   D8E6 20 
1334   D8E7 52 2F 4F 24 DISKRO:	.TEXT	"R/O$"
1335   D8EB             ;
1336   D8EB             ;   Print bdos error message.
1337   D8EB             ;
1338   D8EB E5          PRTERR:	PUSH	HL			;save second message pointer.
1339   D8EC CD CF D9    	CALL	OUTCRLF		;send (cr)(lf).
1340   D8EF 3A 48 DB    	LD	A,(ACTIVE)		;get active drive.
1341   D8F2 C6 41       	ADD	A,'A'			;make ascii.
1342   D8F4 32 CC D8    	LD	(BDOSDRV),A	;and put in message.
1343   D8F7 01 C0 D8    	LD	BC,BDOSERR		;and print it.
1344   D8FA CD D9 D9    	CALL	PRTMESG
1345   D8FD C1          	POP	BC			;print second message line now.
1346   D8FE CD D9 D9    	CALL	PRTMESG
1347   D901             ;
1348   D901             ;   Get an input character. We will check our 1 character
1349   D901             ; buffer first. This may be set by the console status routine.
1350   D901             ;
1351   D901 21 14 DB    GETCHAR:	LD	HL,CHARBUF	;check character buffer.
1352   D904 7E          	LD	A,(HL)		;anything present already?
1353   D905 36 00       	LD	(HL),0		;...either case clear it.
1354   D907 B7          	OR	A
1355   D908 C0          	RET	NZ			;yes, use it.
1356   D909 C3 09 E6    	JP	CONIN			;nope, go get a character responce.
1357   D90C             ;
1358   D90C             ;   Input and echo a character.
1359   D90C             ;
1360   D90C CD 01 D9    GETECHO:	CALL	GETCHAR		;input a character.
1361   D90F CD 1A D9    	CALL	CHKCHAR		;carriage control?
1362   D912 D8          	RET	C			;no, a regular control char so don't echo.
1363   D913 F5          	PUSH	AF			;ok, save character now.
1364   D914 4F          	LD	C,A
1365   D915 CD 96 D9    	CALL	OUTCON		;and echo it.
1366   D918 F1          	POP	AF			;get character and return.
1367   D919 C9          	RET	
1368   D91A             ;
1369   D91A             ;   Check character in (A). Set the zero flag on a carriage
1370   D91A             ; control character and the carry flag on any other control
1371   D91A             ; character.
1372   D91A             ;
1373   D91A FE 0D       CHKCHAR:	CP	CR			;check for carriage return, line feed, backspace,
1374   D91C C8          	RET	Z			;or a tab.
1375   D91D FE 0A       	CP	LF
1376   D91F C8          	RET	Z
1377   D920 FE 09       	CP	TAB
1378   D922 C8          	RET	Z
1379   D923 FE 08       	CP	BS
1380   D925 C8          	RET	Z
1381   D926 FE 20       	CP	' '			;other control char? Set carry flag.
1382   D928 C9          	RET	
1383   D929             ;
1384   D929             ;   Check the console during output. Halt on a control-s, then
1385   D929             ; reboot on a control-c. If anything else is ready, clear the
1386   D929             ; zero flag and return (the calling routine may want to do
1387   D929             ; something).
1388   D929             ;
1389   D929 3A 14 DB    CKCONSOL: 	LD	A,(CHARBUF)	;check buffer.
1390   D92C B7          	OR	A			;if anything, just return without checking.
1391   D92D C2 4B D9    	JP	NZ,CKCON2
1392   D930 CD 06 E6    	CALL	CONST			;nothing in buffer. Check console.
1393   D933 E6 01       	AND	01H			;look at bit 0.
1394   D935 C8          	RET	Z			;return if nothing.
1395   D936 CD 09 E6    	CALL	CONIN			;ok, get it.
1396   D939 FE 13       	CP	CNTRLS		;if not control-s, return with zero cleared.
1397   D93B C2 48 D9    	JP	NZ,CKCON1
1398   D93E CD 09 E6    	CALL	CONIN			;halt processing until another char
1399   D941 FE 03       	CP	CNTRLC		;is typed. Control-c?
1400   D943 CA 00 00    	JP	Z,0			;yes, reboot now.
1401   D946 AF          	XOR	A			;no, just pretend nothing was ever ready.
1402   D947 C9          	RET	
1403   D948 32 14 DB    CKCON1:	LD	(CHARBUF),A	;save character in buffer for later processing.
1404   D94B 3E 01       CKCON2:	LD	A,1			;set (A) to non zero to mean something is ready.
1405   D94D C9          		RET	
1406   D94E             ;
1407   D94E             ;   Output (C) to the screen. If the printer flip-flop flag
1408   D94E             ; is set, we will send character to printer also. The console
1409   D94E             ; will be checked in the process.
1410   D94E             ;
1411   D94E 3A 10 DB    OUTCHAR:	LD	A,(OUTFLAG)	;check output flag.
1412   D951 B7          	OR	A			;anything and we won't generate output.
1413   D952 C2 68 D9    	JP	NZ,OUTCHR1
1414   D955 C5          	PUSH	BC
1415   D956 CD 29 D9    	CALL	CKCONSOL		;check console (we don't care whats there).
1416   D959 C1          	POP	BC
1417   D95A C5          	PUSH	BC
1418   D95B CD 0C E6    	CALL	CONOUT		;output (C) to the screen.
1419   D95E C1          	POP	BC
1420   D95F C5          	PUSH	BC
1421   D960 3A 13 DB    	LD	A,(PRTFLAG)	;check printer flip-flop flag.
1422   D963 B7          	OR	A
1423   D964 C4 0F E6    	CALL	NZ,LIST		;print it also if non-zero.
1424   D967 C1          	POP	BC
1425   D968 79          OUTCHR1:	LD	A,C			;update cursors position.
1426   D969 21 12 DB    	LD	HL,CURPOS
1427   D96C FE 7F       	CP	DEL			;rubouts don't do anything here.
1428   D96E C8          	RET	Z
1429   D96F 34          	INC	(HL)			;bump line pointer.
1430   D970 FE 20       	CP	' '			;and return if a normal character.
1431   D972 D0          	RET	NC
1432   D973 35          	DEC	(HL)			;restore and check for the start of the line.
1433   D974 7E          	LD	A,(HL)
1434   D975 B7          	OR	A
1435   D976 C8          	RET	Z			;ingnore control characters at the start of the line.
1436   D977 79          	LD	A,C
1437   D978 FE 08       	CP	BS			;is it a backspace?
1438   D97A C2 7F D9    	JP	NZ,OUTCHR2
1439   D97D 35          	DEC	(HL)			;yes, backup pointer.
1440   D97E C9          	RET	
1441   D97F FE 0A       OUTCHR2:	CP	LF			;is it a line feed?
1442   D981 C0          	RET	NZ			;ignore anything else.
1443   D982 36 00       	LD	(HL),0		;reset pointer to start of line.
1444   D984 C9          	RET	
1445   D985             ;
1446   D985             ;   Output (A) to the screen. If it is a control character
1447   D985             ; (other than carriage control), use ^x format.
1448   D985             ;
1449   D985 79          SHOWIT:	LD	A,C
1450   D986 CD 1A D9    	CALL	CHKCHAR		;check character.
1451   D989 D2 96 D9    	JP	NC,OUTCON		;not a control, use normal output.
1452   D98C F5          	PUSH	AF
1453   D98D 0E 5E       	LD	C,'^'			;for a control character, preceed it with '^'.
1454   D98F CD 4E D9    	CALL	OUTCHAR
1455   D992 F1          	POP	AF
1456   D993 F6 40       	OR	'@'			;and then use the letter equivelant.
1457   D995 4F          	LD	C,A
1458   D996             ;
1459   D996             ;   Function to output (C) to the console device and expand tabs
1460   D996             ; if necessary.
1461   D996             ;
1462   D996 79          OUTCON:	LD	A,C
1463   D997 FE 09       	CP	TAB			;is it a tab?
1464   D999 C2 4E D9    	JP	NZ,OUTCHAR		;use regular output.
1465   D99C 0E 20       OUTCON1:	LD	C,' '			;yes it is, use spaces instead.
1466   D99E CD 4E D9    	CALL	OUTCHAR
1467   D9A1 3A 12 DB    	LD	A,(CURPOS)		;go until the cursor is at a multiple of 8
1468   D9A4             
1469   D9A4 E6 07       	AND	07H			;position.
1470   D9A6 C2 9C D9    	JP	NZ,OUTCON1
1471   D9A9 C9          	RET	
1472   D9AA             ;
1473   D9AA             ;   Echo a backspace character. Erase the prevoius character
1474   D9AA             ; on the screen.
1475   D9AA             ;
1476   D9AA CD B2 D9    BACKUP:	CALL	BACKUP1		;backup the screen 1 place.
1477   D9AD 0E 20       	LD	C,' '			;then blank that character.
1478   D9AF CD 0C E6    	CALL	CONOUT
1479   D9B2 0E 08       BACKUP1:	LD	C,BS			;then back space once more.
1480   D9B4 C3 0C E6    		JP	CONOUT
1481   D9B7             ;
1482   D9B7             ;   Signal a deleted line. Print a '#' at the end and start
1483   D9B7             ; over.
1484   D9B7             ;
1485   D9B7 0E 23       NEWLINE:	LD	C,'#'
1486   D9B9 CD 4E D9    	CALL	OUTCHAR		;print this.
1487   D9BC CD CF D9    	CALL	OUTCRLF		;start new line.
1488   D9BF 3A 12 DB    NEWLN1:	LD	A,(CURPOS)		;move the cursor to the starting position.
1489   D9C2 21 11 DB    	LD	HL,STARTING
1490   D9C5 BE          	CP	(HL)
1491   D9C6 D0          	RET	NC			;there yet?
1492   D9C7 0E 20       	LD	C,' '
1493   D9C9 CD 4E D9    	CALL	OUTCHAR		;nope, keep going.
1494   D9CC C3 BF D9    	JP	NEWLN1
1495   D9CF             ;
1496   D9CF             ;   Output a (cr) (lf) to the console device (screen).
1497   D9CF             ;
1498   D9CF 0E 0D       OUTCRLF:	LD	C,CR
1499   D9D1 CD 4E D9    	CALL	OUTCHAR
1500   D9D4 0E 0A       	LD	C,LF
1501   D9D6 C3 4E D9    	JP	OUTCHAR
1502   D9D9             ;
1503   D9D9             ;   Print message pointed to by (BC). It will end with a '$'.
1504   D9D9             ;
1505   D9D9 0A          PRTMESG:	LD	A,(BC)		;check for terminating character.
1506   D9DA FE 24       	CP	'$'
1507   D9DC C8          	RET	Z
1508   D9DD 03          	INC	BC
1509   D9DE C5          	PUSH	BC			;otherwise, bump pointer and print it.
1510   D9DF 4F          	LD	C,A
1511   D9E0 CD 96 D9    	CALL	OUTCON
1512   D9E3 C1          	POP	BC
1513   D9E4 C3 D9 D9    	JP	PRTMESG
1514   D9E7             ;
1515   D9E7             ;   Function to execute a buffered read.
1516   D9E7             ;
1517   D9E7 3A 12 DB    RDBUFF:	LD	A,(CURPOS)		;use present location as starting one.
1518   D9EA 32 11 DB    	LD	(STARTING),A
1519   D9ED 2A 49 DB    	LD	HL,(PARAMS)	;get the maximum buffer space.
1520   D9F0 4E          	LD	C,(HL)
1521   D9F1 23          	INC	HL			;point to first available space.
1522   D9F2 E5          	PUSH	HL			;and save.
1523   D9F3 06 00       	LD	B,0			;keep a character count.
1524   D9F5 C5          RDBUF1:	PUSH	BC
1525   D9F6 E5          		PUSH	HL
1526   D9F7 CD 01 D9    RDBUF2:	CALL	GETCHAR		;get the next input character.
1527   D9FA E6 7F       	AND	7FH			;strip bit 7.
1528   D9FC E1          	POP	HL			;reset registers.
1529   D9FD C1          	POP	BC
1530   D9FE FE 0D       	CP	CR			;en of the line?
1531   DA00 CA C7 DA    	JP	Z,RDBUF17
1532   DA03 FE 0A       	CP	LF
1533   DA05 CA C7 DA    	JP	Z,RDBUF17
1534   DA08 FE 08       	CP	BS			;how about a backspace?
1535   DA0A C2 1C DA    	JP	NZ,RDBUF3
1536   DA0D 78          	LD	A,B			;yes, but ignore at the beginning of the line.
1537   DA0E B7          	OR	A
1538   DA0F CA F5 D9    	JP	Z,RDBUF1
1539   DA12 05          	DEC	B			;ok, update counter.
1540   DA13 3A 12 DB    	LD	A,(CURPOS)		;if we backspace to the start of the line,
1541   DA16 32 10 DB    	LD	(OUTFLAG),A	;treat as a cancel (control-x).
1542   DA19 C3 76 DA    	JP	RDBUF10
1543   DA1C FE 7F       RDBUF3:	CP	DEL			;user typed a rubout?
1544   DA1E C2 2C DA    	JP	NZ,RDBUF4
1545   DA21 78          	LD	A,B			;ignore at the start of the line.
1546   DA22 B7          	OR	A
1547   DA23 CA F5 D9    	JP	Z,RDBUF1
1548   DA26 7E          	LD	A,(HL)		;ok, echo the prevoius character.
1549   DA27 05          	DEC	B			;and reset pointers (counters).
1550   DA28 2B          	DEC	HL
1551   DA29 C3 AF DA    	JP	RDBUF15
1552   DA2C FE 05       RDBUF4:	CP	CNTRLE		;physical end of line?
1553   DA2E C2 3D DA    	JP	NZ,RDBUF5
1554   DA31 C5          	PUSH	BC			;yes, do it.
1555   DA32 E5          	PUSH	HL
1556   DA33 CD CF D9    	CALL	OUTCRLF
1557   DA36 AF          	XOR	A			;and update starting position.
1558   DA37 32 11 DB    	LD	(STARTING),A
1559   DA3A C3 F7 D9    	JP	RDBUF2
1560   DA3D FE 10       RDBUF5:	CP	CNTRLP		;control-p?
1561   DA3F C2 4E DA    	JP	NZ,RDBUF6
1562   DA42 E5          	PUSH	HL			;yes, flip the print flag filp-flop byte.
1563   DA43 21 13 DB    	LD	HL,PRTFLAG
1564   DA46 3E 01       	LD	A,1			;PRTFLAG=1-PRTFLAG
1565   DA48 96          	SUB	(HL)
1566   DA49 77          	LD	(HL),A
1567   DA4A E1          	POP	HL
1568   DA4B C3 F5 D9    	JP	RDBUF1
1569   DA4E FE 18       RDBUF6:	CP	CNTRLX		;control-x (cancel)?
1570   DA50 C2 65 DA    	JP	NZ,RDBUF8
1571   DA53 E1          	POP	HL
1572   DA54 3A 11 DB    RDBUF7:	LD	A,(STARTING)	;yes, backup the cursor to here.
1573   DA57 21 12 DB    	LD	HL,CURPOS
1574   DA5A BE          	CP	(HL)
1575   DA5B D2 E7 D9    	JP	NC,RDBUFF		;done yet?
1576   DA5E 35          	DEC	(HL)			;no, decrement pointer and output back up one space.
1577   DA5F CD AA D9    	CALL	BACKUP
1578   DA62 C3 54 DA    	JP	RDBUF7
1579   DA65 FE 15       RDBUF8:	CP	CNTRLU		;cntrol-u (cancel line)?
1580   DA67 C2 71 DA    	JP	NZ,RDBUF9
1581   DA6A CD B7 D9    	CALL	NEWLINE		;start a new line.
1582   DA6D E1          	POP	HL
1583   DA6E C3 E7 D9    	JP	RDBUFF
1584   DA71 FE 12       RDBUF9:	CP	CNTRLR		;control-r?
1585   DA73 C2 AC DA    		JP	NZ,RDBUF14
1586   DA76 C5          RDBUF10:	PUSH	BC			;yes, start a new line and retype the old one.
1587   DA77 CD B7 D9    	CALL	NEWLINE
1588   DA7A C1          	POP	BC
1589   DA7B E1          	POP	HL
1590   DA7C E5          	PUSH	HL
1591   DA7D C5          	PUSH	BC
1592   DA7E 78          RDBUF11:	LD	A,B			;done whole line yet?
1593   DA7F B7          	OR	A
1594   DA80 CA 90 DA    	JP	Z,RDBUF12
1595   DA83 23          	INC	HL			;nope, get next character.
1596   DA84 4E          	LD	C,(HL)
1597   DA85 05          	DEC	B			;count it.
1598   DA86 C5          	PUSH	BC
1599   DA87 E5          	PUSH	HL
1600   DA88 CD 85 D9    	CALL	SHOWIT		;and display it.
1601   DA8B E1          	POP	HL
1602   DA8C C1          	POP	BC
1603   DA8D C3 7E DA    	JP	RDBUF11
1604   DA90 E5          RDBUF12:	PUSH	HL			;done with line. If we were displaying
1605   DA91 3A 10 DB    	LD	A,(OUTFLAG)	;then update cursor position.
1606   DA94 B7          	OR	A
1607   DA95 CA F7 D9    	JP	Z,RDBUF2
1608   DA98 21 12 DB    	LD	HL,CURPOS		;because this line is shorter, we must
1609   DA9B 96          	SUB	(HL)			;back up the cursor (not the screen however)
1610   DA9C 32 10 DB    	LD	(OUTFLAG),A	;some number of positions.
1611   DA9F CD AA D9    RDBUF13:	CALL	BACKUP		;note that as long as (OUTFLAG) is non
1612   DAA2 21 10 DB    	LD	HL,OUTFLAG		;zero, the screen will not be changed.
1613   DAA5 35          	DEC	(HL)
1614   DAA6 C2 9F DA    	JP	NZ,RDBUF13
1615   DAA9 C3 F7 D9    	JP	RDBUF2		;now just get the next character.
1616   DAAC             ;
1617   DAAC             ;   Just a normal character, put this in our buffer and echo.
1618   DAAC             ;
1619   DAAC 23          RDBUF14:	INC	HL
1620   DAAD 77          	LD	(HL),A		;store character.
1621   DAAE 04          	INC	B			;and count it.
1622   DAAF C5          RDBUF15:	PUSH	BC
1623   DAB0 E5          	PUSH	HL
1624   DAB1 4F          	LD	C,A			;echo it now.
1625   DAB2 CD 85 D9    	CALL	SHOWIT
1626   DAB5 E1          	POP	HL
1627   DAB6 C1          	POP	BC
1628   DAB7 7E          	LD	A,(HL)		;was it an abort request?
1629   DAB8 FE 03       	CP	CNTRLC		;control-c abort?
1630   DABA 78          	LD	A,B
1631   DABB C2 C3 DA    	JP	NZ,RDBUF16
1632   DABE FE 01       	CP	1			;only if at start of line.
1633   DAC0 CA 00 00    	JP	Z,0
1634   DAC3 B9          RDBUF16:	CP	C			;nope, have we filled the buffer?
1635   DAC4 DA F5 D9    		JP	C,RDBUF1
1636   DAC7 E1          RDBUF17:	POP	HL			;yes end the line and return.
1637   DAC8 70          	LD	(HL),B
1638   DAC9 0E 0D       	LD	C,CR
1639   DACB C3 4E D9    	JP	OUTCHAR		;output (cr) and return.
1640   DACE             ;
1641   DACE             ;   Function to get a character from the console device.
1642   DACE             ;
1643   DACE CD 0C D9    GETCON:	CALL	GETECHO		;get and echo.
1644   DAD1 C3 07 DB    		JP	SETSTAT		;save status and return.
1645   DAD4             ;
1646   DAD4             ;   Function to get a character from the tape reader device.
1647   DAD4             ;
1648   DAD4 CD 15 E6    GETRDR:	CALL	READER		;get a character from reader, set status and return.
1649   DAD7 C3 07 DB    		JP	SETSTAT
1650   DADA             ;
1651   DADA             ;  Function to perform direct console i/o. If (C) contains (FF)
1652   DADA             ; then this is an input request. If (C) contains (FE) then
1653   DADA             ; this is a status request. Otherwise we are to output (C).
1654   DADA             ;
1655   DADA 79          DIRCIO:	LD	A,C			;test for (FF).
1656   DADB 3C          	INC	A
1657   DADC CA E6 DA    	JP	Z,DIRC1
1658   DADF 3C          	INC	A			;test for (FE).
1659   DAE0 CA 06 E6    	JP	Z,CONST
1660   DAE3 C3 0C E6    	JP	CONOUT		;just output (C).
1661   DAE6 CD 06 E6    DIRC1:	CALL	CONST			;this is an input request.
1662   DAE9 B7          	OR	A
1663   DAEA CA 97 E5    	JP	Z,GOBACK1		;not ready? Just return (directly).
1664   DAED CD 09 E6    	CALL	CONIN			;yes, get character.
1665   DAF0 C3 07 DB    	JP	SETSTAT		;set status and return.
1666   DAF3             ;
1667   DAF3             ;   Function to return the i/o byte.
1668   DAF3             ;
1669   DAF3 3A 03 00    GETIOB:	LD	A,(IOBYTE)
1670   DAF6 C3 07 DB    		JP	SETSTAT
1671   DAF9             ;
1672   DAF9             ;   Function to set the i/o byte.
1673   DAF9             ;
1674   DAF9 21 03 00    SETIOB:	LD	HL,IOBYTE
1675   DAFC 71          	LD	(HL),C
1676   DAFD C9          	RET	
1677   DAFE             ;
1678   DAFE             ;   Function to print the character string pointed to by (DE)
1679   DAFE             ; on the console device. The string ends with a '$'.
1680   DAFE             ;
1681   DAFE EB          PRTSTR:	EX	DE,HL
1682   DAFF 4D          	LD	C,L
1683   DB00 44          	LD	B,H			;now (BC) points to it.
1684   DB01 C3 D9 D9    	JP	PRTMESG
1685   DB04             ;
1686   DB04             ;   Function to interigate the console device.
1687   DB04             ;
1688   DB04 CD 29 D9    GETCSTS:	CALL	CKCONSOL
1689   DB07             ;
1690   DB07             ;   Get here to set the status and return to the cleanup
1691   DB07             ; section. Then back to the user.
1692   DB07             ;
1693   DB07 32 4B DB    SETSTAT:	LD	(STATUS),A
1694   DB0A C9          RTN:		RET	
1695   DB0B             ;
1696   DB0B             ;   Set the status to 1 (read or write error code).
1697   DB0B             ;
1698   DB0B 3E 01       IOERR1:	LD	A,1
1699   DB0D C3 07 DB    		JP	SETSTAT
1700   DB10             ;
1701   DB10 00          OUTFLAG:	.DB	0			;output flag (non zero means no output).
1702   DB11 02          STARTING:	.DB	2			;starting position for cursor.
1703   DB12 00          CURPOS:	.DB	0			;cursor position (0=start of line).
1704   DB13 00          PRTFLAG:	.DB	0			;printer flag (control-p toggle). List if non zero.
1705   DB14 00          CHARBUF:	.DB	0			;single input character buffer.
1706   DB15             ;
1707   DB15             ;   Stack area for BDOS calls.
1708   DB15             ;
1709   DB15 00 00       USRSTACK: 	.DW	0			;save users stack pointer here.
1710   DB17             ;
1711   DB17 00 00 00 00 	.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1711   DB1B 00 00 00 00 
1711   DB1F 00 00 00 00 
1711   DB23 00 00 00 00 
1711   DB27 00 00 00 00 
1711   DB2B 00 00 00 00 
1712   DB2F 00 00 00 00 	.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1712   DB33 00 00 00 00 
1712   DB37 00 00 00 00 
1712   DB3B 00 00 00 00 
1712   DB3F 00 00 00 00 
1712   DB43 00 00 00 00 
1713   DB47             STKAREA 	.EQU	$			;end of stack area.
1714   DB47             ;
1715   DB47 00          USERNO:	.DB	0			;current user number.
1716   DB48 00          ACTIVE:	.DB	0			;currently active drive.
1717   DB49 00 00       PARAMS:	.DW	0			;save (DE) parameters here on entry.
1718   DB4B 00 00       STATUS:	.DW	0			;status returned from bdos function.
1719   DB4D             ;
1720   DB4D             ;   Select error occured, jump to error routine.
1721   DB4D             ;
1722   DB4D 21 11 D8    SLCTERR:	LD	HL,BADSLCT
1723   DB50             ;
1724   DB50             ;   Jump to (HL) indirectly.
1725   DB50             ;
1726   DB50 5E          JUMPHL:	LD	E,(HL)
1727   DB51 23          	INC	HL
1728   DB52 56          	LD	D,(HL)		;now (DE) contain the desired address.
1729   DB53 EB          	EX	DE,HL
1730   DB54 E9          	JP	(HL)
1731   DB55             ;
1732   DB55             ;   Block move. (DE) to (HL), (C) bytes total.
1733   DB55             ;
1734   DB55 0C          DE2HL:	INC	C			;is count down to zero?
1735   DB56 0D          DE2HL1:	DEC	C	
1736   DB57 C8          	RET	Z			;yes, we are done.
1737   DB58 1A          	LD	A,(DE)		;no, move one more byte.
1738   DB59 77          	LD	(HL),A
1739   DB5A 13          	INC	DE
1740   DB5B 23          	INC	HL
1741   DB5C C3 56 DB    	JP	DE2HL1		;and repeat.
1742   DB5F             ;
1743   DB5F             ;   Select the desired drive.
1744   DB5F             ;
1745   DB5F 3A 48 DB    SELECT:	LD	A,(ACTIVE)		;get active disk.
1746   DB62 4F          	LD	C,A
1747   DB63 CD 1B E6    	CALL	SELDSK		;select it.
1748   DB66 7C          	LD	A,H			;valid drive?
1749   DB67 B5          	OR	L			;valid drive?
1750   DB68 C8          	RET	Z			;return if not.
1751   DB69             ;
1752   DB69             ;   Here, the BIOS returned the address of the parameter block
1753   DB69             ; in (HL). We will extract the necessary pointers and save them.
1754   DB69             ;
1755   DB69 5E          	LD	E,(HL)		;yes, get address of translation table into (DE).
1756   DB6A 23          	INC	HL
1757   DB6B 56          	LD	D,(HL)
1758   DB6C 23          	INC	HL
1759   DB6D 22 B9 E5    	LD	(SCRATCH1),HL	;save pointers to scratch areas.
1760   DB70 23          	INC	HL
1761   DB71 23          	INC	HL
1762   DB72 22 BB E5    	LD	(SCRATCH2),HL	;ditto.
1763   DB75 23          	INC	HL
1764   DB76 23          	INC	HL
1765   DB77 22 BD E5    	LD	(SCRATCH3),HL	;ditto.
1766   DB7A 23          	INC	HL
1767   DB7B 23          	INC	HL
1768   DB7C EB          	EX	DE,HL			;now save the translation table address.
1769   DB7D 22 D6 E5    	LD	(XLATE),HL
1770   DB80 21 BF E5    	LD	HL,DIRBUF		;put the next 8 bytes here.
1771   DB83 0E 08       	LD	C,8			;they consist of the directory buffer
1772   DB85 CD 55 DB    	CALL	DE2HL			;pointer, parameter block pointer,
1773   DB88 2A C1 E5    	LD	HL,(DISKPB)	;check and allocation vectors.
1774   DB8B EB          	EX	DE,HL
1775   DB8C 21 C7 E5    	LD	HL,SECTORS		;move parameter block into our ram.
1776   DB8F 0E 0F       	LD	C,15			;it is 15 bytes long.
1777   DB91 CD 55 DB    	CALL	DE2HL
1778   DB94 2A CC E5    	LD	HL,(DSKSIZE)	;check disk size.
1779   DB97 7C          	LD	A,H			;more than 256 blocks on this?
1780   DB98 21 E3 E5    	LD	HL,BIGDISK
1781   DB9B 36 FF       	LD	(HL),0FFH		;set to samll.
1782   DB9D B7          	OR	A
1783   DB9E CA A3 DB    	JP	Z,SELECT1
1784   DBA1 36 00       	LD	(HL),0		;wrong, set to large.
1785   DBA3 3E FF       SELECT1:	LD	A,0FFH		;clear the zero flag.
1786   DBA5 B7          	OR	A
1787   DBA6 C9          	RET	
1788   DBA7             ;
1789   DBA7             ;   Routine to home the disk track head and clear pointers.
1790   DBA7             ;
1791   DBA7 CD 18 E6    HOMEDRV:	CALL	HOME			;home the head.
1792   DBAA AF          	XOR	A
1793   DBAB 2A BB E5    	LD	HL,(SCRATCH2)	;set our track pointer also.
1794   DBAE 77          	LD	(HL),A
1795   DBAF 23          	INC	HL
1796   DBB0 77          	LD	(HL),A
1797   DBB1 2A BD E5    	LD	HL,(SCRATCH3)	;and our sector pointer.
1798   DBB4 77          	LD	(HL),A
1799   DBB5 23          	INC	HL
1800   DBB6 77          	LD	(HL),A
1801   DBB7 C9          	RET	
1802   DBB8             ;
1803   DBB8             ;   Do the actual disk read and check the error return status.
1804   DBB8             ;
1805   DBB8 CD 27 E6    DOREAD:	CALL	READ
1806   DBBB C3 C1 DB    		JP	IORET
1807   DBBE             ;
1808   DBBE             ;   Do the actual disk write and handle any bios error.
1809   DBBE             ;
1810   DBBE CD 2A E6    DOWRITE:	CALL	WRITE
1811   DBC1 B7          IORET:	OR	A
1812   DBC2 C8          	RET	Z			;return unless an error occured.
1813   DBC3 21 0F D8    	LD	HL,BADSCTR		;bad read/write on this sector.
1814   DBC6 C3 50 DB    	JP	JUMPHL
1815   DBC9             ;
1816   DBC9             ;   Routine to select the track and sector that the desired
1817   DBC9             ; block number falls in.
1818   DBC9             ;
1819   DBC9 2A F0 E5    TRKSEC:	LD	HL,(FILEPOS)	;get position of last accessed file
1820   DBCC 0E 02       	LD	C,2			;in directory and compute sector #.
1821   DBCE CD F0 DC    	CALL	SHIFTR		;sector #=file-position/4.
1822   DBD1 22 EB E5    	LD	(BLKNMBR),HL	;save this as the block number of interest.
1823   DBD4 22 F2 E5    	LD	(CKSUMTBL),HL	;what's it doing here too?
1824   DBD7             ;
1825   DBD7             ;   if the sector number has already been set (BLKNMBR), enter
1826   DBD7             ; at this point.
1827   DBD7             ;
1828   DBD7 21 EB E5    TRKSEC1:	LD	HL,BLKNMBR
1829   DBDA 4E          	LD	C,(HL)		;move sector number into (BC).
1830   DBDB 23          	INC	HL
1831   DBDC 46          	LD	B,(HL)
1832   DBDD 2A BD E5    	LD	HL,(SCRATCH3)	;get current sector number and
1833   DBE0 5E          	LD	E,(HL)		;move this into (DE).
1834   DBE1 23          	INC	HL
1835   DBE2 56          	LD	D,(HL)
1836   DBE3 2A BB E5    	LD	HL,(SCRATCH2)	;get current track number.
1837   DBE6 7E          	LD	A,(HL)		;and this into (HL).
1838   DBE7 23          	INC	HL
1839   DBE8 66          	LD	H,(HL)
1840   DBE9 6F          	LD	L,A
1841   DBEA 79          TRKSEC2:	LD	A,C			;is desired sector before current one?
1842   DBEB 93          	SUB	E
1843   DBEC 78          	LD	A,B
1844   DBED 9A          	SBC	A,D
1845   DBEE D2 00 DC    	JP	NC,TRKSEC3
1846   DBF1 E5          	PUSH	HL			;yes, decrement sectors by one track.
1847   DBF2 2A C7 E5    	LD	HL,(SECTORS)	;get sectors per track.
1848   DBF5 7B          	LD	A,E
1849   DBF6 95          	SUB	L
1850   DBF7 5F          	LD	E,A
1851   DBF8 7A          	LD	A,D
1852   DBF9 9C          	SBC	A,H
1853   DBFA 57          	LD	D,A			;now we have backed up one full track.
1854   DBFB E1          	POP	HL
1855   DBFC 2B          	DEC	HL			;adjust track counter.
1856   DBFD C3 EA DB    	JP	TRKSEC2
1857   DC00 E5          TRKSEC3:	PUSH	HL			;desired sector is after current one.
1858   DC01 2A C7 E5    	LD	HL,(SECTORS)	;get sectors per track.
1859   DC04 19          	ADD	HL,DE			;bump sector pointer to next track.
1860   DC05 DA 15 DC    	JP	C,TRKSEC4
1861   DC08 79          	LD	A,C			;is desired sector now before current one?
1862   DC09 95          	SUB	L
1863   DC0A 78          	LD	A,B
1864   DC0B 9C          	SBC	A,H
1865   DC0C DA 15 DC    	JP	C,TRKSEC4
1866   DC0F EB          	EX	DE,HL			;not yes, increment track counter
1867   DC10 E1          	POP	HL			;and continue until it is.
1868   DC11 23          	INC	HL
1869   DC12 C3 00 DC    	JP	TRKSEC3
1870   DC15             ;
1871   DC15             ;   here we have determined the track number that contains the
1872   DC15             ; desired sector.
1873   DC15             ;
1874   DC15 E1          TRKSEC4:	POP	HL			;get track number (HL).
1875   DC16 C5          	PUSH	BC
1876   DC17 D5          	PUSH	DE
1877   DC18 E5          	PUSH	HL
1878   DC19 EB          	EX	DE,HL
1879   DC1A 2A D4 E5    	LD	HL,(OFFSET)	;adjust for first track offset.
1880   DC1D 19          	ADD	HL,DE
1881   DC1E 44          	LD	B,H
1882   DC1F 4D          	LD	C,L
1883   DC20 CD 1E E6    	CALL	SETTRK		;select this track.
1884   DC23 D1          	POP	DE			;reset current track pointer.
1885   DC24 2A BB E5    	LD	HL,(SCRATCH2)
1886   DC27 73          	LD	(HL),E
1887   DC28 23          	INC	HL
1888   DC29 72          	LD	(HL),D
1889   DC2A D1          	POP	DE
1890   DC2B 2A BD E5    	LD	HL,(SCRATCH3)	;reset the first sector on this track.
1891   DC2E 73          	LD	(HL),E
1892   DC2F 23          	INC	HL
1893   DC30 72          	LD	(HL),D
1894   DC31 C1          	POP	BC
1895   DC32 79          	LD	A,C			;now subtract the desired one.
1896   DC33 93          	SUB	E			;to make it relative (1-# sectors/track).
1897   DC34 4F          	LD	C,A
1898   DC35 78          	LD	A,B
1899   DC36 9A          	SBC	A,D
1900   DC37 47          	LD	B,A
1901   DC38 2A D6 E5    	LD	HL,(XLATE)		;translate this sector according to this table.
1902   DC3B EB          	EX	DE,HL
1903   DC3C CD 30 E6    	CALL	SECTRN		;let the bios translate it.
1904   DC3F 4D          	LD	C,L
1905   DC40 44          	LD	B,H
1906   DC41 C3 21 E6    	JP	SETSEC		;and select it.
1907   DC44             ;
1908   DC44             ;   Compute block number from record number (SAVNREC) and
1909   DC44             ; extent number (SAVEXT).
1910   DC44             ;
1911   DC44 21 C9 E5    GETBLOCK: 	LD	HL,BLKSHFT		;get logical to physical conversion.
1912   DC47 4E          	LD	C,(HL)		;note that this is base 2 log of ratio.
1913   DC48 3A E9 E5    	LD	A,(SAVNREC)	;get record number.
1914   DC4B B7          GETBLK1:	OR	A			;compute (A)=(A)/2^BLKSHFT.
1915   DC4C 1F          	RRA	
1916   DC4D 0D          	DEC	C
1917   DC4E C2 4B DC    	JP	NZ,GETBLK1
1918   DC51 47          	LD	B,A			;save result in (B).
1919   DC52 3E 08       	LD	A,8
1920   DC54 96          	SUB	(HL)
1921   DC55 4F          	LD	C,A			;compute (C)=8-BLKSHFT.
1922   DC56 3A E8 E5    	LD	A,(SAVEXT)
1923   DC59 0D          GETBLK2:	DEC	C			;compute (A)=SAVEXT*2^(8-BLKSHFT).
1924   DC5A CA 62 DC    	JP	Z,GETBLK3
1925   DC5D B7          	OR	A
1926   DC5E 17          	RLA	
1927   DC5F C3 59 DC    	JP	GETBLK2
1928   DC62 80          GETBLK3:	ADD	A,B
1929   DC63 C9          		RET	
1930   DC64             ;
1931   DC64             ;   Routine to extract the (BC) block byte from the fcb pointed
1932   DC64             ; to by (PARAMS). If this is a big-disk, then these are 16 bit
1933   DC64             ; block numbers, else they are 8 bit numbers.
1934   DC64             ; Number is returned in (HL).
1935   DC64             ;
1936   DC64 2A 49 DB    EXTBLK:	LD	HL,(PARAMS)	;get fcb address.
1937   DC67 11 10 00    	LD	DE,16			;block numbers start 16 bytes into fcb.
1938   DC6A 19          	ADD	HL,DE
1939   DC6B 09          	ADD	HL,BC
1940   DC6C 3A E3 E5    	LD	A,(BIGDISK)	;are we using a big-disk?
1941   DC6F B7          	OR	A
1942   DC70 CA 77 DC    	JP	Z,EXTBLK1
1943   DC73 6E          	LD	L,(HL)		;no, extract an 8 bit number from the fcb.
1944   DC74 26 00       	LD	H,0
1945   DC76 C9          	RET	
1946   DC77 09          EXTBLK1:	ADD	HL,BC			;yes, extract a 16 bit number.
1947   DC78 5E          	LD	E,(HL)
1948   DC79 23          	INC	HL
1949   DC7A 56          	LD	D,(HL)
1950   DC7B EB          	EX	DE,HL			;return in (HL).
1951   DC7C C9          	RET	
1952   DC7D             ;
1953   DC7D             ;   Compute block number.
1954   DC7D             ;
1955   DC7D CD 44 DC    COMBLK:	CALL	GETBLOCK
1956   DC80 4F          	LD	C,A
1957   DC81 06 00       	LD	B,0
1958   DC83 CD 64 DC    	CALL	EXTBLK
1959   DC86 22 EB E5    	LD	(BLKNMBR),HL
1960   DC89 C9          	RET	
1961   DC8A             ;
1962   DC8A             ;   Check for a zero block number (unused).
1963   DC8A             ;
1964   DC8A 2A EB E5    CHKBLK:	LD	HL,(BLKNMBR)
1965   DC8D 7D          	LD	A,L			;is it zero?
1966   DC8E B4          	OR	H
1967   DC8F C9          	RET	
1968   DC90             ;
1969   DC90             ;   Adjust physical block (BLKNMBR) and convert to logical
1970   DC90             ; sector (LOGSECT). This is the starting sector of this block.
1971   DC90             ; The actual sector of interest is then added to this and the
1972   DC90             ; resulting sector number is stored back in (BLKNMBR). This
1973   DC90             ; will still have to be adjusted for the track number.
1974   DC90             ;
1975   DC90 3A C9 E5    LOGICAL:	LD	A,(BLKSHFT)	;get log2(physical/logical sectors).
1976   DC93 2A EB E5    		LD	HL,(BLKNMBR)	;get physical sector desired.
1977   DC96 29          LOGICL1:	ADD	HL,HL			;compute logical sector number.
1978   DC97 3D          	DEC	A			;note logical sectors are 128 bytes long.
1979   DC98 C2 96 DC    	JP	NZ,LOGICL1
1980   DC9B 22 ED E5    	LD	(LOGSECT),HL	;save logical sector.
1981   DC9E 3A CA E5    	LD	A,(BLKMASK)	;get block mask.
1982   DCA1 4F          	LD	C,A
1983   DCA2 3A E9 E5    	LD	A,(SAVNREC)	;get next sector to access.
1984   DCA5 A1          	AND	C			;extract the relative position within physical block.
1985   DCA6 B5          	OR	L			;and add it too logical sector.
1986   DCA7 6F          	LD	L,A
1987   DCA8 22 EB E5    	LD	(BLKNMBR),HL	;and store.
1988   DCAB C9          	RET	
1989   DCAC             ;
1990   DCAC             ;   Set (HL) to point to extent byte in fcb.
1991   DCAC             ;
1992   DCAC 2A 49 DB    SETEXT:	LD	HL,(PARAMS)
1993   DCAF 11 0C 00    	LD	DE,12			;it is the twelth byte.
1994   DCB2 19          	ADD	HL,DE
1995   DCB3 C9          	RET	
1996   DCB4             ;
1997   DCB4             ;   Set (HL) to point to record count byte in fcb and (DE) to
1998   DCB4             ; next record number byte.
1999   DCB4             ;
2000   DCB4 2A 49 DB    SETHLDE:	LD	HL,(PARAMS)
2001   DCB7 11 0F 00    	LD	DE,15			;record count byte (#15).
2002   DCBA 19          	ADD	HL,DE
2003   DCBB EB          	EX	DE,HL
2004   DCBC 21 11 00    	LD	HL,17			;next record number (#32).
2005   DCBF 19          	ADD	HL,DE
2006   DCC0 C9          	RET	
2007   DCC1             ;
2008   DCC1             ;   Save current file data from fcb.
2009   DCC1             ;
2010   DCC1 CD B4 DC    STRDATA:	CALL	SETHLDE
2011   DCC4 7E          	LD	A,(HL)		;get and store record count byte.
2012   DCC5 32 E9 E5    	LD	(SAVNREC),A
2013   DCC8 EB          	EX	DE,HL
2014   DCC9 7E          	LD	A,(HL)		;get and store next record number byte.
2015   DCCA 32 E7 E5    	LD	(SAVNXT),A
2016   DCCD CD AC DC    	CALL	SETEXT		;point to extent byte.
2017   DCD0 3A CB E5    	LD	A,(EXTMASK)	;get extent mask.
2018   DCD3 A6          	AND	(HL)
2019   DCD4 32 E8 E5    	LD	(SAVEXT),A	;and save extent here.
2020   DCD7 C9          	RET	
2021   DCD8             ;
2022   DCD8             ;   Set the next record to access. If (MODE) is set to 2, then
2023   DCD8             ; the last record byte (SAVNREC) has the correct number to access.
2024   DCD8             ; For sequential access, (MODE) will be equal to 1.
2025   DCD8             ;
2026   DCD8 CD B4 DC    SETNREC:	CALL	SETHLDE
2027   DCDB 3A DB E5    	LD	A,(MODE)		;get sequential flag (=1).
2028   DCDE FE 02       	CP	2			;a 2 indicates that no adder is needed.
2029   DCE0 C2 E4 DC    	JP	NZ,STNREC1
2030   DCE3 AF          	XOR	A			;clear adder (random access?).
2031   DCE4 4F          STNREC1:	LD	C,A
2032   DCE5 3A E9 E5    	LD	A,(SAVNREC)	;get last record number.
2033   DCE8 81          	ADD	A,C			;increment record count.
2034   DCE9 77          	LD	(HL),A		;and set fcb's next record byte.
2035   DCEA EB          	EX	DE,HL
2036   DCEB 3A E7 E5    	LD	A,(SAVNXT)		;get next record byte from storage.
2037   DCEE 77          	LD	(HL),A		;and put this into fcb as number of records used.
2038   DCEF C9          	RET	
2039   DCF0             ;
2040   DCF0             ;   Shift (HL) right (C) bits.
2041   DCF0             ;
2042   DCF0 0C          SHIFTR:	INC	C
2043   DCF1 0D          SHIFTR1:	DEC	C
2044   DCF2 C8          	RET	Z
2045   DCF3 7C          	LD	A,H
2046   DCF4 B7          	OR	A
2047   DCF5 1F          	RRA	
2048   DCF6 67          	LD	H,A
2049   DCF7 7D          	LD	A,L
2050   DCF8 1F          	RRA	
2051   DCF9 6F          	LD	L,A
2052   DCFA C3 F1 DC    	JP	SHIFTR1
2053   DCFD             ;
2054   DCFD             ;   Compute the check-sum for the directory buffer. Return
2055   DCFD             ; integer sum in (A).
2056   DCFD             ;
2057   DCFD 0E 80       CHECKSUM: 	LD	C,128			;length of buffer.
2058   DCFF 2A BF E5    	LD	HL,(DIRBUF)	;get its location.
2059   DD02 AF          	XOR	A			;clear summation byte.
2060   DD03 86          CHKSUM1:	ADD	A,(HL)		;and compute sum ignoring carries.
2061   DD04 23          	INC	HL
2062   DD05 0D          	DEC	C
2063   DD06 C2 03 DD    	JP	NZ,CHKSUM1
2064   DD09 C9          	RET	
2065   DD0A             ;
2066   DD0A             ;   Shift (HL) left (C) bits.
2067   DD0A             ;
2068   DD0A 0C          SHIFTL:	INC	C
2069   DD0B 0D          SHIFTL1:	DEC	C
2070   DD0C C8          	RET	Z
2071   DD0D 29          	ADD	HL,HL			;shift left 1 bit.
2072   DD0E C3 0B DD    	JP	SHIFTL1
2073   DD11             ;
2074   DD11             ;   Routine to set a bit in a 16 bit value contained in (BC).
2075   DD11             ; The bit set depends on the current drive selection.
2076   DD11             ;
2077   DD11 C5          SETBIT:	PUSH	BC			;save 16 bit word.
2078   DD12 3A 48 DB    	LD	A,(ACTIVE)		;get active drive.
2079   DD15 4F          	LD	C,A
2080   DD16 21 01 00    	LD	HL,1
2081   DD19 CD 0A DD    	CALL	SHIFTL		;shift bit 0 into place.
2082   DD1C C1          	POP	BC			;now 'or' this with the original word.
2083   DD1D 79          	LD	A,C
2084   DD1E B5          	OR	L
2085   DD1F 6F          	LD	L,A			;low byte done, do high byte.
2086   DD20 78          	LD	A,B
2087   DD21 B4          	OR	H
2088   DD22 67          	LD	H,A
2089   DD23 C9          	RET	
2090   DD24             ;
2091   DD24             ;   Extract the write protect status bit for the current drive.
2092   DD24             ; The result is returned in (A), bit 0.
2093   DD24             ;
2094   DD24 2A B3 E5    GETWPRT:	LD	HL,(WRTPRT)	;get status bytes.
2095   DD27 3A 48 DB    	LD	A,(ACTIVE)		;which drive is current?
2096   DD2A 4F          	LD	C,A
2097   DD2B CD F0 DC    	CALL	SHIFTR		;shift status such that bit 0 is the
2098   DD2E 7D          	LD	A,L			;one of interest for this drive.
2099   DD2F E6 01       	AND	01H			;and isolate it.
2100   DD31 C9          	RET	
2101   DD32             ;
2102   DD32             ;   Function to write protect the current disk.
2103   DD32             ;
2104   DD32 21 B3 E5    WRTPRTD:	LD	HL,WRTPRT		;point to status word.
2105   DD35 4E          	LD	C,(HL)		;set (BC) equal to the status.
2106   DD36 23          	INC	HL
2107   DD37 46          	LD	B,(HL)
2108   DD38 CD 11 DD    	CALL	SETBIT		;and set this bit according to current drive.
2109   DD3B 22 B3 E5    	LD	(WRTPRT),HL	;then save.
2110   DD3E 2A CE E5    	LD	HL,(DIRSIZE)	;now save directory size limit.
2111   DD41 23          	INC	HL			;remember the last one.
2112   DD42 EB          	EX	DE,HL
2113   DD43 2A B9 E5    	LD	HL,(SCRATCH1)	;and store it here.
2114   DD46 73          	LD	(HL),E		;put low byte.
2115   DD47 23          	INC	HL
2116   DD48 72          	LD	(HL),D		;then high byte.
2117   DD49 C9          	RET	
2118   DD4A             ;
2119   DD4A             ;   Check for a read only file.
2120   DD4A             ;
2121   DD4A CD 64 DD    CHKROFL:	CALL	FCB2HL		;set (HL) to file entry in directory buffer.
2122   DD4D 11 09 00    CKROF1:	LD	DE,9			;look at bit 7 of the ninth byte.
2123   DD50 19          	ADD	HL,DE
2124   DD51 7E          	LD	A,(HL)
2125   DD52 17          	RLA	
2126   DD53 D0          	RET	NC			;return if ok.
2127   DD54 21 15 D8    	LD	HL,ROFILE		;else, print error message and terminate.
2128   DD57 C3 50 DB    	JP	JUMPHL
2129   DD5A             ;
2130   DD5A             ;   Check the write protect status of the active disk.
2131   DD5A             ;
2132   DD5A CD 24 DD    CHKWPRT:	CALL	GETWPRT
2133   DD5D C8          	RET	Z			;return if ok.
2134   DD5E 21 13 D8    	LD	HL,RODISK		;else print message and terminate.
2135   DD61 C3 50 DB    	JP	JUMPHL
2136   DD64             ;
2137   DD64             ;   Routine to set (HL) pointing to the proper entry in the
2138   DD64             ; directory buffer.
2139   DD64             ;
2140   DD64 2A BF E5    FCB2HL:	LD	HL,(DIRBUF)	;get address of buffer.
2141   DD67 3A EF E5    		LD	A,(FCBPOS)		;relative position of file.
2142   DD6A             ;
2143   DD6A             ;   Routine to add (A) to (HL).
2144   DD6A             ;
2145   DD6A 85          ADDA2HL:	ADD	A,L
2146   DD6B 6F          	LD	L,A
2147   DD6C D0          	RET	NC
2148   DD6D 24          	INC	H			;take care of any carry.
2149   DD6E C9          	RET	
2150   DD6F             ;
2151   DD6F             ;   Routine to get the 's2' byte from the fcb supplied in
2152   DD6F             ; the initial parameter specification.
2153   DD6F             ;
2154   DD6F 2A 49 DB    GETS2:	LD	HL,(PARAMS)	;get address of fcb.
2155   DD72 11 0E 00    	LD	DE,14			;relative position of 's2'.
2156   DD75 19          	ADD	HL,DE
2157   DD76 7E          	LD	A,(HL)		;extract this byte.
2158   DD77 C9          	RET	
2159   DD78             ;
2160   DD78             ;   Clear the 's2' byte in the fcb.
2161   DD78             ;
2162   DD78 CD 6F DD    CLEARS2:	CALL	GETS2			;this sets (HL) pointing to it.
2163   DD7B 36 00       	LD	(HL),0		;now clear it.
2164   DD7D C9          	RET	
2165   DD7E             ;
2166   DD7E             ;   Set bit 7 in the 's2' byte of the fcb.
2167   DD7E             ;
2168   DD7E CD 6F DD    SETS2B7:	CALL	GETS2			;get the byte.
2169   DD81 F6 80       	OR	80H			;and set bit 7.
2170   DD83 77          	LD	(HL),A		;then store.
2171   DD84 C9          	RET	
2172   DD85             ;
2173   DD85             ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
2174   DD85             ; the difference. This checks to see if there are more file
2175   DD85             ; names in the directory. We are at (FILEPOS) and there are
2176   DD85             ; (SCRATCH1) of them to check.
2177   DD85             ;
2178   DD85 2A F0 E5    MOREFLS:	LD	HL,(FILEPOS)	;we are here.
2179   DD88 EB          	EX	DE,HL
2180   DD89 2A B9 E5    	LD	HL,(SCRATCH1)	;and don't go past here.
2181   DD8C 7B          	LD	A,E			;compute difference but don't keep.
2182   DD8D 96          	SUB	(HL)
2183   DD8E 23          	INC	HL
2184   DD8F 7A          	LD	A,D
2185   DD90 9E          	SBC	A,(HL)		;set carry if no more names.
2186   DD91 C9          	RET	
2187   DD92             ;
2188   DD92             ;   Call this routine to prevent (SCRATCH1) from being greater
2189   DD92             ; than (FILEPOS).
2190   DD92             ;
2191   DD92 CD 85 DD    CHKNMBR:	CALL	MOREFLS		;SCRATCH1 too big?
2192   DD95 D8          	RET	C
2193   DD96 13          	INC	DE			;yes, reset it to (FILEPOS).
2194   DD97 72          	LD	(HL),D
2195   DD98 2B          	DEC	HL
2196   DD99 73          	LD	(HL),E
2197   DD9A C9          	RET	
2198   DD9B             ;
2199   DD9B             ;   Compute (HL)=(DE)-(HL)
2200   DD9B             ;
2201   DD9B 7B          SUBHL:	LD	A,E			;compute difference.
2202   DD9C 95          	SUB	L
2203   DD9D 6F          	LD	L,A			;store low byte.
2204   DD9E 7A          	LD	A,D
2205   DD9F 9C          	SBC	A,H
2206   DDA0 67          	LD	H,A			;and then high byte.
2207   DDA1 C9          	RET	
2208   DDA2             ;
2209   DDA2             ;   Set the directory checksum byte.
2210   DDA2             ;
2211   DDA2 0E FF       SETDIR:	LD	C,0FFH
2212   DDA4             ;
2213   DDA4             ;   Routine to set or compare the directory checksum byte. If
2214   DDA4             ; (C)=0ffh, then this will set the checksum byte. Else the byte
2215   DDA4             ; will be checked. If the check fails (the disk has been changed),
2216   DDA4             ; then this disk will be write protected.
2217   DDA4             ;
2218   DDA4 2A F2 E5    CHECKDIR: 	LD	HL,(CKSUMTBL)
2219   DDA7 EB          	EX	DE,HL
2220   DDA8 2A D2 E5    	LD	HL,(ALLOC1)
2221   DDAB CD 9B DD    	CALL	SUBHL
2222   DDAE D0          	RET	NC			;ok if (CKSUMTBL) > (ALLOC1), so return.
2223   DDAF C5          	PUSH	BC
2224   DDB0 CD FD DC    	CALL	CHECKSUM		;else compute checksum.
2225   DDB3 2A C3 E5    	LD	HL,(CHKVECT)	;get address of checksum table.
2226   DDB6 EB          	EX	DE,HL
2227   DDB7 2A F2 E5    	LD	HL,(CKSUMTBL)
2228   DDBA 19          	ADD	HL,DE			;set (HL) to point to byte for this drive.
2229   DDBB C1          	POP	BC
2230   DDBC 0C          	INC	C			;set or check ?
2231   DDBD CA CA DD    	JP	Z,CHKDIR1
2232   DDC0 BE          	CP	(HL)			;check them.
2233   DDC1 C8          	RET	Z			;return if they are the same.
2234   DDC2 CD 85 DD    	CALL	MOREFLS		;not the same, do we care?
2235   DDC5 D0          	RET	NC
2236   DDC6 CD 32 DD    	CALL	WRTPRTD		;yes, mark this as write protected.
2237   DDC9 C9          	RET	
2238   DDCA 77          CHKDIR1:	LD	(HL),A		;just set the byte.
2239   DDCB C9          		RET	
2240   DDCC             ;
2241   DDCC             ;   Do a write to the directory of the current disk.
2242   DDCC             ;
2243   DDCC CD A2 DD    DIRWRITE: 	CALL	SETDIR		;set checksum byte.
2244   DDCF CD E6 DD    	CALL	DIRDMA		;set directory dma address.
2245   DDD2 0E 01       	LD	C,1			;tell the bios to actually write.
2246   DDD4 CD BE DB    	CALL	DOWRITE		;then do the write.
2247   DDD7 C3 E0 DD    	JP	DEFDMA
2248   DDDA             ;
2249   DDDA             ;   Read from the directory.
2250   DDDA             ;
2251   DDDA CD E6 DD    DIRREAD:	CALL	DIRDMA		;set the directory dma address.
2252   DDDD CD B8 DB    	CALL	DOREAD		;and read it.
2253   DDE0             ;
2254   DDE0             ;   Routine to set the dma address to the users choice.
2255   DDE0             ;
2256   DDE0 21 B7 E5    DEFDMA:	LD	HL,USERDMA		;reset the default dma address and return.
2257   DDE3 C3 E9 DD    		JP	DIRDMA1
2258   DDE6             ;
2259   DDE6             ;   Routine to set the dma address for directory work.
2260   DDE6             ;
2261   DDE6 21 BF E5    DIRDMA:	LD	HL,DIRBUF
2262   DDE9             ;
2263   DDE9             ;   Set the dma address. On entry, (HL) points to
2264   DDE9             ; word containing the desired dma address.
2265   DDE9             ;
2266   DDE9 4E          DIRDMA1:	LD	C,(HL)
2267   DDEA 23          	INC	HL
2268   DDEB 46          	LD	B,(HL)		;setup (BC) and go to the bios to set it.
2269   DDEC C3 24 E6    	JP	SETDMA
2270   DDEF             ;
2271   DDEF             ;   Move the directory buffer into user's dma space.
2272   DDEF             ;
2273   DDEF 2A BF E5    MOVEDIR:	LD	HL,(DIRBUF)	;buffer is located here, and
2274   DDF2 EB          	EX	DE,HL
2275   DDF3 2A B7 E5    	LD	HL,(USERDMA)	; put it here.
2276   DDF6 0E 80       	LD	C,128			;this is its length.
2277   DDF8 C3 55 DB    	JP	DE2HL			;move it now and return.
2278   DDFB             ;
2279   DDFB             ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
2280   DDFB             ;
2281   DDFB 21 F0 E5    CKFILPOS: 	LD	HL,FILEPOS
2282   DDFE 7E          	LD	A,(HL)
2283   DDFF 23          	INC	HL
2284   DE00 BE          	CP	(HL)			;are both bytes the same?
2285   DE01 C0          	RET	NZ
2286   DE02 3C          	INC	A			;yes, but are they each 0ffh?
2287   DE03 C9          	RET	
2288   DE04             ;
2289   DE04             ;   Set location (FILEPOS) to 0ffffh.
2290   DE04             ;
2291   DE04 21 FF FF    STFILPOS: 	LD	HL,0FFFFH
2292   DE07 22 F0 E5    	LD	(FILEPOS),HL
2293   DE0A C9          	RET	
2294   DE0B             ;
2295   DE0B             ;   Move on to the next file position within the current
2296   DE0B             ; directory buffer. If no more exist, set pointer to 0ffffh
2297   DE0B             ; and the calling routine will check for this. Enter with (C)
2298   DE0B             ; equal to 0ffh to cause the checksum byte to be set, else we
2299   DE0B             ; will check this disk and set write protect if checksums are
2300   DE0B             ; not the same (applies only if another directory sector must
2301   DE0B             ; be read).
2302   DE0B             ;
2303   DE0B 2A CE E5    NXENTRY:	LD	HL,(DIRSIZE)	;get directory entry size limit.
2304   DE0E EB          	EX	DE,HL
2305   DE0F 2A F0 E5    	LD	HL,(FILEPOS)	;get current count.
2306   DE12 23          	INC	HL			;go on to the next one.
2307   DE13 22 F0 E5    	LD	(FILEPOS),HL
2308   DE16 CD 9B DD    	CALL	SUBHL			;(HL)=(DIRSIZE)-(FILEPOS)
2309   DE19 D2 1F DE    	JP	NC,NXENT1		;is there more room left?
2310   DE1C C3 04 DE    	JP	STFILPOS		;no. Set this flag and return.
2311   DE1F 3A F0 E5    NXENT1:	LD	A,(FILEPOS)	;get file position within directory.
2312   DE22 E6 03       	AND	03H			;only look within this sector (only 4 entries fit).
2313   DE24 06 05       	LD	B,5			;convert to relative position (32 bytes each).
2314   DE26 87          NXENT2:	ADD	A,A			;note that this is not efficient code.
2315   DE27 05          	DEC	B			;5 'ADD A's would be better.
2316   DE28 C2 26 DE    	JP	NZ,NXENT2
2317   DE2B 32 EF E5    	LD	(FCBPOS),A		;save it as position of fcb.
2318   DE2E B7          	OR	A
2319   DE2F C0          	RET	NZ			;return if we are within buffer.
2320   DE30 C5          	PUSH	BC
2321   DE31 CD C9 DB    	CALL	TRKSEC		;we need the next directory sector.
2322   DE34 CD DA DD    	CALL	DIRREAD
2323   DE37 C1          	POP	BC
2324   DE38 C3 A4 DD    	JP	CHECKDIR
2325   DE3B             ;
2326   DE3B             ;   Routine to to get a bit from the disk space allocation
2327   DE3B             ; map. It is returned in (A), bit position 0. On entry to here,
2328   DE3B             ; set (BC) to the block number on the disk to check.
2329   DE3B             ; On return, (D) will contain the original bit position for
2330   DE3B             ; this block number and (HL) will point to the address for it.
2331   DE3B             ;
2332   DE3B 79          CKBITMAP: 	LD	A,C			;determine bit number of interest.
2333   DE3C E6 07       	AND	07H			;compute (D)=(E)=(C and 7)+1.
2334   DE3E 3C          	INC	A
2335   DE3F 5F          	LD	E,A			;save particular bit number.
2336   DE40 57          	LD	D,A
2337   DE41             ;
2338   DE41             ;   compute (BC)=(BC)/8.
2339   DE41             ;
2340   DE41 79          	LD	A,C
2341   DE42 0F          	RRCA				;now shift right 3 bits.
2342   DE43 0F          	RRCA	
2343   DE44 0F          	RRCA	
2344   DE45 E6 1F       	AND	1FH			;and clear bits 7,6,5.
2345   DE47 4F          	LD	C,A
2346   DE48 78          	LD	A,B
2347   DE49 87          	ADD	A,A			;now shift (B) into bits 7,6,5.
2348   DE4A 87          	ADD	A,A
2349   DE4B 87          	ADD	A,A
2350   DE4C 87          	ADD	A,A
2351   DE4D 87          	ADD	A,A
2352   DE4E B1          	OR	C			;and add in (C).
2353   DE4F 4F          	LD	C,A			;ok, (C) ha been completed.
2354   DE50 78          	LD	A,B			;is there a better way of doing this?
2355   DE51 0F          	RRCA	
2356   DE52 0F          	RRCA	
2357   DE53 0F          	RRCA	
2358   DE54 E6 1F       	AND	1FH
2359   DE56 47          	LD	B,A			;and now (B) is completed.
2360   DE57             ;
2361   DE57             ;   use this as an offset into the disk space allocation
2362   DE57             ; table.
2363   DE57             ;
2364   DE57 2A C5 E5    	LD	HL,(ALOCVECT)
2365   DE5A 09          	ADD	HL,BC
2366   DE5B 7E          	LD	A,(HL)		;now get correct byte.
2367   DE5C 07          CKBMAP1:	RLCA				;get correct bit into position 0.
2368   DE5D 1D          	DEC	E
2369   DE5E C2 5C DE    	JP	NZ,CKBMAP1
2370   DE61 C9          	RET	
2371   DE62             ;
2372   DE62             ;   Set or clear the bit map such that block number (BC) will be marked
2373   DE62             ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
2374   DE62             ; 1 then it will be set (don't use anyother values).
2375   DE62             ;
2376   DE62 D5          STBITMAP: 	PUSH	DE
2377   DE63 CD 3B DE    	CALL	CKBITMAP		;get the byte of interest.
2378   DE66 E6 FE       	AND	0FEH			;clear the affected bit.
2379   DE68 C1          	POP	BC
2380   DE69 B1          	OR	C			;and now set it acording to (C).
2381   DE6A             ;
2382   DE6A             ;  entry to restore the original bit position and then store
2383   DE6A             ; in table. (A) contains the value, (D) contains the bit
2384   DE6A             ; position (1-8), and (HL) points to the address within the
2385   DE6A             ; space allocation table for this byte.
2386   DE6A             ;
2387   DE6A 0F          STBMAP1:	RRCA				;restore original bit position.
2388   DE6B 15          	DEC	D
2389   DE6C C2 6A DE    	JP	NZ,STBMAP1
2390   DE6F 77          	LD	(HL),A		;and stor byte in table.
2391   DE70 C9          	RET	
2392   DE71             ;
2393   DE71             ;   Set/clear space used bits in allocation map for this file.
2394   DE71             ; On entry, (C)=1 to set the map and (C)=0 to clear it.
2395   DE71             ;
2396   DE71 CD 64 DD    SETFILE:	CALL	FCB2HL		;get address of fcb
2397   DE74 11 10 00    	LD	DE,16
2398   DE77 19          	ADD	HL,DE			;get to block number bytes.
2399   DE78 C5          	PUSH	BC
2400   DE79 0E 11       	LD	C,17			;check all 17 bytes (max) of table.
2401   DE7B D1          SETFL1:	POP	DE
2402   DE7C 0D          	DEC	C			;done all bytes yet?
2403   DE7D C8          	RET	Z
2404   DE7E D5          	PUSH	DE
2405   DE7F 3A E3 E5    	LD	A,(BIGDISK)	;check disk size for 16 bit block numbers.
2406   DE82 B7          	OR	A
2407   DE83 CA 8E DE    	JP	Z,SETFL2
2408   DE86 C5          	PUSH	BC			;only 8 bit numbers. set (BC) to this one.
2409   DE87 E5          	PUSH	HL
2410   DE88 4E          	LD	C,(HL)		;get low byte from table, always
2411   DE89 06 00       	LD	B,0			;set high byte to zero.
2412   DE8B C3 94 DE    	JP	SETFL3
2413   DE8E 0D          SETFL2:	DEC	C			;for 16 bit block numbers, adjust counter.
2414   DE8F C5          	PUSH	BC
2415   DE90 4E          	LD	C,(HL)		;now get both the low and high bytes.
2416   DE91 23          	INC	HL
2417   DE92 46          	LD	B,(HL)
2418   DE93 E5          	PUSH	HL
2419   DE94 79          SETFL3:	LD	A,C			;block used?
2420   DE95 B0          	OR	B
2421   DE96 CA A3 DE    	JP	Z,SETFL4
2422   DE99 2A CC E5    	LD	HL,(DSKSIZE)	;is this block number within the
2423   DE9C 7D          	LD	A,L			;space on the disk?
2424   DE9D 91          	SUB	C
2425   DE9E 7C          	LD	A,H
2426   DE9F 98          	SBC	A,B
2427   DEA0 D4 62 DE    	CALL	NC,STBITMAP	;yes, set the proper bit.
2428   DEA3 E1          SETFL4:	POP	HL			;point to next block number in fcb.
2429   DEA4 23          	INC	HL
2430   DEA5 C1          	POP	BC
2431   DEA6 C3 7B DE    	JP	SETFL1
2432   DEA9             ;
2433   DEA9             ;   Construct the space used allocation bit map for the active
2434   DEA9             ; drive. If a file name starts with '$' and it is under the
2435   DEA9             ; current user number, then (STATUS) is set to minus 1. Otherwise
2436   DEA9             ; it is not set at all.
2437   DEA9             ;
2438   DEA9 2A CC E5    BITMAP:	LD	HL,(DSKSIZE)	;compute size of allocation table.
2439   DEAC 0E 03       	LD	C,3
2440   DEAE CD F0 DC    	CALL	SHIFTR		;(HL)=(HL)/8.
2441   DEB1 23          	INC	HL			;at lease 1 byte.
2442   DEB2 44          	LD	B,H
2443   DEB3 4D          	LD	C,L			;set (BC) to the allocation table length.
2444   DEB4             ;
2445   DEB4             ;   Initialize the bitmap for this drive. Right now, the first
2446   DEB4             ; two bytes are specified by the disk parameter block. However
2447   DEB4             ; a patch could be entered here if it were necessary to setup
2448   DEB4             ; this table in a special mannor. For example, the bios could
2449   DEB4             ; determine locations of 'bad blocks' and set them as already
2450   DEB4             ; 'used' in the map.
2451   DEB4             ;
2452   DEB4 2A C5 E5    	LD	HL,(ALOCVECT)		;now zero out the table now.
2453   DEB7 36 00       BITMAP1:	LD	(HL),0
2454   DEB9 23          	INC	HL
2455   DEBA 0B          	DEC	BC
2456   DEBB 78          	LD	A,B
2457   DEBC B1          	OR	C
2458   DEBD C2 B7 DE    	JP	NZ,BITMAP1
2459   DEC0 2A D0 E5    	LD	HL,(ALLOC0)	;get initial space used by directory.
2460   DEC3 EB          	EX	DE,HL
2461   DEC4 2A C5 E5    	LD	HL,(ALOCVECT)	;and put this into map.
2462   DEC7 73          	LD	(HL),E
2463   DEC8 23          	INC	HL
2464   DEC9 72          	LD	(HL),D
2465   DECA             ;
2466   DECA             ;   End of initialization portion.
2467   DECA             ;
2468   DECA CD A7 DB    	CALL	HOMEDRV		;now home the drive.
2469   DECD 2A B9 E5    	LD	HL,(SCRATCH1)
2470   DED0 36 03       	LD	(HL),3		;force next directory request to read
2471   DED2 23          	INC	HL			;in a sector.
2472   DED3 36 00       	LD	(HL),0
2473   DED5 CD 04 DE    	CALL	STFILPOS		;clear initial file position also.
2474   DED8 0E FF       BITMAP2:	LD	C,0FFH		;read next file name in directory
2475   DEDA CD 0B DE    	CALL	NXENTRY		;and set checksum byte.
2476   DEDD CD FB DD    	CALL	CKFILPOS		;is there another file?
2477   DEE0 C8          	RET	Z
2478   DEE1 CD 64 DD    	CALL	FCB2HL		;yes, get its address.
2479   DEE4 3E E5       	LD	A,0E5H
2480   DEE6 BE          	CP	(HL)			;empty file entry?
2481   DEE7 CA D8 DE    	JP	Z,BITMAP2
2482   DEEA 3A 47 DB    	LD	A,(USERNO)		;no, correct user number?
2483   DEED BE          	CP	(HL)
2484   DEEE C2 FC DE    	JP	NZ,BITMAP3
2485   DEF1 23          	INC	HL
2486   DEF2 7E          	LD	A,(HL)		;yes, does name start with a '$'?
2487   DEF3 D6 24       	SUB	'$'
2488   DEF5 C2 FC DE    	JP	NZ,BITMAP3
2489   DEF8 3D          	DEC	A			;yes, set atatus to minus one.
2490   DEF9 32 4B DB    	LD	(STATUS),A
2491   DEFC 0E 01       BITMAP3:	LD	C,1			;now set this file's space as used in bit map.
2492   DEFE CD 71 DE    	CALL	SETFILE
2493   DF01 CD 92 DD    	CALL	CHKNMBR		;keep (SCRATCH1) in bounds.
2494   DF04 C3 D8 DE    	JP	BITMAP2
2495   DF07             ;
2496   DF07             ;   Set the status (STATUS) and return.
2497   DF07             ;
2498   DF07 3A DA E5    STSTATUS: 	LD	A,(FNDSTAT)
2499   DF0A C3 07 DB    		JP	SETSTAT
2500   DF0D             ;
2501   DF0D             ;   Check extents in (A) and (C). Set the zero flag if they
2502   DF0D             ; are the same. The number of 16k chunks of disk space that
2503   DF0D             ; the directory extent covers is expressad is (EXTMASK+1).
2504   DF0D             ; No registers are modified.
2505   DF0D             ;
2506   DF0D C5          SAMEXT:	PUSH	BC
2507   DF0E F5          	PUSH	AF
2508   DF0F 3A CB E5    	LD	A,(EXTMASK)	;get extent mask and use it to
2509   DF12 2F          	CPL				;to compare both extent numbers.
2510   DF13 47          	LD	B,A			;save resulting mask here.
2511   DF14 79          	LD	A,C			;mask first extent and save in (C).
2512   DF15 A0          	AND	B
2513   DF16 4F          	LD	C,A
2514   DF17 F1          	POP	AF			;now mask second extent and compare
2515   DF18 A0          	AND	B			;with the first one.
2516   DF19 91          	SUB	C
2517   DF1A E6 1F       	AND	1FH			;(* only check buts 0-4 *)
2518   DF1C C1          	POP	BC			;the zero flag is set if they are the same.
2519   DF1D C9          	RET				;restore (BC) and return.
2520   DF1E             ;
2521   DF1E             ;   Search for the first occurence of a file name. On entry,
2522   DF1E             ; register (C) should contain the number of bytes of the fcb
2523   DF1E             ; that must match.
2524   DF1E             ;
2525   DF1E 3E FF       FINDFST:	LD	A,0FFH
2526   DF20 32 DA E5    	LD	(FNDSTAT),A
2527   DF23 21 DE E5    	LD	HL,COUNTER		;save character count.
2528   DF26 71          	LD	(HL),C
2529   DF27 2A 49 DB    	LD	HL,(PARAMS)	;get filename to match.
2530   DF2A 22 DF E5    	LD	(SAVEFCB),HL	;and save.
2531   DF2D CD 04 DE    	CALL	STFILPOS		;clear initial file position (set to 0ffffh).
2532   DF30 CD A7 DB    	CALL	HOMEDRV		;home the drive.
2533   DF33             ;
2534   DF33             ;   Entry to locate the next occurence of a filename within the
2535   DF33             ; directory. The disk is not expected to have been changed. If
2536   DF33             ; it was, then it will be write protected.
2537   DF33             ;
2538   DF33 0E 00       FINDNXT:	LD	C,0			;write protect the disk if changed.
2539   DF35 CD 0B DE    	CALL	NXENTRY		;get next filename entry in directory.
2540   DF38 CD FB DD    	CALL	CKFILPOS		;is file position = 0ffffh?
2541   DF3B CA 9A DF    	JP	Z,FNDNXT6		;yes, exit now then.
2542   DF3E 2A DF E5    	LD	HL,(SAVEFCB)	;set (DE) pointing to filename to match.
2543   DF41 EB          	EX	DE,HL
2544   DF42 1A          	LD	A,(DE)
2545   DF43 FE E5       	CP	0E5H			;empty directory entry?
2546   DF45 CA 50 DF    	JP	Z,FNDNXT1		;(* are we trying to reserect erased entries? *)
2547   DF48 D5          	PUSH	DE
2548   DF49 CD 85 DD    	CALL	MOREFLS		;more files in directory?
2549   DF4C D1          	POP	DE
2550   DF4D D2 9A DF    	JP	NC,FNDNXT6		;no more. Exit now.
2551   DF50 CD 64 DD    FNDNXT1:	CALL	FCB2HL		;get address of this fcb in directory.
2552   DF53 3A DE E5    	LD	A,(COUNTER)	;get number of bytes (characters) to check.
2553   DF56 4F          	LD	C,A
2554   DF57 06 00       	LD	B,0			;initialize byte position counter.
2555   DF59 79          FNDNXT2:	LD	A,C			;are we done with the compare?
2556   DF5A B7          	OR	A
2557   DF5B CA 89 DF    	JP	Z,FNDNXT5
2558   DF5E 1A          	LD	A,(DE)		;no, check next byte.
2559   DF5F FE 3F       	CP	'?'			;don't care about this character?
2560   DF61 CA 82 DF    	JP	Z,FNDNXT4
2561   DF64 78          	LD	A,B			;get bytes position in fcb.
2562   DF65 FE 0D       	CP	13			;don't care about the thirteenth byte either.
2563   DF67 CA 82 DF    	JP	Z,FNDNXT4
2564   DF6A FE 0C       	CP	12			;extent byte?
2565   DF6C 1A          	LD	A,(DE)
2566   DF6D CA 79 DF    	JP	Z,FNDNXT3
2567   DF70 96          	SUB	(HL)			;otherwise compare characters.
2568   DF71 E6 7F       	AND	7FH
2569   DF73 C2 33 DF    	JP	NZ,FINDNXT		;not the same, check next entry.
2570   DF76 C3 82 DF    	JP	FNDNXT4		;so far so good, keep checking.
2571   DF79 C5          FNDNXT3:	PUSH	BC			;check the extent byte here.
2572   DF7A 4E          	LD	C,(HL)
2573   DF7B CD 0D DF    	CALL	SAMEXT
2574   DF7E C1          	POP	BC
2575   DF7F C2 33 DF    	JP	NZ,FINDNXT		;not the same, look some more.
2576   DF82             ;
2577   DF82             ;   So far the names compare. Bump pointers to the next byte
2578   DF82             ; and continue until all (C) characters have been checked.
2579   DF82             ;
2580   DF82 13          FNDNXT4:	INC	DE			;bump pointers.
2581   DF83 23          	INC	HL
2582   DF84 04          	INC	B
2583   DF85 0D          	DEC	C			;adjust character counter.
2584   DF86 C3 59 DF    	JP	FNDNXT2
2585   DF89 3A F0 E5    FNDNXT5:	LD	A,(FILEPOS)	;return the position of this entry.
2586   DF8C E6 03       	AND	03H
2587   DF8E 32 4B DB    	LD	(STATUS),A
2588   DF91 21 DA E5    	LD	HL,FNDSTAT
2589   DF94 7E          	LD	A,(HL)
2590   DF95 17          	RLA	
2591   DF96 D0          	RET	NC
2592   DF97 AF          	XOR	A
2593   DF98 77          	LD	(HL),A
2594   DF99 C9          	RET	
2595   DF9A             ;
2596   DF9A             ;   Filename was not found. Set appropriate status.
2597   DF9A             ;
2598   DF9A CD 04 DE    FNDNXT6:	CALL	STFILPOS		;set (FILEPOS) to 0ffffh.
2599   DF9D 3E FF       	LD	A,0FFH		;say not located.
2600   DF9F C3 07 DB    	JP	SETSTAT
2601   DFA2             ;
2602   DFA2             ;   Erase files from the directory. Only the first byte of the
2603   DFA2             ; fcb will be affected. It is set to (E5).
2604   DFA2             ;
2605   DFA2 CD 5A DD    ERAFILE:	CALL	CHKWPRT		;is disk write protected?
2606   DFA5 0E 0C       	LD	C,12			;only compare file names.
2607   DFA7 CD 1E DF    	CALL	FINDFST		;get first file name.
2608   DFAA CD FB DD    ERAFIL1:	CALL	CKFILPOS		;any found?
2609   DFAD C8          	RET	Z			;nope, we must be done.
2610   DFAE CD 4A DD    	CALL	CHKROFL		;is file read only?
2611   DFB1 CD 64 DD    	CALL	FCB2HL		;nope, get address of fcb and
2612   DFB4 36 E5       	LD	(HL),0E5H		;set first byte to 'empty'.
2613   DFB6 0E 00       	LD	C,0			;clear the space from the bit map.
2614   DFB8 CD 71 DE    	CALL	SETFILE
2615   DFBB CD CC DD    	CALL	DIRWRITE		;now write the directory sector back out.
2616   DFBE CD 33 DF    	CALL	FINDNXT		;find the next file name.
2617   DFC1 C3 AA DF    	JP	ERAFIL1		;and repeat process.
2618   DFC4             ;
2619   DFC4             ;   Look through the space allocation map (bit map) for the
2620   DFC4             ; next available block. Start searching at block number (BC-1).
2621   DFC4             ; The search procedure is to look for an empty block that is
2622   DFC4             ; before the starting block. If not empty, look at a later
2623   DFC4             ; block number. In this way, we return the closest empty block
2624   DFC4             ; on either side of the 'target' block number. This will speed
2625   DFC4             ; access on random devices. For serial devices, this should be
2626   DFC4             ; changed to look in the forward direction first and then start
2627   DFC4             ; at the front and search some more.
2628   DFC4             ;
2629   DFC4             ;   On return, (DE)= block number that is empty and (HL) =0
2630   DFC4             ; if no empry block was found.
2631   DFC4             ;
2632   DFC4 50          FNDSPACE: 	LD	D,B			;set (DE) as the block that is checked.
2633   DFC5 59          		LD	E,C
2634   DFC6             ;
2635   DFC6             ;   Look before target block. Registers (BC) are used as the lower
2636   DFC6             ; pointer and (DE) as the upper pointer.
2637   DFC6             ;
2638   DFC6 79          FNDSPA1:	LD	A,C			;is block 0 specified?
2639   DFC7 B0          	OR	B
2640   DFC8 CA D7 DF    	JP	Z,FNDSPA2
2641   DFCB 0B          	DEC	BC			;nope, check previous block.
2642   DFCC D5          	PUSH	DE
2643   DFCD C5          	PUSH	BC
2644   DFCE CD 3B DE    	CALL	CKBITMAP
2645   DFD1 1F          	RRA				;is this block empty?
2646   DFD2 D2 F2 DF    	JP	NC,FNDSPA3		;yes. use this.
2647   DFD5             ;
2648   DFD5             ;   Note that the above logic gets the first block that it finds
2649   DFD5             ; that is empty. Thus a file could be written 'backward' making
2650   DFD5             ; it very slow to access. This could be changed to look for the
2651   DFD5             ; first empty block and then continue until the start of this
2652   DFD5             ; empty space is located and then used that starting block.
2653   DFD5             ; This should help speed up access to some files especially on
2654   DFD5             ; a well used disk with lots of fairly small 'holes'.
2655   DFD5             ;
2656   DFD5 C1          	POP	BC			;nope, check some more.
2657   DFD6 D1          	POP	DE
2658   DFD7             ;
2659   DFD7             ;   Now look after target block.
2660   DFD7             ;
2661   DFD7 2A CC E5    FNDSPA2:	LD	HL,(DSKSIZE)	;is block (DE) within disk limits?
2662   DFDA 7B          	LD	A,E
2663   DFDB 95          	SUB	L
2664   DFDC 7A          	LD	A,D
2665   DFDD 9C          	SBC	A,H
2666   DFDE D2 FA DF    	JP	NC,FNDSPA4
2667   DFE1 13          	INC	DE			;yes, move on to next one.
2668   DFE2 C5          	PUSH	BC
2669   DFE3 D5          	PUSH	DE
2670   DFE4 42          	LD	B,D
2671   DFE5 4B          	LD	C,E
2672   DFE6 CD 3B DE    	CALL	CKBITMAP		;check it.
2673   DFE9 1F          	RRA				;empty?
2674   DFEA D2 F2 DF    	JP	NC,FNDSPA3
2675   DFED D1          	POP	DE			;nope, continue searching.
2676   DFEE C1          	POP	BC
2677   DFEF C3 C6 DF    	JP	FNDSPA1
2678   DFF2             ;
2679   DFF2             ;   Empty block found. Set it as used and return with (HL)
2680   DFF2             ; pointing to it (true?).
2681   DFF2             ;
2682   DFF2 17          FNDSPA3:	RLA				;reset byte.
2683   DFF3 3C          	INC	A			;and set bit 0.
2684   DFF4 CD 6A DE    	CALL	STBMAP1		;update bit map.
2685   DFF7 E1          	POP	HL			;set return registers.
2686   DFF8 D1          	POP	DE
2687   DFF9 C9          	RET	
2688   DFFA             ;
2689   DFFA             ;   Free block was not found. If (BC) is not zero, then we have
2690   DFFA             ; not checked all of the disk space.
2691   DFFA             ;
2692   DFFA 79          FNDSPA4:	LD	A,C
2693   DFFB B0          	OR	B
2694   DFFC C2 C6 DF    	JP	NZ,FNDSPA1
2695   DFFF 21 00 00    	LD	HL,0			;set 'not found' status.
2696   E002 C9          	RET	
2697   E003             ;
2698   E003             ;   Move a complete fcb entry into the directory and write it.
2699   E003             ;
2700   E003 0E 00       FCBSET:	LD	C,0
2701   E005 1E 20       		LD	E,32			;length of each entry.
2702   E007             ;
2703   E007             ;   Move (E) bytes from the fcb pointed to by (PARAMS) into
2704   E007             ; fcb in directory starting at relative byte (C). This updated
2705   E007             ; directory buffer is then written to the disk.
2706   E007             ;
2707   E007 D5          UPDATE:	PUSH	DE
2708   E008 06 00       	LD	B,0			;set (BC) to relative byte position.
2709   E00A 2A 49 DB    	LD	HL,(PARAMS)	;get address of fcb.
2710   E00D 09          	ADD	HL,BC			;compute starting byte.
2711   E00E EB          	EX	DE,HL
2712   E00F CD 64 DD    	CALL	FCB2HL		;get address of fcb to update in directory.
2713   E012 C1          	POP	BC			;set (C) to number of bytes to change.
2714   E013 CD 55 DB    	CALL	DE2HL
2715   E016 CD C9 DB    UPDATE1:	CALL	TRKSEC		;determine the track and sector affected.
2716   E019 C3 CC DD    		JP	DIRWRITE		;then write this sector out.
2717   E01C             ;
2718   E01C             ;   Routine to change the name of all files on the disk with a
2719   E01C             ; specified name. The fcb contains the current name as the
2720   E01C             ; first 12 characters and the new name 16 bytes into the fcb.
2721   E01C             ;
2722   E01C CD 5A DD    CHGNAMES: 	CALL	CHKWPRT		;check for a write protected disk.
2723   E01F 0E 0C       	LD	C,12			;match first 12 bytes of fcb only.
2724   E021 CD 1E DF    	CALL	FINDFST		;get first name.
2725   E024 2A 49 DB    	LD	HL,(PARAMS)	;get address of fcb.
2726   E027 7E          	LD	A,(HL)		;get user number.
2727   E028 11 10 00    	LD	DE,16			;move over to desired name.
2728   E02B 19          	ADD	HL,DE
2729   E02C 77          	LD	(HL),A		;keep same user number.
2730   E02D CD FB DD    CHGNAM1:	CALL	CKFILPOS		;any matching file found?
2731   E030 C8          	RET	Z			;no, we must be done.
2732   E031 CD 4A DD    	CALL	CHKROFL		;check for read only file.
2733   E034 0E 10       	LD	C,16			;start 16 bytes into fcb.
2734   E036 1E 0C       	LD	E,12			;and update the first 12 bytes of directory.
2735   E038 CD 07 E0    	CALL	UPDATE
2736   E03B CD 33 DF    	CALL	FINDNXT		;get te next file name.
2737   E03E C3 2D E0    	JP	CHGNAM1		;and continue.
2738   E041             ;
2739   E041             ;   Update a files attributes. The procedure is to search for
2740   E041             ; every file with the same name as shown in fcb (ignoring bit 7)
2741   E041             ; and then to update it (which includes bit 7). No other changes
2742   E041             ; are made.
2743   E041             ;
2744   E041 0E 0C       SAVEATTR: 	LD	C,12			;match first 12 bytes.
2745   E043 CD 1E DF    		CALL	FINDFST		;look for first filename.
2746   E046 CD FB DD    SAVATR1:	CALL	CKFILPOS		;was one found?
2747   E049 C8          	RET	Z			;nope, we must be done.
2748   E04A 0E 00       	LD	C,0			;yes, update the first 12 bytes now.
2749   E04C 1E 0C       	LD	E,12
2750   E04E CD 07 E0    	CALL	UPDATE		;update filename and write directory.
2751   E051 CD 33 DF    	CALL	FINDNXT		;and get the next file.
2752   E054 C3 46 E0    	JP	SAVATR1		;then continue until done.
2753   E057             ;
2754   E057             ;  Open a file (name specified in fcb).
2755   E057             ;
2756   E057 0E 0F       OPENIT:	LD	C,15			;compare the first 15 bytes.
2757   E059 CD 1E DF    	CALL	FINDFST		;get the first one in directory.
2758   E05C CD FB DD    	CALL	CKFILPOS		;any at all?
2759   E05F C8          	RET	Z
2760   E060 CD AC DC    OPENIT1:	CALL	SETEXT		;point to extent byte within users fcb.
2761   E063 7E          	LD	A,(HL)		;and get it.
2762   E064 F5          	PUSH	AF			;save it and address.
2763   E065 E5          	PUSH	HL
2764   E066 CD 64 DD    	CALL	FCB2HL		;point to fcb in directory.
2765   E069 EB          	EX	DE,HL
2766   E06A 2A 49 DB    	LD	HL,(PARAMS)	;this is the users copy.
2767   E06D 0E 20       	LD	C,32			;move it into users space.
2768   E06F D5          	PUSH	DE
2769   E070 CD 55 DB    	CALL	DE2HL
2770   E073 CD 7E DD    	CALL	SETS2B7		;set bit 7 in 's2' byte (unmodified).
2771   E076 D1          	POP	DE			;now get the extent byte from this fcb.
2772   E077 21 0C 00    	LD	HL,12
2773   E07A 19          	ADD	HL,DE
2774   E07B 4E          	LD	C,(HL)		;into (C).
2775   E07C 21 0F 00    	LD	HL,15			;now get the record count byte into (B).
2776   E07F 19          	ADD	HL,DE
2777   E080 46          	LD	B,(HL)
2778   E081 E1          	POP	HL			;keep the same extent as the user had originally.
2779   E082 F1          	POP	AF
2780   E083 77          	LD	(HL),A
2781   E084 79          	LD	A,C			;is it the same as in the directory fcb?
2782   E085 BE          	CP	(HL)	
2783   E086 78          	LD	A,B			;if yes, then use the same record count.
2784   E087 CA 91 E0    	JP	Z,OPENIT2
2785   E08A 3E 00       	LD	A,0			;if the user specified an extent greater than
2786   E08C DA 91 E0    	JP	C,OPENIT2		;the one in the directory, then set record count to 0.
2787   E08F 3E 80       	LD	A,128			;otherwise set to maximum.
2788   E091 2A 49 DB    OPENIT2:	LD	HL,(PARAMS)	;set record count in users fcb to (A).
2789   E094 11 0F 00    	LD	DE,15
2790   E097 19          	ADD	HL,DE			;compute relative position.
2791   E098 77          	LD	(HL),A		;and set the record count.
2792   E099 C9          	RET	
2793   E09A             ;
2794   E09A             ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
2795   E09A             ; point to a zero value (16 bit).
2796   E09A             ;   Return with zero flag set it (DE) was moved. Registers (DE)
2797   E09A             ; and (HL) are not changed. However (A) is.
2798   E09A             ;
2799   E09A 7E          MOVEWORD: 	LD	A,(HL)		;check for a zero word.
2800   E09B 23          	INC	HL
2801   E09C B6          	OR	(HL)			;both bytes zero?
2802   E09D 2B          	DEC	HL
2803   E09E C0          	RET	NZ			;nope, just return.
2804   E09F 1A          	LD	A,(DE)		;yes, move two bytes from (DE) into
2805   E0A0 77          	LD	(HL),A		;this zero space.
2806   E0A1 13          	INC	DE
2807   E0A2 23          	INC	HL
2808   E0A3 1A          	LD	A,(DE)
2809   E0A4 77          	LD	(HL),A
2810   E0A5 1B          	DEC	DE			;don't disturb these registers.
2811   E0A6 2B          	DEC	HL
2812   E0A7 C9          	RET	
2813   E0A8             ;
2814   E0A8             ;   Get here to close a file specified by (fcb).
2815   E0A8             ;
2816   E0A8 AF          CLOSEIT:	XOR	A			;clear status and file position bytes.
2817   E0A9 32 4B DB    	LD	(STATUS),A
2818   E0AC 32 F0 E5    	LD	(FILEPOS),A
2819   E0AF 32 F1 E5    	LD	(FILEPOS+1),A
2820   E0B2 CD 24 DD    	CALL	GETWPRT		;get write protect bit for this drive.
2821   E0B5 C0          	RET	NZ			;just return if it is set.
2822   E0B6 CD 6F DD    	CALL	GETS2			;else get the 's2' byte.
2823   E0B9 E6 80       	AND	80H			;and look at bit 7 (file unmodified?).
2824   E0BB C0          	RET	NZ			;just return if set.
2825   E0BC 0E 0F       	LD	C,15			;else look up this file in directory.
2826   E0BE CD 1E DF    	CALL	FINDFST
2827   E0C1 CD FB DD    	CALL	CKFILPOS		;was it found?
2828   E0C4 C8          	RET	Z			;just return if not.
2829   E0C5 01 10 00    	LD	BC,16			;set (HL) pointing to records used section.
2830   E0C8 CD 64 DD    	CALL	FCB2HL
2831   E0CB 09          	ADD	HL,BC
2832   E0CC EB          	EX	DE,HL
2833   E0CD 2A 49 DB    	LD	HL,(PARAMS)	;do the same for users specified fcb.
2834   E0D0 09          	ADD	HL,BC
2835   E0D1 0E 10       	LD	C,16			;this many bytes are present in this extent.
2836   E0D3 3A E3 E5    CLOSEIT1: 	LD	A,(BIGDISK)	;8 or 16 bit record numbers?
2837   E0D6 B7          	OR	A
2838   E0D7 CA EE E0    	JP	Z,CLOSEIT4
2839   E0DA 7E          	LD	A,(HL)		;just 8 bit. Get one from users fcb.
2840   E0DB B7          	OR	A
2841   E0DC 1A          	LD	A,(DE)		;now get one from directory fcb.
2842   E0DD C2 E1 E0    	JP	NZ,CLOSEIT2
2843   E0E0 77          	LD	(HL),A		;users byte was zero. Update from directory.
2844   E0E1 B7          CLOSEIT2: 	OR	A
2845   E0E2 C2 E7 E0    	JP	NZ,CLOSEIT3
2846   E0E5 7E          	LD	A,(HL)		;directories byte was zero, update from users fcb.
2847   E0E6 12          	LD	(DE),A
2848   E0E7 BE          CLOSEIT3: 	CP	(HL)			;if neither one of these bytes were zero,
2849   E0E8 C2 25 E1    	JP	NZ,CLOSEIT7	;then close error if they are not the same.
2850   E0EB C3 03 E1    	JP	CLOSEIT5		;ok so far, get to next byte in fcbs.
2851   E0EE CD 9A E0    CLOSEIT4: 	CALL	MOVEWORD		;update users fcb if it is zero.
2852   E0F1 EB          	EX	DE,HL
2853   E0F2 CD 9A E0    	CALL	MOVEWORD		;update directories fcb if it is zero.
2854   E0F5 EB          	EX	DE,HL
2855   E0F6 1A          	LD	A,(DE)		;if these two values are no different,
2856   E0F7 BE          	CP	(HL)			;then a close error occured.
2857   E0F8 C2 25 E1    	JP	NZ,CLOSEIT7
2858   E0FB 13          	INC	DE			;check second byte.
2859   E0FC 23          	INC	HL
2860   E0FD 1A          	LD	A,(DE)
2861   E0FE BE          	CP	(HL)
2862   E0FF C2 25 E1    	JP	NZ,CLOSEIT7
2863   E102 0D          	DEC	C			;remember 16 bit values.
2864   E103 13          CLOSEIT5: 	INC	DE			;bump to next item in table.
2865   E104 23          	INC	HL
2866   E105 0D          	DEC	C			;there are 16 entries only.
2867   E106 C2 D3 E0    	JP	NZ,CLOSEIT1	;continue if more to do.
2868   E109 01 EC FF    	LD	BC,0FFECH		;backup 20 places (extent byte).
2869   E10C 09          	ADD	HL,BC
2870   E10D EB          	EX	DE,HL
2871   E10E 09          	ADD	HL,BC
2872   E10F 1A          	LD	A,(DE)
2873   E110 BE          	CP	(HL)			;directory's extent already greater than the
2874   E111 DA 1D E1    	JP	C,CLOSEIT6		;users extent?
2875   E114 77          	LD	(HL),A		;no, update directory extent.
2876   E115 01 03 00    	LD	BC,3			;and update the record count byte in
2877   E118 09          	ADD	HL,BC			;directories fcb.
2878   E119 EB          	EX	DE,HL
2879   E11A 09          	ADD	HL,BC
2880   E11B 7E          	LD	A,(HL)		;get from user.
2881   E11C 12          	LD	(DE),A		;and put in directory.
2882   E11D 3E FF       CLOSEIT6: 	LD	A,0FFH		;set 'was open and is now closed' byte.
2883   E11F 32 D8 E5    	LD	(CLOSEFLG),A
2884   E122 C3 16 E0    	JP	UPDATE1		;update the directory now.
2885   E125 21 4B DB    CLOSEIT7: 	LD	HL,STATUS		;set return status and then return.
2886   E128 35          	DEC	(HL)
2887   E129 C9          	RET	
2888   E12A             ;
2889   E12A             ;   Routine to get the next empty space in the directory. It
2890   E12A             ; will then be cleared for use.
2891   E12A             ;
2892   E12A CD 5A DD    GETEMPTY: 	CALL	CHKWPRT		;make sure disk is not write protected.
2893   E12D 2A 49 DB    	LD	HL,(PARAMS)	;save current parameters (fcb).
2894   E130 E5          	PUSH	HL
2895   E131 21 B2 E5    	LD	HL,EMPTYFCB	;use special one for empty space.
2896   E134 22 49 DB    	LD	(PARAMS),HL
2897   E137 0E 01       	LD	C,1			;search for first empty spot in directory.
2898   E139 CD 1E DF    	CALL	FINDFST		;(* only check first byte *)
2899   E13C CD FB DD    	CALL	CKFILPOS		;none?
2900   E13F E1          	POP	HL
2901   E140 22 49 DB    	LD	(PARAMS),HL	;restore original fcb address.
2902   E143 C8          	RET	Z			;return if no more space.
2903   E144 EB          	EX	DE,HL
2904   E145 21 0F 00    	LD	HL,15			;point to number of records for this file.
2905   E148 19          	ADD	HL,DE
2906   E149 0E 11       	LD	C,17			;and clear all of this space.
2907   E14B AF          	XOR	A
2908   E14C 77          GETMT1:	LD	(HL),A
2909   E14D 23          	INC	HL
2910   E14E 0D          	DEC	C
2911   E14F C2 4C E1    	JP	NZ,GETMT1
2912   E152 21 0D 00    	LD	HL,13			;clear the 's1' byte also.
2913   E155 19          	ADD	HL,DE
2914   E156 77          	LD	(HL),A
2915   E157 CD 92 DD    	CALL	CHKNMBR		;keep (SCRATCH1) within bounds.
2916   E15A CD 03 E0    	CALL	FCBSET		;write out this fcb entry to directory.
2917   E15D C3 7E DD    	JP	SETS2B7		;set 's2' byte bit 7 (unmodified at present).
2918   E160             ;
2919   E160             ;   Routine to close the current extent and open the next one
2920   E160             ; for reading.
2921   E160             ;
2922   E160 AF          GETNEXT:	XOR	A
2923   E161 32 D8 E5    	LD	(CLOSEFLG),A	;clear close flag.
2924   E164 CD A8 E0    	CALL	CLOSEIT		;close this extent.
2925   E167 CD FB DD    	CALL	CKFILPOS
2926   E16A C8          	RET	Z			;not there???
2927   E16B 2A 49 DB    	LD	HL,(PARAMS)	;get extent byte.
2928   E16E 01 0C 00    	LD	BC,12
2929   E171 09          	ADD	HL,BC
2930   E172 7E          	LD	A,(HL)		;and increment it.
2931   E173 3C          	INC	A
2932   E174 E6 1F       	AND	1FH			;keep within range 0-31.
2933   E176 77          	LD	(HL),A
2934   E177 CA 89 E1    	JP	Z,GTNEXT1		;overflow?
2935   E17A 47          	LD	B,A			;mask extent byte.
2936   E17B 3A CB E5    	LD	A,(EXTMASK)
2937   E17E A0          	AND	B
2938   E17F 21 D8 E5    	LD	HL,CLOSEFLG	;check close flag (0ffh is ok).
2939   E182 A6          	AND	(HL)
2940   E183 CA 94 E1    	JP	Z,GTNEXT2		;if zero, we must read in next extent.
2941   E186 C3 B2 E1    	JP	GTNEXT3		;else, it is already in memory.
2942   E189 01 02 00    GTNEXT1:	LD	BC,2			;Point to the 's2' byte.
2943   E18C 09          	ADD	HL,BC
2944   E18D 34          	INC	(HL)			;and bump it.
2945   E18E 7E          	LD	A,(HL)		;too many extents?
2946   E18F E6 0F       	AND	0FH
2947   E191 CA BC E1    	JP	Z,GTNEXT5		;yes, set error code.
2948   E194             ;
2949   E194             ;   Get here to open the next extent.
2950   E194             ;
2951   E194 0E 0F       GTNEXT2:	LD	C,15			;set to check first 15 bytes of fcb.
2952   E196 CD 1E DF    	CALL	FINDFST		;find the first one.
2953   E199 CD FB DD    	CALL	CKFILPOS		;none available?
2954   E19C C2 B2 E1    	JP	NZ,GTNEXT3
2955   E19F 3A D9 E5    	LD	A,(RDWRTFLG)	;no extent present. Can we open an empty one?
2956   E1A2 3C          	INC	A			;0ffh means reading (so not possible).
2957   E1A3 CA BC E1    	JP	Z,GTNEXT5		;or an error.
2958   E1A6 CD 2A E1    	CALL	GETEMPTY		;we are writing, get an empty entry.
2959   E1A9 CD FB DD    	CALL	CKFILPOS		;none?
2960   E1AC CA BC E1    	JP	Z,GTNEXT5		;error if true.
2961   E1AF C3 B5 E1    	JP	GTNEXT4		;else we are almost done.
2962   E1B2 CD 60 E0    GTNEXT3:	CALL	OPENIT1		;open this extent.
2963   E1B5 CD C1 DC    GTNEXT4:	CALL	STRDATA		;move in updated data (rec #, extent #, etc.)
2964   E1B8 AF          	XOR	A			;clear status and return.
2965   E1B9 C3 07 DB    	JP	SETSTAT
2966   E1BC             ;
2967   E1BC             ;   Error in extending the file. Too many extents were needed
2968   E1BC             ; or not enough space on the disk.
2969   E1BC             ;
2970   E1BC CD 0B DB    GTNEXT5:	CALL	IOERR1		;set error code, clear bit 7 of 's2'
2971   E1BF C3 7E DD    		JP	SETS2B7		;so this is not written on a close.
2972   E1C2             ;
2973   E1C2             ;   Read a sequential file.
2974   E1C2             ;
2975   E1C2 3E 01       RDSEQ:	LD	A,1			;set sequential access mode.
2976   E1C4 32 DB E5    		LD	(MODE),A
2977   E1C7 3E FF       RDSEQ1:	LD	A,0FFH		;don't allow reading unwritten space.
2978   E1C9 32 D9 E5    	LD	(RDWRTFLG),A
2979   E1CC CD C1 DC    	CALL	STRDATA		;put rec# and ext# into fcb.
2980   E1CF 3A E9 E5    	LD	A,(SAVNREC)	;get next record to read.
2981   E1D2 21 E7 E5    	LD	HL,SAVNXT		;get number of records in extent.
2982   E1D5 BE          	CP	(HL)			;within this extent?
2983   E1D6 DA EC E1    	JP	C,RDSEQ2
2984   E1D9 FE 80       	CP	128			;no. Is this extent fully used?
2985   E1DB C2 01 E2    	JP	NZ,RDSEQ3		;no. End-of-file.
2986   E1DE CD 60 E1    	CALL	GETNEXT		;yes, open the next one.
2987   E1E1 AF          	XOR	A			;reset next record to read.
2988   E1E2 32 E9 E5    	LD	(SAVNREC),A
2989   E1E5 3A 4B DB    	LD	A,(STATUS)		;check on open, successful?
2990   E1E8 B7          	OR	A
2991   E1E9 C2 01 E2    	JP	NZ,RDSEQ3		;no, error.
2992   E1EC CD 7D DC    RDSEQ2:	CALL	COMBLK		;ok. compute block number to read.
2993   E1EF CD 8A DC    	CALL	CHKBLK		;check it. Within bounds?
2994   E1F2 CA 01 E2    	JP	Z,RDSEQ3		;no, error.
2995   E1F5 CD 90 DC    	CALL	LOGICAL		;convert (BLKNMBR) to logical sector (128 byte).
2996   E1F8 CD D7 DB    	CALL	TRKSEC1		;set the track and sector for this block #.
2997   E1FB CD B8 DB    	CALL	DOREAD		;and read it.
2998   E1FE C3 D8 DC    	JP	SETNREC		;and set the next record to be accessed.
2999   E201             ;
3000   E201             ;   Read error occured. Set status and return.
3001   E201             ;
3002   E201 C3 0B DB    RDSEQ3:	JP	IOERR1
3003   E204             ;
3004   E204             ;   Write the next sequential record.
3005   E204             ;
3006   E204 3E 01       WTSEQ:	LD	A,1			;set sequential access mode.
3007   E206 32 DB E5    		LD	(MODE),A
3008   E209 3E 00       WTSEQ1:	LD	A,0			;allow an addition empty extent to be opened.
3009   E20B 32 D9 E5    	LD	(RDWRTFLG),A
3010   E20E CD 5A DD    	CALL	CHKWPRT		;check write protect status.
3011   E211 2A 49 DB    	LD	HL,(PARAMS)	
3012   E214 CD 4D DD    	CALL	CKROF1		;check for read only file, (HL) already set to fcb.
3013   E217 CD C1 DC    	CALL	STRDATA		;put updated data into fcb.
3014   E21A 3A E9 E5    	LD	A,(SAVNREC)	;get record number to write.
3015   E21D FE 80       	CP	128			;within range?
3016   E21F D2 0B DB    	JP	NC,IOERR1		;no, error(?).
3017   E222 CD 7D DC    	CALL	COMBLK		;compute block number.
3018   E225 CD 8A DC    	CALL	CHKBLK		;check number.
3019   E228 0E 00       	LD	C,0			;is there one to write to?
3020   E22A C2 74 E2    	JP	NZ,WTSEQ6		;yes, go do it.
3021   E22D CD 44 DC    	CALL	GETBLOCK		;get next block number within fcb to use.
3022   E230 32 DD E5    	LD	(RELBLOCK),A	;and save.
3023   E233 01 00 00    	LD	BC,0			;start looking for space from the start
3024   E236 B7          	OR	A			;if none allocated as yet.
3025   E237 CA 41 E2    	JP	Z,WTSEQ2
3026   E23A 4F          	LD	C,A			;extract previous block number from fcb
3027   E23B 0B          	DEC	BC			;so we can be closest to it.
3028   E23C CD 64 DC    	CALL	EXTBLK
3029   E23F 44          	LD	B,H
3030   E240 4D          	LD	C,L
3031   E241 CD C4 DF    WTSEQ2:	CALL	FNDSPACE		;find the next empty block nearest number (BC).
3032   E244 7D          	LD	A,L			;check for a zero number.
3033   E245 B4          	OR	H
3034   E246 C2 4E E2    	JP	NZ,WTSEQ3
3035   E249 3E 02       	LD	A,2			;no more space?
3036   E24B C3 07 DB    	JP	SETSTAT
3037   E24E 22 EB E5    WTSEQ3:	LD	(BLKNMBR),HL	;save block number to access.
3038   E251 EB          	EX	DE,HL			;put block number into (DE).
3039   E252 2A 49 DB    	LD	HL,(PARAMS)	;now we must update the fcb for this
3040   E255 01 10 00    	LD	BC,16			;newly allocated block.
3041   E258 09          	ADD	HL,BC
3042   E259 3A E3 E5    	LD	A,(BIGDISK)	;8 or 16 bit block numbers?
3043   E25C B7          	OR	A
3044   E25D 3A DD E5    	LD	A,(RELBLOCK)	;(* update this entry *)
3045   E260 CA 6A E2    	JP	Z,WTSEQ4		;zero means 16 bit ones.
3046   E263 CD 6A DD    	CALL	ADDA2HL		;(HL)=(HL)+(A)
3047   E266 73          	LD	(HL),E		;store new block number.
3048   E267 C3 72 E2    	JP	WTSEQ5
3049   E26A 4F          WTSEQ4:	LD	C,A			;compute spot in this 16 bit table.
3050   E26B 06 00       	LD	B,0
3051   E26D 09          	ADD	HL,BC
3052   E26E 09          	ADD	HL,BC
3053   E26F 73          	LD	(HL),E		;stuff block number (DE) there.
3054   E270 23          	INC	HL
3055   E271 72          	LD	(HL),D
3056   E272 0E 02       WTSEQ5:	LD	C,2			;set (C) to indicate writing to un-used disk space.
3057   E274 3A 4B DB    WTSEQ6:	LD	A,(STATUS)		;are we ok so far?
3058   E277 B7          	OR	A
3059   E278 C0          	RET	NZ
3060   E279 C5          	PUSH	BC			;yes, save write flag for bios (register C).
3061   E27A CD 90 DC    	CALL	LOGICAL		;convert (BLKNMBR) over to loical sectors.
3062   E27D 3A DB E5    	LD	A,(MODE)		;get access mode flag (1=sequential,
3063   E280 3D          	DEC	A			;0=random, 2=special?).
3064   E281 3D          	DEC	A
3065   E282 C2 C1 E2    	JP	NZ,WTSEQ9
3066   E285             ;
3067   E285             ;   Special random i/o from function #40. Maybe for M/PM, but the
3068   E285             ; current block, if it has not been written to, will be zeroed
3069   E285             ; out and then written (reason?).
3070   E285             ;
3071   E285 C1          	POP	BC
3072   E286 C5          	PUSH	BC
3073   E287 79          	LD	A,C			;get write status flag (2=writing unused space).
3074   E288 3D          	DEC	A
3075   E289 3D          	DEC	A
3076   E28A C2 C1 E2    	JP	NZ,WTSEQ9
3077   E28D E5          	PUSH	HL
3078   E28E 2A BF E5    	LD	HL,(DIRBUF)	;zero out the directory buffer.
3079   E291 57          	LD	D,A			;note that (A) is zero here.
3080   E292 77          WTSEQ7:	LD	(HL),A
3081   E293 23          	INC	HL
3082   E294 14          	INC	D			;do 128 bytes.
3083   E295 F2 92 E2    	JP	P,WTSEQ7
3084   E298 CD E6 DD    	CALL	DIRDMA		;tell the bios the dma address for directory access.
3085   E29B 2A ED E5    	LD	HL,(LOGSECT)	;get sector that starts current block.
3086   E29E 0E 02       	LD	C,2			;set 'writing to unused space' flag.
3087   E2A0 22 EB E5    WTSEQ8:	LD	(BLKNMBR),HL	;save sector to write.
3088   E2A3 C5          	PUSH	BC
3089   E2A4 CD D7 DB    	CALL	TRKSEC1		;determine its track and sector numbers.
3090   E2A7 C1          	POP	BC
3091   E2A8 CD BE DB    	CALL	DOWRITE		;now write out 128 bytes of zeros.
3092   E2AB 2A EB E5    	LD	HL,(BLKNMBR)	;get sector number.
3093   E2AE 0E 00       	LD	C,0			;set normal write flag.
3094   E2B0 3A CA E5    	LD	A,(BLKMASK)	;determine if we have written the entire
3095   E2B3 47          	LD	B,A			;physical block.
3096   E2B4 A5          	AND	L
3097   E2B5 B8          	CP	B
3098   E2B6 23          	INC	HL			;prepare for the next one.
3099   E2B7 C2 A0 E2    	JP	NZ,WTSEQ8		;continue until (BLKMASK+1) sectors written.
3100   E2BA E1          	POP	HL			;reset next sector number.
3101   E2BB 22 EB E5    	LD	(BLKNMBR),HL
3102   E2BE CD E0 DD    	CALL	DEFDMA		;and reset dma address.
3103   E2C1             ;
3104   E2C1             ;   Normal disk write. Set the desired track and sector then
3105   E2C1             ; do the actual write.
3106   E2C1             ;
3107   E2C1 CD D7 DB    WTSEQ9:	CALL	TRKSEC1		;determine track and sector for this write.
3108   E2C4 C1          	POP	BC			;get write status flag.
3109   E2C5 C5          	PUSH	BC
3110   E2C6 CD BE DB    	CALL	DOWRITE		;and write this out.
3111   E2C9 C1          	POP	BC
3112   E2CA 3A E9 E5    	LD	A,(SAVNREC)	;get number of records in file.
3113   E2CD 21 E7 E5    	LD	HL,SAVNXT		;get last record written.
3114   E2D0 BE          	CP	(HL)
3115   E2D1 DA D8 E2    	JP	C,WTSEQ10
3116   E2D4 77          	LD	(HL),A		;we have to update record count.
3117   E2D5 34          	INC	(HL)
3118   E2D6 0E 02       	LD	C,2
3119   E2D8             ;
3120   E2D8             ;*   This area has been patched to correct disk update problem
3121   E2D8             ;* when using blocking and de-blocking in the BIOS.
3122   E2D8             ;
3123   E2D8 00          WTSEQ10:	NOP				;was 'dcr c'
3124   E2D9 00          	NOP				;was 'dcr c'
3125   E2DA 21 00 00    	LD	HL,0			;was 'jnz wtseq99'
3126   E2DD             ;
3127   E2DD             ; *   End of patch.
3128   E2DD             ;
3129   E2DD F5          	PUSH	AF
3130   E2DE CD 6F DD    	CALL	GETS2			;set 'extent written to' flag.
3131   E2E1 E6 7F       	AND	7FH			;(* clear bit 7 *)
3132   E2E3 77          	LD	(HL),A
3133   E2E4 F1          	POP	AF			;get record count for this extent.
3134   E2E5 FE 7F       WTSEQ99:	CP	127			;is it full?
3135   E2E7 C2 06 E3    	JP	NZ,WTSEQ12
3136   E2EA 3A DB E5    	LD	A,(MODE)		;yes, are we in sequential mode?
3137   E2ED FE 01       	CP	1
3138   E2EF C2 06 E3    	JP	NZ,WTSEQ12
3139   E2F2 CD D8 DC    	CALL	SETNREC		;yes, set next record number.
3140   E2F5 CD 60 E1    	CALL	GETNEXT		;and get next empty space in directory.
3141   E2F8 21 4B DB    	LD	HL,STATUS		;ok?
3142   E2FB 7E          	LD	A,(HL)
3143   E2FC B7          	OR	A
3144   E2FD C2 04 E3    	JP	NZ,WTSEQ11
3145   E300 3D          	DEC	A			;yes, set record count to -1.
3146   E301 32 E9 E5    	LD	(SAVNREC),A
3147   E304 36 00       WTSEQ11:	LD	(HL),0		;clear status.
3148   E306 C3 D8 DC    WTSEQ12:	JP	SETNREC		;set next record to access.
3149   E309             ;
3150   E309             ;   For random i/o, set the fcb for the desired record number
3151   E309             ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
3152   E309             ; used as follows:
3153   E309             ;
3154   E309             ;       fcb+35            fcb+34            fcb+33
3155   E309             ;  |     'r-2'      |      'r-1'      |      'r-0'     |
3156   E309             ;  |7             0 | 7             0 | 7             0|
3157   E309             ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
3158   E309             ;  |    overflow   | | extra |  extent   |   record #  |
3159   E309             ;  | ______________| |_extent|__number___|_____________|
3160   E309             ;                     also 's2'
3161   E309             ;
3162   E309             ;   On entry, register (C) contains 0ffh if this is a read
3163   E309             ; and thus we can not access unwritten disk space. Otherwise,
3164   E309             ; another extent will be opened (for writing) if required.
3165   E309             ;
3166   E309 AF          POSITION: 	XOR	A			;set random i/o flag.
3167   E30A 32 DB E5    		LD	(MODE),A
3168   E30D             ;
3169   E30D             ;   Special entry (function #40). M/PM ?
3170   E30D             ;
3171   E30D C5          POSITN1:	PUSH	BC			;save read/write flag.
3172   E30E 2A 49 DB    	LD	HL,(PARAMS)	;get address of fcb.
3173   E311 EB          	EX	DE,HL
3174   E312 21 21 00    	LD	HL,33			;now get byte 'r0'.
3175   E315 19          	ADD	HL,DE
3176   E316 7E          	LD	A,(HL)
3177   E317 E6 7F       	AND	7FH			;keep bits 0-6 for the record number to access.
3178   E319 F5          	PUSH	AF
3179   E31A 7E          	LD	A,(HL)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
3180   E31B 17          	RLA	
3181   E31C 23          	INC	HL
3182   E31D 7E          	LD	A,(HL)
3183   E31E 17          	RLA	
3184   E31F E6 1F       	AND	1FH			;and save this in bits 0-4 of (C).
3185   E321 4F          	LD	C,A			;this is the extent byte.
3186   E322 7E          	LD	A,(HL)		;now get the extra extent byte.
3187   E323 1F          	RRA	
3188   E324 1F          	RRA	
3189   E325 1F          	RRA	
3190   E326 1F          	RRA	
3191   E327 E6 0F       	AND	0FH
3192   E329 47          	LD	B,A			;and save it in (B).
3193   E32A F1          	POP	AF			;get record number back to (A).
3194   E32B 23          	INC	HL			;check overflow byte 'r2'.
3195   E32C 6E          	LD	L,(HL)	
3196   E32D 2C          	INC	L
3197   E32E 2D          	DEC	L
3198   E32F 2E 06       	LD	L,6			;prepare for error.
3199   E331 C2 91 E3    	JP	NZ,POSITN5		;out of disk space error.
3200   E334 21 20 00    	LD	HL,32			;store record number into fcb.
3201   E337 19          	ADD	HL,DE
3202   E338 77          	LD	(HL),A
3203   E339 21 0C 00    	LD	HL,12			;and now check the extent byte.
3204   E33C 19          	ADD	HL,DE
3205   E33D 79          	LD	A,C
3206   E33E 96          	SUB	(HL)			;same extent as before?
3207   E33F C2 4D E3    	JP	NZ,POSITN2
3208   E342 21 0E 00    	LD	HL,14			;yes, check extra extent byte 's2' also.
3209   E345 19          	ADD	HL,DE
3210   E346 78          	LD	A,B
3211   E347 96          	SUB	(HL)
3212   E348 E6 7F       	AND	7FH
3213   E34A CA 85 E3    	JP	Z,POSITN3		;same, we are almost done then.
3214   E34D             ;
3215   E34D             ;  Get here when another extent is required.
3216   E34D             ;
3217   E34D C5          POSITN2:	PUSH	BC
3218   E34E D5          	PUSH	DE
3219   E34F CD A8 E0    	CALL	CLOSEIT		;close current extent.
3220   E352 D1          	POP	DE
3221   E353 C1          	POP	BC
3222   E354 2E 03       	LD	L,3			;prepare for error.
3223   E356 3A 4B DB    	LD	A,(STATUS)
3224   E359 3C          	INC	A
3225   E35A CA 8A E3    	JP	Z,POSITN4		;close error.
3226   E35D 21 0C 00    	LD	HL,12			;put desired extent into fcb now.
3227   E360 19          	ADD	HL,DE
3228   E361 71          	LD	(HL),C
3229   E362 21 0E 00    	LD	HL,14			;and store extra extent byte 's2'.
3230   E365 19          	ADD	HL,DE
3231   E366 70          	LD	(HL),B
3232   E367 CD 57 E0    	CALL	OPENIT		;try and get this extent.
3233   E36A 3A 4B DB    	LD	A,(STATUS)		;was it there?
3234   E36D 3C          	INC	A
3235   E36E C2 85 E3    	JP	NZ,POSITN3
3236   E371 C1          	POP	BC			;no. can we create a new one (writing?).
3237   E372 C5          	PUSH	BC
3238   E373 2E 04       	LD	L,4			;prepare for error.
3239   E375 0C          	INC	C
3240   E376 CA 8A E3    	JP	Z,POSITN4		;nope, reading unwritten space error.
3241   E379 CD 2A E1    	CALL	GETEMPTY		;yes we can, try to find space.
3242   E37C 2E 05       	LD	L,5			;prepare for error.
3243   E37E 3A 4B DB    	LD	A,(STATUS)
3244   E381 3C          	INC	A
3245   E382 CA 8A E3    	JP	Z,POSITN4		;out of space?
3246   E385             ;
3247   E385             ;   Normal return location. Clear error code and return.
3248   E385             ;
3249   E385 C1          POSITN3:	POP	BC			;restore stack.
3250   E386 AF          	XOR	A			;and clear error code byte.
3251   E387 C3 07 DB    	JP	SETSTAT
3252   E38A             ;
3253   E38A             ;   Error. Set the 's2' byte to indicate this (why?).
3254   E38A             ;
3255   E38A E5          POSITN4:	PUSH	HL
3256   E38B CD 6F DD    	CALL	GETS2
3257   E38E 36 C0       	LD	(HL),0C0H
3258   E390 E1          	POP	HL
3259   E391             ;
3260   E391             ;   Return with error code (presently in L).
3261   E391             ;
3262   E391 C1          POSITN5:	POP	BC
3263   E392 7D          	LD	A,L			;get error code.
3264   E393 32 4B DB    	LD	(STATUS),A	
3265   E396 C3 7E DD    	JP	SETS2B7
3266   E399             ;
3267   E399             ;   Read a random record.
3268   E399             ;
3269   E399 0E FF       READRAN:	LD	C,0FFH		;set 'read' status.
3270   E39B CD 09 E3    	CALL	POSITION		;position the file to proper record.
3271   E39E CC C7 E1    	CALL	Z,RDSEQ1		;and read it as usual (if no errors).
3272   E3A1 C9          	RET	
3273   E3A2             ;
3274   E3A2             ;   Write to a random record.
3275   E3A2             ;
3276   E3A2 0E 00       WRITERAN: 	LD	C,0			;set 'writing' flag.
3277   E3A4 CD 09 E3    	CALL	POSITION		;position the file to proper record.
3278   E3A7 CC 09 E2    	CALL	Z,WTSEQ1		;and write as usual (if no errors).
3279   E3AA C9          	RET	
3280   E3AB             ;
3281   E3AB             ;   Compute the random record number. Enter with (HL) pointing
3282   E3AB             ; to a fcb an (DE) contains a relative location of a record
3283   E3AB             ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
3284   E3AB             ; byte, and (A) the 'r2' byte.
3285   E3AB             ;
3286   E3AB             ;   On return, the zero flag is set if the record is within
3287   E3AB             ; bounds. Otherwise, an overflow occured.
3288   E3AB             ;
3289   E3AB EB          COMPRAND: 	EX	DE,HL			;save fcb pointer in (DE).
3290   E3AC 19          	ADD	HL,DE			;compute relative position of record #.
3291   E3AD 4E          	LD	C,(HL)		;get record number into (BC).
3292   E3AE 06 00       	LD	B,0
3293   E3B0 21 0C 00    	LD	HL,12			;now get extent.
3294   E3B3 19          	ADD	HL,DE
3295   E3B4 7E          	LD	A,(HL)		;compute (BC)=(record #)+(extent)*128.
3296   E3B5 0F          	RRCA				;move lower bit into bit 7.
3297   E3B6 E6 80       	AND	80H			;and ignore all other bits.
3298   E3B8 81          	ADD	A,C			;add to our record number.
3299   E3B9 4F          	LD	C,A
3300   E3BA 3E 00       	LD	A,0			;take care of any carry.
3301   E3BC 88          	ADC	A,B
3302   E3BD 47          	LD	B,A
3303   E3BE 7E          	LD	A,(HL)		;now get the upper bits of extent into
3304   E3BF 0F          	RRCA				;bit positions 0-3.
3305   E3C0 E6 0F       	AND	0FH			;and ignore all others.
3306   E3C2 80          	ADD	A,B			;add this in to 'r1' byte.
3307   E3C3 47          	LD	B,A
3308   E3C4 21 0E 00    	LD	HL,14			;get the 's2' byte (extra extent).
3309   E3C7 19          	ADD	HL,DE
3310   E3C8 7E          	LD	A,(HL)
3311   E3C9 87          	ADD	A,A			;and shift it left 4 bits (bits 4-7).
3312   E3CA 87          	ADD	A,A
3313   E3CB 87          	ADD	A,A
3314   E3CC 87          	ADD	A,A	
3315   E3CD F5          	PUSH	AF			;save carry flag (bit 0 of flag byte).
3316   E3CE 80          	ADD	A,B			;now add extra extent into 'r1'.
3317   E3CF 47          	LD	B,A
3318   E3D0 F5          	PUSH	AF			;and save carry (overflow byte 'r2').
3319   E3D1 E1          	POP	HL			;bit 0 of (L) is the overflow indicator.
3320   E3D2 7D          	LD	A,L
3321   E3D3 E1          	POP	HL			;and same for first carry flag.
3322   E3D4 B5          	OR	L			;either one of these set?
3323   E3D5 E6 01       	AND	01H			;only check the carry flags.
3324   E3D7 C9          	RET	
3325   E3D8             ;
3326   E3D8             ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
3327   E3D8             ; reflect the last record used for a random (or other) file.
3328   E3D8             ; This reads the directory and looks at all extents computing
3329   E3D8             ; the largerst record number for each and keeping the maximum
3330   E3D8             ; value only. Then 'r0', 'r1', and 'r2' will reflect this
3331   E3D8             ; maximum record number. This is used to compute the space used
3332   E3D8             ; by a random file.
3333   E3D8             ;
3334   E3D8 0E 0C       RANSIZE:	LD	C,12			;look thru directory for first entry with
3335   E3DA CD 1E DF    	CALL	FINDFST		;this name.
3336   E3DD 2A 49 DB    	LD	HL,(PARAMS)	;zero out the 'r0, r1, r2' bytes.
3337   E3E0 11 21 00    	LD	DE,33
3338   E3E3 19          	ADD	HL,DE
3339   E3E4 E5          	PUSH	HL
3340   E3E5 72          	LD	(HL),D		;note that (D)=0.
3341   E3E6 23          	INC	HL
3342   E3E7 72          	LD	(HL),D
3343   E3E8 23          	INC	HL
3344   E3E9 72          	LD	(HL),D
3345   E3EA CD FB DD    RANSIZ1:	CALL	CKFILPOS		;is there an extent to process?
3346   E3ED CA 12 E4    	JP	Z,RANSIZ3		;no, we are done.
3347   E3F0 CD 64 DD    	CALL	FCB2HL		;set (HL) pointing to proper fcb in dir.
3348   E3F3 11 0F 00    	LD	DE,15			;point to last record in extent.
3349   E3F6 CD AB E3    	CALL	COMPRAND		;and compute random parameters.
3350   E3F9 E1          	POP	HL
3351   E3FA E5          	PUSH	HL			;now check these values against those
3352   E3FB 5F          	LD	E,A			;already in fcb.
3353   E3FC 79          	LD	A,C			;the carry flag will be set if those
3354   E3FD 96          	SUB	(HL)			;in the fcb represent a larger size than
3355   E3FE 23          	INC	HL			;this extent does.
3356   E3FF 78          	LD	A,B
3357   E400 9E          	SBC	A,(HL)
3358   E401 23          	INC	HL
3359   E402 7B          	LD	A,E
3360   E403 9E          	SBC	A,(HL)
3361   E404 DA 0C E4    	JP	C,RANSIZ2
3362   E407 73          	LD	(HL),E		;we found a larger (in size) extent.
3363   E408 2B          	DEC	HL			;stuff these values into fcb.
3364   E409 70          	LD	(HL),B
3365   E40A 2B          	DEC	HL
3366   E40B 71          	LD	(HL),C
3367   E40C CD 33 DF    RANSIZ2:	CALL	FINDNXT		;now get the next extent.
3368   E40F C3 EA E3    		JP	RANSIZ1		;continue til all done.
3369   E412 E1          RANSIZ3:	POP	HL			;we are done, restore the stack and
3370   E413 C9          		RET				;return.
3371   E414             ;
3372   E414             ;   Function to return the random record position of a given
3373   E414             ; file which has been read in sequential mode up to now.
3374   E414             ;
3375   E414 2A 49 DB    SETRAN:	LD	HL,(PARAMS)	;point to fcb.
3376   E417 11 20 00    	LD	DE,32			;and to last used record.
3377   E41A CD AB E3    	CALL	COMPRAND		;compute random position.
3378   E41D 21 21 00    	LD	HL,33			;now stuff these values into fcb.
3379   E420 19          	ADD	HL,DE
3380   E421 71          	LD	(HL),C		;move 'r0'.
3381   E422 23          	INC	HL
3382   E423 70          	LD	(HL),B		;and 'r1'.
3383   E424 23          	INC	HL
3384   E425 77          	LD	(HL),A		;and lastly 'r2'.
3385   E426 C9          	RET	
3386   E427             ;
3387   E427             ;   This routine select the drive specified in (ACTIVE) and
3388   E427             ; update the login vector and bitmap table if this drive was
3389   E427             ; not already active.
3390   E427             ;
3391   E427 2A B5 E5    LOGINDRV: 	LD	HL,(LOGIN)		;get the login vector.
3392   E42A 3A 48 DB    	LD	A,(ACTIVE)		;get the default drive.
3393   E42D 4F          	LD	C,A
3394   E42E CD F0 DC    	CALL	SHIFTR		;position active bit for this drive
3395   E431 E5          	PUSH	HL			;into bit 0.
3396   E432 EB          	EX	DE,HL
3397   E433 CD 5F DB    	CALL	SELECT		;select this drive.
3398   E436 E1          	POP	HL
3399   E437 CC 4D DB    	CALL	Z,SLCTERR		;valid drive?
3400   E43A 7D          	LD	A,L			;is this a newly activated drive?
3401   E43B 1F          	RRA	
3402   E43C D8          	RET	C
3403   E43D 2A B5 E5    	LD	HL,(LOGIN)		;yes, update the login vector.
3404   E440 4D          	LD	C,L
3405   E441 44          	LD	B,H
3406   E442 CD 11 DD    	CALL	SETBIT
3407   E445 22 B5 E5    	LD	(LOGIN),HL		;and save.
3408   E448 C3 A9 DE    	JP	BITMAP		;now update the bitmap.
3409   E44B             ;
3410   E44B             ;   Function to set the active disk number.
3411   E44B             ;
3412   E44B 3A DC E5    SETDSK:	LD	A,(EPARAM)		;get parameter passed and see if this
3413   E44E 21 48 DB    	LD	HL,ACTIVE		;represents a change in drives.
3414   E451 BE          	CP	(HL)
3415   E452 C8          	RET	Z
3416   E453 77          	LD	(HL),A		;yes it does, log it in.
3417   E454 C3 27 E4    	JP	LOGINDRV
3418   E457             ;
3419   E457             ;   This is the 'auto disk select' routine. The firsst byte
3420   E457             ; of the fcb is examined for a drive specification. If non
3421   E457             ; zero then the drive will be selected and loged in.
3422   E457             ;
3423   E457 3E FF       AUTOSEL:	LD	A,0FFH		;say 'auto-select activated'.
3424   E459 32 E4 E5    	LD	(AUTO),A
3425   E45C 2A 49 DB    	LD	HL,(PARAMS)	;get drive specified.
3426   E45F 7E          	LD	A,(HL)
3427   E460 E6 1F       	AND	1FH			;look at lower 5 bits.
3428   E462 3D          	DEC	A			;adjust for (1=A, 2=B) etc.
3429   E463 32 DC E5    	LD	(EPARAM),A		;and save for the select routine.
3430   E466 FE 1E       	CP	1EH			;check for 'no change' condition.
3431   E468 D2 7B E4    	JP	NC,AUTOSL1		;yes, don't change.
3432   E46B 3A 48 DB    	LD	A,(ACTIVE)		;we must change, save currently active
3433   E46E 32 E5 E5    	LD	(OLDDRV),A		;drive.
3434   E471 7E          	LD	A,(HL)		;and save first byte of fcb also.
3435   E472 32 E6 E5    	LD	(AUTOFLAG),A	;this must be non-zero.
3436   E475 E6 E0       	AND	0E0H			;whats this for (bits 6,7 are used for
3437   E477 77          	LD	(HL),A		;something)?
3438   E478 CD 4B E4    	CALL	SETDSK		;select and log in this drive.
3439   E47B 3A 47 DB    AUTOSL1:	LD	A,(USERNO)		;move user number into fcb.
3440   E47E 2A 49 DB    	LD	HL,(PARAMS)	;(* upper half of first byte *)
3441   E481 B6          	OR	(HL)
3442   E482 77          	LD	(HL),A
3443   E483 C9          	RET				;and return (all done).
3444   E484             ;
3445   E484             ;   Function to return the current cp/m version number.
3446   E484             ;
3447   E484 3E 22       GETVER:	LD	A,022H		;version 2.2
3448   E486 C3 07 DB    		JP	SETSTAT
3449   E489             ;
3450   E489             ;   Function to reset the disk system.
3451   E489             ;
3452   E489 21 00 00    RSTDSK:	LD	HL,0			;clear write protect status and log
3453   E48C 22 B3 E5    	LD	(WRTPRT),HL	;in vector.
3454   E48F 22 B5 E5    	LD	(LOGIN),HL
3455   E492 AF          	XOR	A			;select drive 'A'.
3456   E493 32 48 DB    	LD	(ACTIVE),A
3457   E496 21 80 00    	LD	HL,TBUFF		;setup default dma address.
3458   E499 22 B7 E5    	LD	(USERDMA),HL
3459   E49C CD E0 DD    	CALL	DEFDMA
3460   E49F C3 27 E4    	JP	LOGINDRV		;now log in drive 'A'.
3461   E4A2             ;
3462   E4A2             ;   Function to open a specified file.
3463   E4A2             ;
3464   E4A2 CD 78 DD    OPENFIL:	CALL	CLEARS2		;clear 's2' byte.
3465   E4A5 CD 57 E4    	CALL	AUTOSEL		;select proper disk.
3466   E4A8 C3 57 E0    	JP	OPENIT		;and open the file.
3467   E4AB             ;
3468   E4AB             ;   Function to close a specified file.
3469   E4AB             ;
3470   E4AB CD 57 E4    CLOSEFIL: 	CALL	AUTOSEL		;select proper disk.
3471   E4AE C3 A8 E0    		JP	CLOSEIT		;and close the file.
3472   E4B1             ;
3473   E4B1             ;   Function to return the first occurence of a specified file
3474   E4B1             ; name. If the first byte of the fcb is '?' then the name will
3475   E4B1             ; not be checked (get the first entry no matter what).
3476   E4B1             ;
3477   E4B1 0E 00       GETFST:	LD	C,0			;prepare for special search.
3478   E4B3 EB          	EX	DE,HL
3479   E4B4 7E          	LD	A,(HL)		;is first byte a '?'?
3480   E4B5 FE 3F       	CP	'?'
3481   E4B7 CA C8 E4    	JP	Z,GETFST1		;yes, just get very first entry (zero length match).
3482   E4BA CD AC DC    	CALL	SETEXT		;get the extension byte from fcb.
3483   E4BD 7E          	LD	A,(HL)		;is it '?'? if yes, then we want
3484   E4BE FE 3F       	CP	'?'			;an entry with a specific 's2' byte.
3485   E4C0 C4 78 DD    	CALL	NZ,CLEARS2		;otherwise, look for a zero 's2' byte.
3486   E4C3 CD 57 E4    	CALL	AUTOSEL		;select proper drive.
3487   E4C6 0E 0F       	LD	C,15			;compare bytes 0-14 in fcb (12&13 excluded).
3488   E4C8 CD 1E DF    GETFST1:	CALL	FINDFST		;find an entry and then move it into
3489   E4CB C3 EF DD    		JP	MOVEDIR		;the users dma space.
3490   E4CE             ;
3491   E4CE             ;   Function to return the next occurence of a file name.
3492   E4CE             ;
3493   E4CE 2A DF E5    GETNXT:	LD	HL,(SAVEFCB)	;restore pointers. note that no
3494   E4D1 22 49 DB    	LD	(PARAMS),HL	;other dbos calls are allowed.
3495   E4D4 CD 57 E4    	CALL	AUTOSEL		;no error will be returned, but the
3496   E4D7 CD 33 DF    	CALL	FINDNXT		;results will be wrong.
3497   E4DA C3 EF DD    	JP	MOVEDIR
3498   E4DD             ;
3499   E4DD             ;   Function to delete a file by name.
3500   E4DD             ;
3501   E4DD CD 57 E4    DELFILE:	CALL	AUTOSEL		;select proper drive.
3502   E4E0 CD A2 DF    	CALL	ERAFILE		;erase the file.
3503   E4E3 C3 07 DF    	JP	STSTATUS		;set status and return.
3504   E4E6             ;
3505   E4E6             ;   Function to execute a sequential read of the specified
3506   E4E6             ; record number.
3507   E4E6             ;
3508   E4E6 CD 57 E4    READSEQ:CALL	AUTOSEL		;select proper drive then read.
3509   E4E9 C3 C2 E1    		JP	RDSEQ
3510   E4EC             ;
3511   E4EC             ;   Function to write the net sequential record.
3512   E4EC             ;
3513   E4EC CD 57 E4    WRTSEQ:	CALL	AUTOSEL		;select proper drive then write.
3514   E4EF C3 04 E2    		JP	WTSEQ
3515   E4F2             ;
3516   E4F2             ;   Create a file function.
3517   E4F2             ;
3518   E4F2 CD 78 DD    FCREATE:	CALL	CLEARS2		;clear the 's2' byte on all creates.
3519   E4F5 CD 57 E4    	CALL	AUTOSEL		;select proper drive and get the next
3520   E4F8 C3 2A E1    	JP	GETEMPTY		;empty directory space.
3521   E4FB             ;
3522   E4FB             ;   Function to rename a file.
3523   E4FB             
3524   E4FB CD 57 E4    RENFILE:	CALL	AUTOSEL		;select proper drive and then switch
3525   E4FE CD 1C E0    	CALL	CHGNAMES		;file names.
3526   E501 C3 07 DF    	JP	STSTATUS
3527   E504             ;
3528   E504             ;   Function to return the login vector.
3529   E504             ;
3530   E504 2A B5 E5    GETLOG:	LD	HL,(LOGIN)
3531   E507 C3 2F E5    		JP	GETPRM1
3532   E50A             ;
3533   E50A             ;   Function to return the current disk assignment.
3534   E50A             ;
3535   E50A 3A 48 DB    GETCRNT:	LD	A,(ACTIVE)
3536   E50D C3 07 DB    		JP	SETSTAT
3537   E510             ;
3538   E510             ;   Function to set the dma address.
3539   E510             ;
3540   E510 EB          PUTDMA:	EX	DE,HL
3541   E511 22 B7 E5    	LD	(USERDMA),HL	;save in our space and then get to
3542   E514 C3 E0 DD    	JP	DEFDMA		;the bios with this also.
3543   E517             ;
3544   E517             ;   Function to return the allocation vector.
3545   E517             ;
3546   E517 2A C5 E5    GETALOC:	LD	HL,(ALOCVECT)
3547   E51A C3 2F E5    		JP	GETPRM1
3548   E51D             ;
3549   E51D             ;   Function to return the read-only status vector.
3550   E51D             ;
3551   E51D 2A B3 E5    GETROV:	LD	HL,(WRTPRT)
3552   E520 C3 2F E5    		JP	GETPRM1
3553   E523             ;
3554   E523             ;   Function to set the file attributes (read-only, system).
3555   E523             ;
3556   E523 CD 57 E4    SETATTR:	CALL	AUTOSEL		;select proper drive then save attributes.
3557   E526 CD 41 E0    	CALL	SAVEATTR
3558   E529 C3 07 DF    	JP	STSTATUS
3559   E52C             ;
3560   E52C             ;   Function to return the address of the disk parameter block
3561   E52C             ; for the current drive.
3562   E52C             ;
3563   E52C 2A C1 E5    GETPARM:	LD	HL,(DISKPB)
3564   E52F 22 4B DB    GETPRM1:	LD	(STATUS),HL
3565   E532 C9          		RET	
3566   E533             ;
3567   E533             ;   Function to get or set the user number. If (E) was (FF)
3568   E533             ; then this is a request to return the current user number.
3569   E533             ; Else set the user number from (E).
3570   E533             ;
3571   E533 3A DC E5    GETUSER:	LD	A,(EPARAM)		;get parameter.
3572   E536 FE FF       	CP	0FFH			;get user number?
3573   E538 C2 41 E5    	JP	NZ,SETUSER
3574   E53B 3A 47 DB    	LD	A,(USERNO)		;yes, just do it.
3575   E53E C3 07 DB    	JP	SETSTAT
3576   E541 E6 1F       SETUSER:	AND	1FH			;no, we should set it instead. keep low
3577   E543 32 47 DB    	LD	(USERNO),A		;bits (0-4) only.
3578   E546 C9          	RET	
3579   E547             ;
3580   E547             ;   Function to read a random record from a file.
3581   E547             ;
3582   E547 CD 57 E4    RDRANDOM: 	CALL	AUTOSEL		;select proper drive and read.
3583   E54A C3 99 E3    		JP	READRAN
3584   E54D             ;
3585   E54D             ;   Function to compute the file size for random files.
3586   E54D             ;
3587   E54D CD 57 E4    WTRANDOM: 	CALL	AUTOSEL		;select proper drive and write.
3588   E550 C3 A2 E3    		JP	WRITERAN
3589   E553             ;
3590   E553             ;   Function to compute the size of a random file.
3591   E553             ;
3592   E553 CD 57 E4    FILESIZE: 	CALL	AUTOSEL		;select proper drive and check file length
3593   E556 C3 D8 E3    		JP	RANSIZE
3594   E559             ;
3595   E559             ;   Function #37. This allows a program to log off any drives.
3596   E559             ; On entry, set (DE) to contain a word with bits set for those
3597   E559             ; drives that are to be logged off. The log-in vector and the
3598   E559             ; write protect vector will be updated. This must be a M/PM
3599   E559             ; special function.
3600   E559             ;
3601   E559 2A 49 DB    LOGOFF:	LD	HL,(PARAMS)	;get drives to log off.
3602   E55C 7D          	LD	A,L			;for each bit that is set, we want
3603   E55D 2F          	CPL				;to clear that bit in (LOGIN)
3604   E55E 5F          	LD	E,A			;and (WRTPRT).
3605   E55F 7C          	LD	A,H
3606   E560 2F          	CPL	
3607   E561 2A B5 E5    	LD	HL,(LOGIN)		;reset the login vector.
3608   E564 A4          	AND	H
3609   E565 57          	LD	D,A
3610   E566 7D          	LD	A,L
3611   E567 A3          	AND	E
3612   E568 5F          	LD	E,A
3613   E569 2A B3 E5    	LD	HL,(WRTPRT)
3614   E56C EB          	EX	DE,HL
3615   E56D 22 B5 E5    	LD	(LOGIN),HL		;and save.
3616   E570 7D          	LD	A,L			;now do the write protect vector.
3617   E571 A3          	AND	E
3618   E572 6F          	LD	L,A
3619   E573 7C          	LD	A,H
3620   E574 A2          	AND	D
3621   E575 67          	LD	H,A
3622   E576 22 B3 E5    	LD	(WRTPRT),HL	;and save. all done.
3623   E579 C9          	RET	
3624   E57A             ;
3625   E57A             ;   Get here to return to the user.
3626   E57A             ;
3627   E57A 3A E4 E5    GOBACK:	LD	A,(AUTO)		;was auto select activated?
3628   E57D B7          	OR	A
3629   E57E CA 97 E5    	JP	Z,GOBACK1
3630   E581 2A 49 DB    	LD	HL,(PARAMS)	;yes, but was a change made?
3631   E584 36 00       	LD	(HL),0		;(* reset first byte of fcb *)
3632   E586 3A E6 E5    	LD	A,(AUTOFLAG)
3633   E589 B7          	OR	A
3634   E58A CA 97 E5    	JP	Z,GOBACK1
3635   E58D 77          	LD	(HL),A		;yes, reset first byte properly.
3636   E58E 3A E5 E5    	LD	A,(OLDDRV)		;and get the old drive and select it.
3637   E591 32 DC E5    	LD	(EPARAM),A
3638   E594 CD 4B E4    	CALL	SETDSK
3639   E597 2A 15 DB    GOBACK1:	LD	HL,(USRSTACK)	;reset the users stack pointer.
3640   E59A F9          	LD	SP,HL
3641   E59B 2A 4B DB    	LD	HL,(STATUS)	;get return status.
3642   E59E 7D          	LD	A,L			;force version 1.4 compatability.
3643   E59F 44          	LD	B,H
3644   E5A0 C9          	RET				;and go back to user.
3645   E5A1             ;
3646   E5A1             ;   Function #40. This is a special entry to do random i/o.
3647   E5A1             ; For the case where we are writing to unused disk space, this
3648   E5A1             ; space will be zeroed out first. This must be a M/PM special
3649   E5A1             ; purpose function, because why would any normal program even
3650   E5A1             ; care about the previous contents of a sector about to be
3651   E5A1             ; written over.
3652   E5A1             ;
3653   E5A1 CD 57 E4    WTSPECL:	CALL	AUTOSEL		;select proper drive.
3654   E5A4 3E 02       	LD	A,2			;use special write mode.
3655   E5A6 32 DB E5    	LD	(MODE),A
3656   E5A9 0E 00       	LD	C,0			;set write indicator.
3657   E5AB CD 0D E3    	CALL	POSITN1		;position the file.
3658   E5AE CC 09 E2    	CALL	Z,WTSEQ1		;and write (if no errors).
3659   E5B1 C9          	RET	
3660   E5B2             ;
3661   E5B2             ;**************************************************************
3662   E5B2             ;*
3663   E5B2             ;*     BDOS data storage pool.
3664   E5B2             ;*
3665   E5B2             ;**************************************************************
3666   E5B2             ;
3667   E5B2 E5          EMPTYFCB: 	.DB	0E5H			;empty directory segment indicator.
3668   E5B3 00 00       WRTPRT:	.DW	0			;write protect status for all 16 drives.
3669   E5B5 00 00       LOGIN:	.DW	0			;drive active word (1 bit per drive).
3670   E5B7 80 00       USERDMA:	.DW	080H			;user's dma address (defaults to 80h).
3671   E5B9             ;
3672   E5B9             ;   Scratch areas from parameter block.
3673   E5B9             ;
3674   E5B9 00 00       SCRATCH1: 	.DW	0			;relative position within dir segment for file (0-3).
3675   E5BB 00 00       SCRATCH2: 	.DW	0			;last selected track number.
3676   E5BD 00 00       SCRATCH3: 	.DW	0			;last selected sector number.
3677   E5BF             ;
3678   E5BF             ;   Disk storage areas from parameter block.
3679   E5BF             ;
3680   E5BF 00 00       DIRBUF:	.DW	0			;address of directory buffer to use.
3681   E5C1 00 00       DISKPB:	.DW	0			;contains address of disk parameter block.
3682   E5C3 00 00       CHKVECT:	.DW	0			;address of check vector.
3683   E5C5 00 00       ALOCVECT: 	.DW	0			;address of allocation vector (bit map).
3684   E5C7             ;
3685   E5C7             ;   Parameter block returned from the bios.
3686   E5C7             ;
3687   E5C7 00 00       SECTORS:	.DW	0			;sectors per track from bios.
3688   E5C9 00          BLKSHFT:	.DB	0			;block shift.
3689   E5CA 00          BLKMASK:	.DB	0			;block mask.
3690   E5CB 00          EXTMASK:	.DB	0			;extent mask.
3691   E5CC 00 00       DSKSIZE:	.DW	0			;disk size from bios (number of blocks-1).
3692   E5CE 00 00       DIRSIZE:	.DW	0			;directory size.
3693   E5D0 00 00       ALLOC0:	.DW	0			;storage for first bytes of bit map (dir space used).
3694   E5D2 00 00       ALLOC1:	.DW	0
3695   E5D4 00 00       OFFSET:	.DW	0			;first usable track number.
3696   E5D6 00 00       XLATE:	.DW	0			;sector translation table address.
3697   E5D8             ;
3698   E5D8             ;
3699   E5D8 00          CLOSEFLG: 	.DB	0			;close flag (=0ffh is extent written ok).
3700   E5D9 00          RDWRTFLG: 	.DB	0			;read/write flag (0ffh=read, 0=write).
3701   E5DA 00          FNDSTAT:	.DB	0			;filename found status (0=found first entry).
3702   E5DB 00          MODE:		.DB	0			;I/o mode select (0=random, 1=sequential, 2=special random).
3703   E5DC 00          EPARAM:	.DB	0			;storage for register (E) on entry to bdos.
3704   E5DD 00          RELBLOCK: 	.DB	0			;relative position within fcb of block number written.
3705   E5DE 00          COUNTER:	.DB	0			;byte counter for directory name searches.
3706   E5DF 00 00 00 00 SAVEFCB:	.DW	0,0			;save space for address of fcb (for directory searches).
3707   E5E3 00          BIGDISK:	.DB	0			;if =0 then disk is > 256 blocks long.
3708   E5E4 00          AUTO:		.DB	0			;if non-zero, then auto select activated.
3709   E5E5 00          OLDDRV:	.DB	0			;on auto select, storage for previous drive.
3710   E5E6 00          AUTOFLAG: 	.DB	0			;if non-zero, then auto select changed drives.
3711   E5E7 00          SAVNXT:	.DB	0			;storage for next record number to access.
3712   E5E8 00          SAVEXT:	.DB	0			;storage for extent number of file.
3713   E5E9 00 00       SAVNREC:	.DW	0			;storage for number of records in file.
3714   E5EB 00 00       BLKNMBR:	.DW	0			;block number (physical sector) used within a file or logical sect
3715   E5ED 00 00       LOGSECT:	.DW	0			;starting logical (128 byte) sector of block (physical sector).
3716   E5EF 00          FCBPOS:	.DB	0			;relative position within buffer for fcb of file of interest.
3717   E5F0 00 00       FILEPOS:	.DW	0			;files position within directory (0 to max entries -1).
3718   E5F2             ;
3719   E5F2             ;   Disk directory buffer checksum bytes. One for each of the
3720   E5F2             ; 16 possible drives.
3721   E5F2             ;
3722   E5F2 00 00 00 00 CKSUMTBL: 	.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
3722   E5F6 00 00 00 00 
3722   E5FA 00 00 00 00 
3722   E5FE 00 00 00 00 
3723   E602             
3724   E5FE             		.ORG	BIOS-2
3725   E5FE 0C D8       		.DW	FBASE			;write here the BDOS entry point so BIOS can copy it to page zero
3726   E600             ;**************************************************************
3727   E600             ;*
3728   E600             ;*        B I O S   J U M P   T A B L E
3729   E600             ;*
3730   E600             ;**************************************************************
3731   E600             ;
3732   E600             		.ORG	BIOS
3733   E600 C3 00 00    BOOT:		JP	0			;NOTE WE USE FAKE DESTINATIONS
3734   E603 C3 00 00    WBOOT:	JP	0
3735   E606 C3 00 00    CONST:	JP	0
3736   E609 C3 00 00    CONIN:	JP	0
3737   E60C C3 00 00    CONOUT:	JP	0
3738   E60F C3 00 00    LIST:		JP	0
3739   E612 C3 00 00    PUNCH:	JP	0
3740   E615 C3 00 00    READER:	JP	0
3741   E618 C3 00 00    HOME:		JP	0
3742   E61B C3 00 00    SELDSK:	JP	0
3743   E61E C3 00 00    SETTRK:	JP	0
3744   E621 C3 00 00    SETSEC:	JP	0
3745   E624 C3 00 00    SETDMA:	JP	0
3746   E627 C3 00 00    READ:		JP	0
3747   E62A C3 00 00    WRITE:	JP	0
3748   E62D C3 00 00    PRSTAT:	JP	0
3749   E630 C3 00 00    SECTRN:	JP	0
3750   E633             ;
3751   E633             ;*
3752   E633             ;******************   E N D   O F   C P / M   *****************
3753   E633             ;*
3754   E633             		.END
tasm: Number of errors = 0
