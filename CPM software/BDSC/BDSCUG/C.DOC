          **********************************************************
          *                                                        *
          *       BD Software C Compiler  v1.32+     July 4, 1980  *
          *       On-line Handbook                                 *
          *       written by      Leor Zolman                      *
          *                       BD Software                      *
          *                       173 Hampshire st. #2             *
          *                       Cambridge, Mass. 02139           *
          *                       (617) 492-3038 evenings          *
          *                                                        *
          *      Note new CLINK options: -v, -l, -r, -c            *
          *      (The only difference between v1.32+ and v1.32 is  *
          *      CLINK and this doc file. The new CLINK will not   *
          *      bomb anymore on excessively large linkages, but   *
          *      the -r option may be necessary to avoid a         *
          *              "Ref table overflow" error.               *
          **********************************************************
 
 
There  is  NO  restriction on use of COM files generated by the BDS C Compiler;
Users are free to place such items on the market without paying any royalty for
use of run-time routines provided with the compiler package.  
 

The main components  of  the  BDS  C  package  are:  four  executable COM files
(CC1.COM,  CC2.COM,  CLINK.COM  and  CLIB.COM),  two  standard  library   files
(DEFF.CRL and DEFF2.CRL), and a run-time package module (C.CCC). There are also
a few sample source programs and various utility packages.  
 
A description of each follows:  
 
 
CC1:      Because  C  loads the entire source file into memory in one shot, the
          compilation is broken up into two phases (not "passes", strictly; The
          two phases end  up  taking  about  8 "passes" to actually implement),
          maximizing the amount of memory available for the source file.  
 
          CC1, the first phase of the compiler,  accepts  a  C source file with
          any  filename and extension (say, "foo.c") and produces  a  temporary
          file containing  a  symbol  table  and  an encoded form of the source
          code.  By default, version 1.3 will leave  the  temporary file in RAM
          and attempt to load in the next phase of the compiler  (CC2) from the
          currently  logged  in disk (unless error occur); see the "-a"  option
          below for control details.  
 
          The file extension ".C"  is  NOT assumed for the source file name, so
          saying "foo" when you mean "foo.c" would not work.  
 
          If the source file name is preceded  by  a disk designation, then the
          input is taken from the specified disk, and the output (if no errors)
          is written to that disk.  
 
          Following the name of the source file on the  command  line,  you may
          specify a list of options, each "optionally" preceded by a dash.  THE
          COMMAND  LINE  PROCESSOR  IS  NEW FOR v1.32...OPTIONS FOR CC1 ARE NOW
          SPECIFIED IN THE SAME MANNER AS WITH CLINK.  
 
          The recognized options are:  
 
 
          -s      causes undeclared identifiers  to  be  implicitly declared as
                  int variables, wherever possible.  (this  is  not  especially
                  useful,  since most C compilers demand that all variables  be
                  declared always.  If  you  desire portability, don't use this
                  option.) 
 
          -o      causes  speed-optimization  to   be   performed   instead  of
                  space-optimization. I.e., causes the final generated  code to
                  be  longer  but  faster.    Will  ONLY  work  provided CC2 is
                  auto-loaded by CC1.  Otherwise, location ram+104h  of CC2.COM
                  must be changed from 01h to 00h, using DDT or SID, in lieu of
                  the "-o" option.  
 
          -p      causes  the  result  of the preprocessor phase of compilation
                  (i.e., the result of #define and #include text substitutions)
                  to be written to the CP/M  console output, with lines numbers
                  generated. If you type a control-P  before  hitting return on
                  the command line, output will also go to the list device.  
 
          -r n    reserves nK bytes for the symbol table.  Default  value for n
                  is 8 (6 for 4200h-based versions.) Minimum symbol table  size
                  is 5K.  
 
          -a x    Causes CC2.COM to be auto-loaded from disk x, where x may  be
                  "a",  "b",  "c",  etc...or  "z"  to  force  a .CCI file to be
                  written to disk (under control of the "-d" option below.) 
 
                  You'd  use  this  option when the disk on which  your  BDS  C
                  commands reside is  NOT  the  currently  logged  disk; In the
                  absence  of  this  option,  CC1 will auto- load CC2 from  the
                  currently logged disk.  
 
          -d x    Specifies to which disk the .CRL  file output of the compiler
                  is  to be written. The default is the  disk  from  which  the
                  source was taken. Again, x can be "a", "b", "c", etc.  
 
                  If auto-loading  of CC2 is not performed (i.e., if the "-a z"
                  option is used), then  this  option  controls  which disk the
                  .CCI file output is to be written to.  
 
                  
 
          Examples:  
          
                  A>cc1 foobar.c -s -r6
 
          Supresses errors for undefined variables, sets symbol table  size  to
          6K bytes, and auto-loads CC2 from the currently logged disk;  
          
                  A>cc1 zot.c -r14 -a z -p
             (or) A>cc1 zot.c -r14azp
             (or) A>cc1 zot.c -pazr14
             (or) A>cc1 zot.c pazr14
 
          Sets  symbol  table  size  to  14K bytes (-r14), forces ZOT.CCI to be
          written to the currently logged disk (-a z), and text is displayed on
          the  console after all #defines and  #includes  have  been  processed
          (-p). Note that dashes and spaces are all optional.  
          
                  A>cc1 b:bunny.c -ac
 
          Gets BUNNY.C  from  disk  B,  and  auto-loads CC2.COM from disk C (if
          there are no bugs in BUNNY.) 
          
                  A>cc1 chess.c -o
 
          Compiles chess.c, auto-loads CC2 from the current disk, and optimizes
          for speed. In the previous examples,  space-optimization  is  instead
          performed by default.  
 
          On  a  2  MHz  8080,  processing speed (not counting disk waiting) is
          about 12 lines of source/second.    On a 4 MHz Z80, speed is about 30
          lines/sec.  
 
 
CC2:      This is the second phase of the compiler.  CC2  accepts a ".CCI" file
          as  input,  and writes out a ".CRL" file if no errors  are  detected.
          (CRL  is  mnemonic   for   'C   ReLocatable'.)  Normally  CC2.COM  is
          automatically loaded in (by CC1) and operates on the CCI file left in
          memory by CC1; If invoked explicitly,  then  the  .CCI file is loaded
          from disk.  
 
          If all goes well, writing out of the CRL file is followed by deletion
          of the "CCI" file (if it exits), and compilation is complete.  
 
          Like CC1, if a disk is specified explicitly as in 
          
                  A>cc2 c:yahoo
 
          then  the .CCI file is loaded from the specified disk  and  the  .CRL
          file is written to that same disk.  
 
          On an 8080,  execution  speed  = about 35 lines/sec.  On a 4 MHz Z80,
          speed is about 90 lines/sec.  
 
 
CLINK:    This program links a "main" function  from  a  given CRL file in with
          C.CCC  (for common system subroutines) and any subordinate  functions
          which "main" may require (from perhaps many CRL files).  Alternately,
          CLINK may  be  used to prepare a code segment which can be swapped in
          at run time by the root module.  
 
          A successful linkage  causes  a  ".COM" file to be generated. At this
          point, the 8080 absolute machine code  file  is  ready to be executed
          (for better or worse) as a transient command by CP/M  (or  swapped in
          by another COM file.) 
 
          The first argument on the command line must be the name of a CRL file
          containing  the  "main" function for your program (the .CRL extension
          need not be given, but note that the special meaning of the extension
          characters used in  previous versions has been eliminated in favor of
          some new conventional  command  line  options.) If a disk designation
          precedes the filename, this indicates where  all  .CRL  files (except
          DEFF*.CRL)  are  to  be searched for if further disk designators  are
          omitted.  
 
          Any other CRL files to  search  may  also be specified on the command
          line,  causing  them  to be searched in the  order  specified.    The
          default disk to search  will be the same disk from which the original
          CRL file was taken; this  default  can be overridden by specifying an
          explicit disk designation for any appropriate  CRL  file name needing
          it.  
 
          After  all  given  CRL  files  have  been  searched once, CLINK  will
          automatically search DEFF.CRL and then DEFF2.CRL.  
 
          An example:  
          
                  A>clink c:foo bar a:zot fraz
 
          causes  disk  C  to  be searched for the files FOO.CRL,  BAR.CRL  and
          FRAZ.CRL, and disk A to  be searched to find ZOT.CRL. Note that CLINK
          expects  to find C.CCC, DEFF.CRL  and  DEFF2.CRL  on  the  currrently
          logged disk  by default, and also writes the COM file produced to the
          currently logged  disk.  To override these defaults, see the "-c" and
          "-o" options described below.  
 
          If there are still  some  unresolved  references  after all given CRL
          files  and  DEFF*.CRL  have  been scanned, then CLINK will  enter  an
          interactive mode with the user  in  order to try resolving them. This
          situation is likely to arise in the case  where  a  function  becomes
          "needed"  AFTER the CRL file containing it has already been searched.
          When yanking  functions out of a CRL file, CLINK will only take those
          which are already  known  to  be  needed  (due to a prior reference.)
          Thus, it will save you some pain to order the  CRL  filenames  on the
          command  line  in  such  a  way  as  to  minimize  undefined backward
          references.  This ONLY applies to multiple CRL files;  the  order  of
          functions within a single CRL file makes no difference.  
 
          There are many  options  which  may be specified on the CLINK command
          line. Each option must be preceded  by some space and a dash (-); the
          space between any option and its argument  (if  the  option  takes an
          argument) may be omitted.  
 
          The presently supported options are:  
 
                -s          Prints out load statistics;  
 
                -d          Use this to run the code immediately after linking,
                            for  debugging  purposes, instead of writing a  COM
                            file out to disk.    Note  that no arguments can be
                            passed to the program when executed in this way.  
 
                -t nnnn     Reserves location nnnn (hex)  and  above  for user;
                            default  is  to  reserve no space. What this really
                            does is to cause the first op in the object file to
                            become 
                            
                                    lxi sp,nnnn
 
                            instead of the usual 
                            
                                    lhld RAM+6
                                    sphl
 
 
                -c d        Tells CLINK to search disk "d" for C.CCC, DEFF.CRL,
                            and DEFF2.CRL. If  this  option  is  not given, the
                            currently logged disk is searched by default.  
 
                -o name     Causes the .COM file generated to be called 
           (or) -o name.    "name.COM", "name" or "name.ext" respectively 
           (or) -o name.ext for the first three forms. If this option is 
           (or) -o d:       not given, the name of the "main" .CRL file is used
                            by  default, with the extension ".COM".  The  given
                            name may be precided by a disk designator to direct
                            the output  to  a particular disk (the current disk
                            is used by default.)  The final form of this option
                            directs  the  output file  to  the  specified  disk
                            without affecting  the  filename  under which it is
                            written.  Note  that  the  colon  is  required   to
                            distinguish this from the first form of the option.
 
 
                -e xxxx     Sets  start  of  data  area  to  address  xxxx,  to
                            maintain  consistency between several separate .COM
                            files  when  chaining  (via  the  library  function
                            "exec")  is  used  and  external  data  need  to be
                            shared.    If  the  program  will  be  swapping  in
                            segments, then the value given MUST BE GREATER THAN
                            THE  HIGHEST  ADDRESS THAT WILL EVER BE OCCUPIED BY
                            SWAPPED-IN CODE.    Note  that  the  "Stack  space"
                            statistic,  printed  upon completion of linkage  if
                            "-s" is given, may be incorrect when this option is
                            used.  
 
                -y name     Yanks  in  the symbol table  file  "name.SYM"  from
                            disk, and defines  all  the  symbols found therein.
                            This  is used when linking an overlay  segment,  to
                            pre-define  the  function addresses resident in the
                            root node and accessible by the segment. See the -w
                            option below.  
 
                -w          Causes a SID-compatible  symbol  table  file  to be
                            written  to  disk for use either by SID or by CLINK
                            later on when  linking overlay segments (see the -y
                            option above.) 
 
                -v          Specifies that the  resultant  COM  file  is  to be
                            swapped in as an overlay segment by another command
                            at run time, so the run-time package (C.CCC) is not
                            linked  into the code. The "-l" (letter ell) option
                            should always  be  used  with  "-v". Note that this
                            option  replaces the shameful "foo.aaS"  scheme  of
                            previous versions.  
 
                -l xxxx     (letter ell) Determines the starting (load) address
                            of the generated  code.  Normally, this defaults to
                            the  address  of the TPA; If  used  with  the  "-v"
                            option, this generates  an  overlay segment to load
                            in  at  address  xxxx. If the "-v"  option  is  not
                            given, then the run-time  package (C.CCC) must have
                            been previously re-assembled  to  run  at  location
                            xxxx.  For detailed info on generating code to  run
                            at  an arbitrary  starting  address  and/or  to  be
                            ROMable,  see  the  User's  Guide appendix entitled
                            "Generating ROMable Code and Other Deviations" 
 
                -r xxxx     Reserve xxxx bytes (in HEX) for  the internal CLINK
                            forward function reference table.  This table's not
                            being  big  enough (and my faulty tests  for  table
                            overflow) were  responsible  for  CLINK's  previous
                            tendency  to  crash  on  big  linkages. While CLINK
                            won't crash anymore, it may give  you  a "Ref table
                            overflow"  message  and quit; if this happens,  use
                            this option with an argument  larger  than the 600h
                            default  for regular CP/M, or the 400h default  for
                            4200h-based  CP/M  systems,  to  enlarge  the table
                            area.  Of  course, this reduces the space available
                            for linked code...if  CLINK  gives  you  an "Out of
                            memory" message, use the "-r" option to reduce  the
                            reserved  table  space and provide more code space.
                            Chances are, though,  that  you  won't  be  able to
                            reduce  the table space by much before running  out
                            of it. Time for overlays...  
 
                            
          Examples:  
          
                  A>clink foo bar
 
          Gets  "main" from the file FOO.CRL,  searches  for  needed  functions
          first in  FOO.CRL  and  then,  if  needed,  in  BAR.CRL, DEFF.CRL and
          DEFF2.CRL. All files are assumed to reside on the currently logged-in
          disk.  
          
                  A>clink b:ihtfp belle -s
 
          Searches for IHTFP.CRL and BELLE.CRL on disk B; prints  a  statistics
          summary  when linkage is complete. The files DEFF*.CRL and C.CCC  are
          assumed to  reside  on the currently logged in disk; output also goes
          to the currently logged in disk.  
          
                  A>clink b:ihtfp. -c a -s belle -o c:zot
 
          is the same as the last  example  except:  the  output file is called
          ZOT.COM, DEFF*.CRL and C.CCC are assumed to reside  on  A, and output
          goes to disk C.  
          
                  A>clink stoned -t7000 -s
 
          Sets  top of memory to 7000h and prints out load statistics.  Current
          disk used for everything.  
 
          Note that  if the load statistics tell you that the "LAST ADDRESS" is
          greater than  the  "TOP OF MEMORY", the program hasn't got the chance
          of a snowball in hell of running correctly.  
          
                  A>clink rootseg -w -e 6000 -s
 
          links "rootseg" with  the  intention  of  having  "rootseg"  call  in
          segments  form  disk  as  it runs. The symbol table is written out to
          disk (via the -w option) named  "ROOTSEG.SYM",  and the external data
          area  is  set  to  6000 hex, indicating that the code  for  "rootseg"
          itself ends somewhere  low  enough  so  that  even  with  the longest
          segment(s) in RAM, the last code address doesn't exceed 6000  hex.  A
          stat summary is also output to the console.  
          
                  A>clink seg1 -y rootseg -s -v -l7000
 
          This  assumes  seg1  is  going to be swapped to location 7000h at run
          time by the file linked in the last example.  The 2K run-time package
          will  NOT  be included (as it  always  is  for  root  modules,  i.e.,
          non-segments).  The symbol file "ROOTSEG.SYM" is yanked in and milked
          for any useful addresses  it  may  contain,  and  a  stat  summary is
          printed  afterwards,  as  usual. Note that some of the stats are  not
          printed (such as the external data starting address), since they have
          no meaning to a segment.  
 
 
 
CLIB:     This program maintains .CRL  files, allows transfer of functions from
          one CRL file to another, etc. To invoke CLIB, just type 
          
                  A>clib
 
          CLIB will print a line such as 
          
                  Function buffer size = nnnnn
 
          specifying the largest function  size that can be handled. Attempting
          to "transfer" or "extract" a function  larger than this size could be
          destructive.  
 
          Next CLIB will prompt with a "*". Typing  "h" at this point will give
          you a command summary.  
 
          Basically, you work CLIB by opening one to  six CRL files (which then
          become associated with "file numbers"), diddling  the  files  to your
          hearts  content,  closing  all  files  which  you altered, and typing
          control-C.  
 
          The old version of any CRL file you change with  CLIB  is  renamed to
          name.BRL (for Backup ReLative).  
 
          A sample session of CLIB to, say, transfer the functions named "FOO",
          "BAR",  and  "ZOT"  from a .CRL file named "DSSR" to one named  "RTS"
          would go as follows:  
                  
                  A>clib
                  BD Sofware C Librarian v1.31
                  Function buffer size = xxxxx bytes
                  * open 0 dssr
                  * open 1 rts
                  * t 0 1 foo
                  * t 0 1 bar
                  * t 0 1 zot
                  * c 1
                  * ^C
                  
                  A> ...
 
                  
          The "open" commands prepare  to do work on a .CRL file, and associate
          each .CRL file opened with a digit  (0-5).    The "transfer" commands
          tell CLIB to transfer the named function from the  first  file (named
          by  file  #) to the second file (also named by number).  The  "close"
          command need  only  be given for files which have been altered; since
          DSSR wasn't written to  in  the  above  example, it didn't need to be
          closed, but RTS did need to be closed.  
 
          Note: using the "d" command (to delete a  function  from  a CRL file)
          does  NOT free up the CRL directory space which was taken up  by  the
          deleted  function's  name. This space does not become available UNITL
          AFTER THE FILE IS CLOSED (using the "c" command.) This means that if,
          for example, you want  to delete some stuff from DEFF.CRL in order to
          make  room  for  other  stuff,  you  have  to  close  DEFF.CRL  after
          performing the deletiions,  re-open  it,  and  THEN  transfer the new
          functions  in...otherwise  you'll  draw  a  "No  more  space  in  CRL
          directory" error.  
 
 
DEFF.CRL: Contains all compiled functions from STDLIB1.C and STDLIB2.C, as well
          as the major I/O functions written in machine language. See the BDS C
          User's  Guide,  STDLIB1.C  and STDLIB2.C for documentation  on  these
          functions.  
 
 
DEFF2.CRL: More library functions. This  file  is  an  overflow  from DEFF.CRL,
          containing   the   newer  and  more  obscure  machine-language  coded
          functions. Both DEFF.CRL and DEFF2.CRL are now searched automatically
          by CLINK.  
 
 
C.CCC:    The run-time package, containing code for processing the command line
          (generating argc and  argv,  for  you UNIX lovers), room for file I/O
          buffers, some math subroutines, etc.    This  piece  of  code  always
          occupies  the  first  74fh bytes (ram+100h to ram+84eh) of .COM files
          generated by CLINK.  
 
 
OTHER THINGS YOU GET WITH THE PACKAGE:  
 
 
 
STDLIB1.C       Source  for library  functions  which  are  written  in  C  and
                present, in compiled form, within DEFF.CRL.  
 
STDLIB2.C       More DEFF.CRL library function sources.  
 
STONE.C         Game program  using  good  recursion techniques. Tough to beat,
                too.  Written  by ace hackers  Clark  Baker  and  Terry  Hayes.
                Special H19 version for H89 systems.  
 
PRESSUP.C       Another neat game -- excellent human engineering on this one by
                Steve Ward.  
 
OTHELLO.C       Game again. Doesn't put up much of a fight, but has sentimental
                value as the first  real  program  ever  compiled by BDS C, and
                also serves as a good example of passing arrays as arguments to
                functions.  
 
LIFE.C          Yet another game program; shows off speed  of programs compiled
                by BDS C.  Special H19 version for H89 systems.  
 
MM.C            Mastermind. Another goodie By Steve.  
 
TTT.C           You guessed it -- now try to beat it!  
 
RALLY.C         Arcade game, for H19 terminal only.  
 
BUGS.C          Defies description...for H19 only.  
 
TABIFY.C        Turns spaces into tabs, optimizing storage requirements  for  a
                text file.  
 
COPYALL.C       A  utility  program,  for  single-disk  systems, which copies a
                whole  mess of files from one disk to another  while  buffering
                stuff up  in  memory as much as possible. This is the program I
                wrote to make BDS C package disks, after the number of files in
                the package got  large  enough to make using FILECOPY.COM a bit
                impractical.  
 
PNUM.C          Utility program to print out a file with line numbers (see also
                the "-p" option to CC1.).  
 
TELNET.C        Program  to let a system be  used  as  a  terminal,  optionally
                routing  stuff  from  modem  to  disk  and  vice-  versa.  Nice
                hanshaking and check- summing features. Hairy but useful.  
 
CONVERT.C       Converts unprintable  characters (for systems having upper-case
                only  and/or  incomplete   special  symbol  set)  into  special
                2-character sequences beginning  with  the  character  '#'. See
                also CC0T.C 
 
CC0T.C          Converts  C  source  files  containing  the  special  sequences
                generated by the CONVERT program back into a form that  can  be
                compiled.    For  more  info  on CONVERT and CC0T, see the last
                section of this file.  
 
 
C.DOC           You seem to have found this one.  
 
FLOAT.DOC,      Bob Mathias's contributed floating 
FLOAT.C         point  package  (uses  the  "fp"  function   which  resides  in
                DEFF2.CRL.) 
 
FLOATSUM.C      Sample program using the floating point package.  
 
CCRL.DOC,       Earl T. Cohen's COM-to-CRL conversion 
CCRL.C          program. Use this only if you don't have MACRO-80 or MAC.  
 
BIGFIO.C        Large-buffered File I/O library, by Scott Layson.  
 
CMAC.DOC,       Macro package for use with Digital Re- 
CMAC.LIB        search's  "mac"  macro  assembler to make CRL files  painlessly
                from assembler programs.  (There's  a  printed document telling
                how to do same with MACRO-80.) 
 
 
                

        ===== == === === = =========
        Notes on the BDS C compiler:
        ===== == === === = =========
 
THIS IS NOT AN INTERPRETER.  
 
Some hacks, such as BASIC-E, are billed as compilers but  actually just do some
preprocessing  and  then  interpret  the  program.  BDS  C is a true  compiler,
generating not-too-optimal but nevertheless quick 8080 code.  
 
For the gory details on the BDS C implementation, see my notes to APPENDIX A of
the EXCELLENT book 

        "The C Programming Language."
 
Variable types supported:  
        
        int,
        char,
        unsigned,
        struct,
        union,
        pointers to  a) all of the above
                     b) to other pointers and
                     c) to functions,
        arrays (of one or two dimensions),
        simple combinations of the above.
 
        For example, 

         char *foo[10][15];
 
declares foo to be a two dimensional array of pointers to characters;  

        char (*foo)();
 
declares foo to be a pointer to a function returning a character;  

        char *foo, bar, zot[10];
 
declares foo to be a pointer to characters, bar to be a single  char  variable,
ant zot to be an array of 10 characters.  
 
Since  all  functions  in C may be used recursively, all variable accessing  is
done relative to a base-of-  stack-frame  pointer, kept in the BC register pair
during execution. Note that it takes 8 bytes of code to transfer a simple local
variable whose address is 

        (Base of stack pointer) + foo
 
to the HL register pair; The code appears as:  

        lxi h,foo
        dad b
        mov a,m
        inx h
        mov h,m
        mov l,a
 
To get an array element or structure element  is  even  more  hairy. Facts like
this are enough to make me REALLY wish Intel had bothered to implement a double
byte indirect load instruction. Oh well.  
 
If  your  keyboard doesn't support the '{' and '}' characters (open  and  close
brace, for  those of you whose printer doesn't know about ascii 7B and 7D), the
symbols 'begin' and 'end' may be substituted. Don't unless you have to; '{' and
'}' take up less  memory.  The CONVERT program will perform this conversion, if
necessary.  
 
 

        ==== ===
        Test Run
        ==== ===
 
To see if everything  is  OK,  try  compiling  the  sample program STONE.C. The
sequence should look like this:  
        
        A>cc1 stone.c
        BD Software C Compiler v1.31  (Part I)
           xxK elbowroom
        BD Software C Compiler v1.31 (Part II)
           xxK to spare
        
        A>clink stone
        BD Software C Linker v1.31
        Linkage complete
          xxK left over
        
        A>stone
        Difficulty (1-1000): 
        
        <and so on as STONE.COM executes...>
        
        
 
Now for all you UPPER-CASE-ONLY (and/or limited symbols) people:  
 
The C compiler itself doesn't know the difference between  a  printable  and  a
non-printable   character   (as  far  as  your  upper-  case-only  terminal  is
concerned.) In order for a source  file to compile properly, characters such as
"left bracket" must appear as their  ASCII value indicates. Since your terminal
can't print these special characters (there  are  about  nine  of  them  used),
typing out a normal source file (say, LIFE.C) will produce some strange symbols
on your terminal in place of what's really there.  What's needed is some way to
encode  those  special symbols so that you can enter them and read them on your
terminal for editing, and them un-encode them for purposes of compilation.  
 
Thus, the programs  CONVERT.C  and  CC0T.C have been provided to translate back
and  forth  between an encoded form of  source  code  in  which  all  of  these
unprintable characters get represented in terms of printable symbols; i.e., the
character "#" (which has no special meaning to the C compiler unless it is part
of one of the  strings  "#define",  "#include",  "#ifdef",  "#ifndef", "#else",
"#undef" and "#endif") followed by one of the characters:  

        B, L, R, C, V, U, or H.
 
(Note that the "#undef" preprocessor directive has been just  recently added to
the  compiler,  and  clashes  with  the "#U" encoding. If you need to  use  the
"#undef" directive, you'll need to change  the  "U"  to  some  other  character
(perhaps "N") by modifying the CONVERT.C and CC0T.C programs.) 
 
The precise usage of each of the sequences #B, #L, #R, etc., is covered  by the
comments within the CONVERT.C source file.  
 
So,  the  CONVERT  program  takes source files in the natural form and converts
them to "#" notation (let's call  it  ".CT"  format.)  The  form of the CONVERT
command is:  

        A>convert foo.c bar.ct
 
where foo.c is an existing normal source file, and bar.ct is  a  new file to be
created as an encoded form of foo.c.  You may then edit the .ct file  normally,
using the "#" conventions to represent all those special characters.  
 
When  you're  ready to compile the file, the CC0T program must be run first  to
convert the .CT file back into the natural format.  
 
To reverse the example above, the command would be:  

        A>cc0t bar.ct zot.c
 
leaving zot.c as the file ready for compilation by BDS C.  
 
If you don't have  an  upper-case-only  terminal  (or  one  lacking  a complete
symbolic  character  set),  then  you  won't  need to bother with CONVERT.C  or
CC0T.C. Otherwise...I suggest you upgrade as soon  as  possible to a full ASCII
terminal, so you can forget about CONVERT and CC0T forever.  
 
Incidentally, both CONVERT.C and CC0T.C must be compiled  before  they  can  be
used.  If  this  seems  confusing,  remember  that  the  problem here is NOT an
incompatibility  between  the  source files and the compiler,  but  rather  one
between  the  source  files  and  your  terminal's  ability  to  display  them.
CONVERT.C and CC0T.C will compile in  their  present  form  no matter what; but
modifying  them  on  a  limited  terminal  would  require passing them  through
CONVERT.COM first.  
 
        << The End >>
