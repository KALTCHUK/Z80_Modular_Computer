0001   0000             ;**************************************************************
0002   0000             ;*
0003   0000             ;*             C P / M   version   2 . 2
0004   0000             ;*
0005   0000             ;*   Reconstructed from memory image on February 27, 1981
0006   0000             ;*
0007   0000             ;*                by Clark A. Calkins
0008   0000             ;*
0009   0000             ;**************************************************************
0010   0000             ;
0011   0000             ;   Set memory limit here. This is the amount of contigeous
0012   0000             ; ram starting from 0000. CP/M will reside at the end of this space.
0013   0000             ;
0014   0000             
0015   0000             BIOS		.EQU	0E600H		;BIOS start address
0016   0000             IOBYTE	.EQU	3			;i/o definition byte.
0017   0000             TDRIVE	.EQU	4			;current drive name and user number.
0018   0000             ENTRY		.EQU	5			;entry point for the cp/m bdos.
0019   0000             TFCB		.EQU	5CH			;default file control block.
0020   0000             TBUFF		.EQU	80H			;i/o buffer and command line storage.
0021   0000             TBASE		.EQU	100H			;transiant program storage area.
0022   0000             ;
0023   0000             ;   Set control character equates.
0024   0000             ;
0025   0000             CNTRLC	.EQU	3			;control-c
0026   0000             CNTRLE	.EQU	05H			;control-e
0027   0000             BS		.EQU	08H			;backspace
0028   0000             TAB		.EQU	09H			;tab
0029   0000             LF		.EQU	0AH			;line feed
0030   0000             FF		.EQU	0CH			;form feed
0031   0000             CR		.EQU	0DH			;carriage return
0032   0000             CNTRLP	.EQU	10H			;control-p
0033   0000             CNTRLR	.EQU	12H			;control-r
0034   0000             CNTRLS	.EQU	13H			;control-s
0035   0000             CNTRLU	.EQU	15H			;control-u
0036   0000             CNTRLX	.EQU	18H			;control-x
0037   0000             CNTRLZ	.EQU	1AH			;control-z (end-of-file mark)
0038   0000             DEL		.EQU	7FH			;rubout
0039   0000             ;
0040   0000             ;   Set origin for CP/M
0041   0000             ;
0042   D000             		.ORG	0D000H
0043   D000             ;
0044   D000 C3 5C D3    CBASE:	JP	COMMAND		;execute command processor (ccp).
0045   D003 C3 58 D3    		JP	CLEARBUF		;entry to empty input buffer before starting ccp.
0046   D006             
0047   D006             ;
0048   D006             ;   Standard cp/m ccp input buffer. Format is (max length),
0049   D006             ; (actual length), (char #1), (char #2), (char #3), etc.
0050   D006             ;
0051   D006 7F          INBUFF:	.DB	127			;length of input buffer.
0052   D007 00          		.DB	0			;current length of contents.
0053   D008 43 6F 70 79 		.TEXT	"Copyright"
0053   D00C 72 69 67 68 
0053   D010 74 
0054   D011 20 31 39 37 		.TEXT	" 1979 (c) by Digital Research      "
0054   D015 39 20 28 63 
0054   D019 29 20 62 79 
0054   D01D 20 44 69 67 
0054   D021 69 74 61 6C 
0054   D025 20 52 65 73 
0054   D029 65 61 72 63 
0054   D02D 68 20 20 20 
0054   D031 20 20 20 
0055   D034 00 00 00 00 		.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0055   D038 00 00 00 00 
0055   D03C 00 00 00 00 
0055   D040 00 00 00 00 
0055   D044 00 00 00 00 
0055   D048 00 00 00 
0056   D04B 00 00 00 00 		.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0056   D04F 00 00 00 00 
0056   D053 00 00 00 00 
0056   D057 00 00 00 00 
0056   D05B 00 00 00 00 
0056   D05F 00 00 00 
0057   D062 00 00 00 00 		.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0057   D066 00 00 00 00 
0057   D06A 00 00 00 00 
0057   D06E 00 00 00 00 
0057   D072 00 00 00 00 
0057   D076 00 00 00 
0058   D079 00 00 00 00 		.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0058   D07D 00 00 00 00 
0058   D081 00 00 00 00 
0058   D085 00 00 00 
0059   D088 08 D0       INPOINT:	.DW	INBUFF+2		;input line pointer
0060   D08A 00 00       NAMEPNT:	.DW	0			;input line pointer used for error message. Points to
0061   D08C             ;						;start of name in error.
0062   D08C             ;
0063   D08C             ;   Routine to print (A) on the console. All registers used.
0064   D08C             ;
0065   D08C 5F          PRINT:	LD	E,A			;setup bdos call.
0066   D08D 0E 02       		LD	C,2
0067   D08F C3 05 00    		JP	ENTRY
0068   D092             ;
0069   D092             ;   Routine to print (A) on the console and to save (BC).
0070   D092             ;
0071   D092 C5          PRINTB:	PUSH	BC
0072   D093 CD 8C D0    		CALL	PRINT
0073   D096 C1          		POP	BC
0074   D097 C9          		RET	
0075   D098             ;
0076   D098             ;   Routine to send a carriage return, line feed combination
0077   D098             ; to the console.
0078   D098             ;
0079   D098 3E 0D       CRLF:		LD	A,CR
0080   D09A CD 92 D0    		CALL	PRINTB
0081   D09D 3E 0A       		LD	A,LF
0082   D09F C3 92 D0    		JP	PRINTB
0083   D0A2             ;
0084   D0A2             ;   Routine to send one space to the console and save (BC).
0085   D0A2             ;
0086   D0A2 3E 20       SPACE:	LD	A,' '
0087   D0A4 C3 92 D0    		JP	PRINTB
0088   D0A7             ;
0089   D0A7             ;   Routine to print character string pointed to be (BC) on the
0090   D0A7             ; console. It must terminate with a null byte.
0091   D0A7             ;
0092   D0A7 C5          PLINE:	PUSH	BC
0093   D0A8 CD 98 D0    		CALL	CRLF
0094   D0AB E1          		POP	HL
0095   D0AC 7E          PLINE2:	LD	A,(HL)
0096   D0AD B7          		OR	A
0097   D0AE C8          		RET	Z
0098   D0AF 23          		INC	HL
0099   D0B0 E5          		PUSH	HL
0100   D0B1 CD 8C D0    		CALL	PRINT
0101   D0B4 E1          		POP	HL
0102   D0B5 C3 AC D0    		JP	PLINE2
0103   D0B8             ;
0104   D0B8             ;   Routine to reset the disk system.
0105   D0B8             ;
0106   D0B8 0E 0D       RESDSK:	LD	C,13
0107   D0BA C3 05 00    		JP	ENTRY
0108   D0BD             ;
0109   D0BD             ;   Routine to select disk (A).
0110   D0BD             ;
0111   D0BD 5F          DSKSEL:	LD	E,A
0112   D0BE 0E 0E       		LD	C,14
0113   D0C0 C3 05 00    		JP	ENTRY
0114   D0C3             ;
0115   D0C3             ;   Routine to call bdos and save the return code. The zero
0116   D0C3             ; flag is set on a return of 0ffh.
0117   D0C3             ;
0118   D0C3 CD 05 00    ENTRY1:	CALL	ENTRY
0119   D0C6 32 EE D7    		LD	(RTNCODE),A	;save return code.
0120   D0C9 3C          		INC	A			;set zero if 0ffh returned.
0121   D0CA C9          		RET	
0122   D0CB             ;
0123   D0CB             ;   Routine to open a file. (DE) must point to the FCB.
0124   D0CB             ;
0125   D0CB 0E 0F       OPEN:		LD	C,15
0126   D0CD C3 C3 D0    		JP	ENTRY1
0127   D0D0             ;
0128   D0D0             ;   Routine to open file at (FCB).
0129   D0D0             ;
0130   D0D0 AF          OPENFCB:	XOR	A			;clear the record number byte at fcb+32
0131   D0D1 32 ED D7    		LD	(FCB+32),A
0132   D0D4 11 CD D7    		LD	DE,FCB
0133   D0D7 C3 CB D0    		JP	OPEN
0134   D0DA             ;
0135   D0DA             ;   Routine to close a file. (DE) points to FCB.
0136   D0DA             ;
0137   D0DA 0E 10       CLOSE:	LD	C,16
0138   D0DC C3 C3 D0    		JP	ENTRY1
0139   D0DF             ;
0140   D0DF             ;   Routine to search for the first file with ambigueous name
0141   D0DF             ; (DE).
0142   D0DF             ;
0143   D0DF 0E 11       SRCHFST:	LD	C,17
0144   D0E1 C3 C3 D0    		JP	ENTRY1
0145   D0E4             ;
0146   D0E4             ;   Search for the next ambigeous file name.
0147   D0E4             ;
0148   D0E4 0E 12       SRCHNXT:	LD	C,18
0149   D0E6 C3 C3 D0    		JP	ENTRY1
0150   D0E9             ;
0151   D0E9             ;   Search for file at (FCB).
0152   D0E9             ;
0153   D0E9 11 CD D7    SRCHFCB:	LD	DE,FCB
0154   D0EC C3 DF D0    		JP	SRCHFST
0155   D0EF             ;
0156   D0EF             ;   Routine to delete a file pointed to by (DE).
0157   D0EF             ;
0158   D0EF 0E 13       DELETE:	LD	C,19
0159   D0F1 C3 05 00    		JP	ENTRY
0160   D0F4             ;
0161   D0F4             ;   Routine to call the bdos and set the zero flag if a zero
0162   D0F4             ; status is returned.
0163   D0F4             ;
0164   D0F4 CD 05 00    ENTRY2:	CALL	ENTRY
0165   D0F7 B7          		OR	A			;set zero flag if appropriate.
0166   D0F8 C9          		RET	
0167   D0F9             ;
0168   D0F9             ;   Routine to read the next record from a sequential file.
0169   D0F9             ; (DE) points to the FCB.
0170   D0F9             ;
0171   D0F9 0E 14       RDREC:	LD	C,20
0172   D0FB C3 F4 D0    		JP	ENTRY2
0173   D0FE             ;
0174   D0FE             ;   Routine to read file at (FCB).
0175   D0FE             ;
0176   D0FE 11 CD D7    READFCB:	LD	DE,FCB
0177   D101 C3 F9 D0    		JP	RDREC
0178   D104             ;
0179   D104             ;   Routine to write the next record of a sequential file.
0180   D104             ; (DE) points to the FCB.
0181   D104             ;
0182   D104 0E 15       WRTREC:	LD	C,21
0183   D106 C3 F4 D0    		JP	ENTRY2
0184   D109             ;
0185   D109             ;   Routine to create the file pointed to by (DE).
0186   D109             ;
0187   D109 0E 16       CREATE:	LD	C,22
0188   D10B C3 C3 D0    		JP	ENTRY1
0189   D10E             ;
0190   D10E             ;   Routine to rename the file pointed to by (DE). Note that
0191   D10E             ; the new name starts at (DE+16).
0192   D10E             ;
0193   D10E 0E 17       RENAM:	LD	C,23
0194   D110 C3 05 00    		JP	ENTRY
0195   D113             ;
0196   D113             ;   Get the current user code.
0197   D113             ;
0198   D113 1E FF       GETUSR:	LD	E,0FFH
0199   D115             ;
0200   D115             ;   Routne to get or set the current user code.
0201   D115             ; If (E) is FF then this is a GET, else it is a SET.
0202   D115             ;
0203   D115 0E 20       GETSETUC: 	LD	C,32
0204   D117 C3 05 00    		JP	ENTRY
0205   D11A             ;
0206   D11A             ;   Routine to set the current drive byte at (TDRIVE).
0207   D11A             ;
0208   D11A CD 13 D1    SETCDRV:	CALL	GETUSR		;get user number
0209   D11D 87          		ADD	A,A			;and shift into the upper 4 bits.
0210   D11E 87          		ADD	A,A
0211   D11F 87          		ADD	A,A
0212   D120 87          		ADD	A,A
0213   D121 21 EF D7    		LD	HL,CDRIVE		;now add in the current drive number.
0214   D124 B6          		OR	(HL)
0215   D125 32 04 00    		LD	(TDRIVE),A		;and save.
0216   D128 C9          		RET	
0217   D129             ;
0218   D129             ;   Move currently active drive down to (TDRIVE).
0219   D129             ;
0220   D129 3A EF D7    MOVECD:	LD	A,(CDRIVE)
0221   D12C 32 04 00    		LD	(TDRIVE),A
0222   D12F C9          		RET	
0223   D130             ;
0224   D130             ;   Routine to convert (A) into upper case ascii. Only letters
0225   D130             ; are affected.
0226   D130             ;
0227   D130 FE 61       UPPER:	CP	'a'			;check for letters in the range of 'a' to 'z'.
0228   D132 D8          		RET	C
0229   D133 FE 7B       		CP	'{'
0230   D135 D0          		RET	NC
0231   D136 E6 5F       		AND	5FH			;convert it if found.
0232   D138 C9          		RET	
0233   D139             ;
0234   D139             ;   Routine to get a line of input. We must check to see if the
0235   D139             ; user is in (BATCH) mode. If so, then read the input from file
0236   D139             ; ($$$.SUB). At the end, reset to console input.
0237   D139             ;
0238   D139 3A AB D7    GETINP:	LD	A,(BATCH)		;if =0, then use console input.
0239   D13C B7          		OR	A
0240   D13D CA 96 D1    		JP	Z,GETINP1
0241   D140             ;
0242   D140             ;   Use the submit file ($$$.sub) which is prepared by a
0243   D140             ; SUBMIT run. It must be on drive (A) and it will be deleted
0244   D140             ; if and error occures (like eof).
0245   D140             ;
0246   D140 3A EF D7    		LD	A,(CDRIVE)		;select drive 0 if need be.
0247   D143 B7          		OR	A
0248   D144 3E 00       		LD	A,0			;always use drive A for submit.
0249   D146 C4 BD D0    		CALL	NZ,DSKSEL		;select it if required.
0250   D149 11 AC D7    		LD	DE,BATCHFCB
0251   D14C CD CB D0    		CALL	OPEN			;look for it.
0252   D14F CA 96 D1    		JP	Z,GETINP1		;if not there, use normal input.
0253   D152 3A BB D7    		LD	A,(BATCHFCB+15)	;get last record number+1.
0254   D155 3D          		DEC	A
0255   D156 32 CC D7    		LD	(BATCHFCB+32),A
0256   D159 11 AC D7    		LD	DE,BATCHFCB
0257   D15C CD F9 D0    		CALL	RDREC			;read last record.
0258   D15F C2 96 D1    		JP	NZ,GETINP1		;quit on end of file.
0259   D162             ;
0260   D162             ;   Move this record into input buffer.
0261   D162             ;
0262   D162 11 07 D0    		LD	DE,INBUFF+1
0263   D165 21 80 00    		LD	HL,TBUFF		;data was read into buffer here.
0264   D168 06 80       		LD	B,128			;all 128 characters may be used.
0265   D16A CD 42 D4    		CALL	HL2DE			;(HL) to (DE), (B) bytes.
0266   D16D 21 BA D7    	LD	HL,BATCHFCB+14
0267   D170 36 00       	LD	(HL),0		;zero out the 's2' byte.
0268   D172 23          	INC	HL			;and decrement the record count.
0269   D173 35          	DEC	(HL)
0270   D174 11 AC D7    	LD	DE,BATCHFCB	;close the batch file now.
0271   D177 CD DA D0    	CALL	CLOSE
0272   D17A CA 96 D1    	JP	Z,GETINP1		;quit on an error.
0273   D17D 3A EF D7    	LD	A,(CDRIVE)		;re-select previous drive if need be.
0274   D180 B7          	OR	A
0275   D181 C4 BD D0    	CALL	NZ,DSKSEL		;don't do needless selects.
0276   D184             ;
0277   D184             ;   Print line just read on console.
0278   D184             ;
0279   D184 21 08 D0    	LD	HL,INBUFF+2
0280   D187 CD AC D0    	CALL	PLINE2
0281   D18A CD C2 D1    	CALL	CHKCON		;check console, quit on a key.
0282   D18D CA A7 D1    	JP	Z,GETINP2		;jump if no key is pressed.
0283   D190             ;
0284   D190             ;   Terminate the submit job on any keyboard input. Delete this
0285   D190             ; file such that it is not re-started and jump to normal keyboard
0286   D190             ; input section.
0287   D190             ;
0288   D190 CD DD D1    	CALL	DELBATCH		;delete the batch file.
0289   D193 C3 82 D3    	JP	CMMND1		;and restart command input.
0290   D196             ;
0291   D196             ;   Get here for normal keyboard input. Delete the submit file
0292   D196             ; incase there was one.
0293   D196             ;
0294   D196 CD DD D1    GETINP1:	CALL	DELBATCH		;delete file ($$$.sub).
0295   D199 CD 1A D1    	CALL	SETCDRV		;reset active disk.
0296   D19C 0E 0A       	LD	C,10			;get line from console device.
0297   D19E 11 06 D0    	LD	DE,INBUFF
0298   D1A1 CD 05 00    	CALL	ENTRY
0299   D1A4 CD 29 D1    	CALL	MOVECD		;reset current drive (again).
0300   D1A7             ;
0301   D1A7             ;   Convert input line to upper case.
0302   D1A7             ;
0303   D1A7 21 07 D0    GETINP2:	LD	HL,INBUFF+1
0304   D1AA 46          		LD	B,(HL)		;(B)=character counter.
0305   D1AB 23          GETINP3:	INC	HL
0306   D1AC 78          	LD	A,B			;end of the line?
0307   D1AD B7          	OR	A
0308   D1AE CA BA D1    	JP	Z,GETINP4
0309   D1B1 7E          	LD	A,(HL)		;convert to upper case.
0310   D1B2 CD 30 D1    	CALL	UPPER
0311   D1B5 77          	LD	(HL),A
0312   D1B6 05          	DEC	B			;adjust character count.
0313   D1B7 C3 AB D1    	JP	GETINP3
0314   D1BA 77          GETINP4:	LD	(HL),A		;add trailing null.
0315   D1BB 21 08 D0    	LD	HL,INBUFF+2
0316   D1BE 22 88 D0    	LD	(INPOINT),HL	;reset input line pointer.
0317   D1C1 C9          	RET	
0318   D1C2             ;
0319   D1C2             ;   Routine to check the console for a key pressed. The zero
0320   D1C2             ; flag is set is none, else the character is returned in (A).
0321   D1C2             ;
0322   D1C2 0E 0B       CHKCON:	LD	C,11			;check console.
0323   D1C4 CD 05 00    	CALL	ENTRY
0324   D1C7 B7          	OR	A
0325   D1C8 C8          	RET	Z			;return if nothing.
0326   D1C9 0E 01       	LD	C,1			;else get character.
0327   D1CB CD 05 00    	CALL	ENTRY
0328   D1CE B7          	OR	A			;clear zero flag and return.
0329   D1CF C9          	RET	
0330   D1D0             ;
0331   D1D0             ;   Routine to get the currently active drive number.
0332   D1D0             ;
0333   D1D0 0E 19       GETDSK:	LD	C,25
0334   D1D2 C3 05 00    		JP	ENTRY
0335   D1D5             ;
0336   D1D5             ;   Set the stabdard dma address.
0337   D1D5             ;
0338   D1D5 11 80 00    STDDMA:	LD	DE,TBUFF
0339   D1D8             ;
0340   D1D8             ;   Routine to set the dma address to (DE).
0341   D1D8             ;
0342   D1D8 0E 1A       DMASET:	LD	C,26
0343   D1DA C3 05 00    		JP	ENTRY
0344   D1DD             ;
0345   D1DD             ;  Delete the batch file created by SUBMIT.
0346   D1DD             ;
0347   D1DD 21 AB D7    DELBATCH: 	LD	HL,BATCH		;is batch active?
0348   D1E0 7E          	LD	A,(HL)
0349   D1E1 B7          	OR	A
0350   D1E2 C8          	RET	Z
0351   D1E3 36 00       	LD	(HL),0		;yes, de-activate it.
0352   D1E5 AF          	XOR	A
0353   D1E6 CD BD D0    	CALL	DSKSEL		;select drive 0 for sure.
0354   D1E9 11 AC D7    	LD	DE,BATCHFCB	;and delete this file.
0355   D1EC CD EF D0    	CALL	DELETE
0356   D1EF 3A EF D7    	LD	A,(CDRIVE)		;reset current drive.
0357   D1F2 C3 BD D0    	JP	DSKSEL
0358   D1F5             ;
0359   D1F5             ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
0360   D1F5             ; the same or we halt....
0361   D1F5             ;
0362   D1F5 11 28 D3    VERIFY:	LD	DE,PATTRN1		;these are the serial number bytes.
0363   D1F8 21 00 D8    	LD	HL,PATTRN2		;ditto, but how could they be different?
0364   D1FB 06 06       	LD	B,6			;6 bytes each.
0365   D1FD 1A          VERIFY1:	LD	A,(DE)
0366   D1FE BE          	CP	(HL)
0367   D1FF C2 CF D3    	JP	NZ,HALT		;jump to halt routine.
0368   D202 13          	INC	DE
0369   D203 23          	INC	HL
0370   D204 05          	DEC	B
0371   D205 C2 FD D1    	JP	NZ,VERIFY1
0372   D208 C9          	RET	
0373   D209             ;
0374   D209             ;   Print back file name with a '?' to indicate a syntax error.
0375   D209             ;
0376   D209 CD 98 D0    SYNERR:	CALL	CRLF			;end current line.
0377   D20C 2A 8A D0    		LD	HL,(NAMEPNT)	;this points to name in error.
0378   D20F 7E          SYNERR1:	LD	A,(HL)		;print it until a space or null is found.
0379   D210 FE 20       	CP	' '
0380   D212 CA 22 D2    	JP	Z,SYNERR2
0381   D215 B7          	OR	A
0382   D216 CA 22 D2    	JP	Z,SYNERR2
0383   D219 E5          	PUSH	HL
0384   D21A CD 8C D0    	CALL	PRINT
0385   D21D E1          	POP	HL
0386   D21E 23          	INC	HL
0387   D21F C3 0F D2    	JP	SYNERR1
0388   D222 3E 3F       SYNERR2:	LD	A,'?'			;add trailing '?'.
0389   D224 CD 8C D0    	CALL	PRINT
0390   D227 CD 98 D0    	CALL	CRLF
0391   D22A CD DD D1    	CALL	DELBATCH		;delete any batch file.
0392   D22D C3 82 D3    	JP	CMMND1		;and restart from console input.
0393   D230             ;
0394   D230             ;   Check character at (DE) for legal command input. Note that the
0395   D230             ; zero flag is set if the character is a delimiter.
0396   D230             ;
0397   D230 1A          CHECK:	LD	A,(DE)
0398   D231 B7          	OR	A
0399   D232 C8          	RET	Z
0400   D233 FE 20       	CP	' '			;control characters are not legal here.
0401   D235 DA 09 D2    	JP	C,SYNERR
0402   D238 C8          	RET	Z			;check for valid delimiter.
0403   D239 FE 3D       	CP	'='
0404   D23B C8          	RET	Z
0405   D23C FE 5F       	CP	'_'
0406   D23E C8          	RET	Z
0407   D23F FE 2E       	CP	'.'
0408   D241 C8          	RET	Z
0409   D242 FE 3A       	CP	':'
0410   D244 C8          	RET	Z
0411   D245 FE 3B       	CP	03BH ; ';'
0412   D247 C8          	RET	Z
0413   D248 FE 3C       	CP	'<'
0414   D24A C8          	RET	Z
0415   D24B FE 3E       	CP	'>'
0416   D24D C8          	RET	Z
0417   D24E C9          	RET	
0418   D24F             ;
0419   D24F             ;   Get the next non-blank character from (DE).
0420   D24F             ;
0421   D24F 1A          NONBLANK: 	LD	A,(DE)
0422   D250 B7          	OR	A			;string ends with a null.
0423   D251 C8          	RET	Z
0424   D252 FE 20       	CP	' '
0425   D254 C0          	RET	NZ
0426   D255 13          	INC	DE
0427   D256 C3 4F D2    	JP	NONBLANK
0428   D259             ;
0429   D259             ;   Add (HL)=(HL)+(A)
0430   D259             ;
0431   D259 85          ADDHL:	ADD	A,L
0432   D25A 6F          	LD	L,A
0433   D25B D0          	RET	NC			;take care of any carry.
0434   D25C 24          	INC	H
0435   D25D C9          	RET	
0436   D25E             ;
0437   D25E             ;   Convert the first name in (FCB).
0438   D25E             ;
0439   D25E 3E 00       CONVFST:	LD	A,0
0440   D260             ;
0441   D260             ;   Format a file name (convert * to '?', etc.). On return,
0442   D260             ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
0443   D260             ; the position within the fcb for the name (either 0 or 16).
0444   D260             ;
0445   D260 21 CD D7    CONVERT:	LD	HL,FCB
0446   D263 CD 59 D2    	CALL	ADDHL
0447   D266 E5          	PUSH	HL
0448   D267 E5          	PUSH	HL
0449   D268 AF          	XOR	A
0450   D269 32 F0 D7    	LD	(CHGDRV),A		;initialize drive change flag.
0451   D26C 2A 88 D0    	LD	HL,(INPOINT)	;set (HL) as pointer into input line.
0452   D26F EB          	EX	DE,HL
0453   D270 CD 4F D2    	CALL	NONBLANK		;get next non-blank character.
0454   D273 EB          	EX	DE,HL
0455   D274 22 8A D0    	LD	(NAMEPNT),HL	;save pointer here for any error message.
0456   D277 EB          	EX	DE,HL
0457   D278 E1          	POP	HL
0458   D279 1A          	LD	A,(DE)		;get first character.
0459   D27A B7          	OR	A
0460   D27B CA 89 D2    	JP	Z,CONVRT1
0461   D27E DE 40       	SBC	A,'A'-1		;might be a drive name, convert to binary.
0462   D280 47          	LD	B,A			;and save.
0463   D281 13          	INC	DE			;check next character for a ':'.
0464   D282 1A          	LD	A,(DE)
0465   D283 FE 3A       	CP	':'
0466   D285 CA 90 D2    	JP	Z,CONVRT2
0467   D288 1B          	DEC	DE			;nope, move pointer back to the start of the line.
0468   D289 3A EF D7    CONVRT1:	LD	A,(CDRIVE)
0469   D28C 77          	LD	(HL),A
0470   D28D C3 96 D2    	JP	CONVRT3
0471   D290 78          CONVRT2:	LD	A,B
0472   D291 32 F0 D7    	LD	(CHGDRV),A		;set change in drives flag.
0473   D294 70          	LD	(HL),B
0474   D295 13          	INC	DE
0475   D296             ;
0476   D296             ;   Convert the basic file name.
0477   D296             ;
0478   D296 06 08       CONVRT3:	LD	B,08H
0479   D298 CD 30 D2    CONVRT4:	CALL	CHECK
0480   D29B CA B9 D2    	JP	Z,CONVRT8
0481   D29E 23          	INC	HL
0482   D29F FE 2A       	CP	'*'			;note that an '*' will fill the remaining
0483   D2A1 C2 A9 D2    	JP	NZ,CONVRT5		;field with '?'.
0484   D2A4 36 3F       	LD	(HL),'?'
0485   D2A6 C3 AB D2    	JP	CONVRT6
0486   D2A9 77          CONVRT5:	LD	(HL),A
0487   D2AA 13          		INC	DE
0488   D2AB 05          CONVRT6:	DEC	B
0489   D2AC C2 98 D2    		JP	NZ,CONVRT4
0490   D2AF CD 30 D2    CONVRT7:	CALL	CHECK			;get next delimiter.
0491   D2B2 CA C0 D2    	JP	Z,GETEXT
0492   D2B5 13          	INC	DE
0493   D2B6 C3 AF D2    	JP	CONVRT7
0494   D2B9 23          CONVRT8:	INC	HL			;blank fill the file name.
0495   D2BA 36 20       	LD	(HL),' '
0496   D2BC 05          	DEC	B
0497   D2BD C2 B9 D2    	JP	NZ,CONVRT8
0498   D2C0             ;
0499   D2C0             ;   Get the extension and convert it.
0500   D2C0             ;
0501   D2C0 06 03       GETEXT:	LD	B,03H
0502   D2C2 FE 2E       		CP	'.'
0503   D2C4 C2 E9 D2    		JP	NZ,GETEXT5
0504   D2C7 13          		INC	DE
0505   D2C8 CD 30 D2    GETEXT1:	CALL	CHECK
0506   D2CB CA E9 D2    	JP	Z,GETEXT5
0507   D2CE 23          	INC	HL
0508   D2CF FE 2A       	CP	'*'
0509   D2D1 C2 D9 D2    	JP	NZ,GETEXT2
0510   D2D4 36 3F       	LD	(HL),'?'
0511   D2D6 C3 DB D2    	JP	GETEXT3
0512   D2D9 77          GETEXT2:	LD	(HL),A
0513   D2DA 13          		INC	DE
0514   D2DB 05          GETEXT3:	DEC	B
0515   D2DC C2 C8 D2    		JP	NZ,GETEXT1
0516   D2DF CD 30 D2    GETEXT4:	CALL	CHECK
0517   D2E2 CA F0 D2    	JP	Z,GETEXT6
0518   D2E5 13          	INC	DE
0519   D2E6 C3 DF D2    	JP	GETEXT4
0520   D2E9 23          GETEXT5:	INC	HL
0521   D2EA 36 20       	LD	(HL),' '
0522   D2EC 05          	DEC	B
0523   D2ED C2 E9 D2    	JP	NZ,GETEXT5
0524   D2F0 06 03       GETEXT6:	LD	B,3
0525   D2F2 23          GETEXT7:	INC	HL
0526   D2F3 36 00       	LD	(HL),0
0527   D2F5 05          	DEC	B
0528   D2F6 C2 F2 D2    	JP	NZ,GETEXT7
0529   D2F9 EB          	EX	DE,HL
0530   D2FA 22 88 D0    	LD	(INPOINT),HL	;save input line pointer.
0531   D2FD E1          	POP	HL
0532   D2FE             ;
0533   D2FE             ;   Check to see if this is an ambigeous file name specification.
0534   D2FE             ; Set the (A) register to non zero if it is.
0535   D2FE             ;
0536   D2FE 01 0B 00    		LD	BC,11			;set name length.
0537   D301 23          GETEXT8:	INC	HL
0538   D302 7E          	LD	A,(HL)
0539   D303 FE 3F       	CP	'?'			;any question marks?
0540   D305 C2 09 D3    	JP	NZ,GETEXT9
0541   D308 04          	INC	B			;count them.
0542   D309 0D          GETEXT9:	DEC	C
0543   D30A C2 01 D3    	JP	NZ,GETEXT8
0544   D30D 78          	LD	A,B
0545   D30E B7          	OR	A
0546   D30F C9          	RET	
0547   D310             ;
0548   D310             ;   CP/M command table. Note commands can be either 3 or 4 characters long.
0549   D310             ;
0550   D310             NUMCMDS 	.EQU	6			;number of commands
0551   D310 44 49 52 20 CMDTBL:	.TEXT	"DIR "
0552   D314 45 52 41 20 	.TEXT	"ERA "
0553   D318 54 59 50 45 	.TEXT	"TYPE"
0554   D31C 53 41 56 45 	.TEXT	"SAVE"
0555   D320 52 45 4E 20 	.TEXT	"REN "
0556   D324 55 53 45 52 	.TEXT	"USER"
0557   D328             ;
0558   D328             ;   The following six bytes must agree with those at (PATTRN2)
0559   D328             ; or cp/m will HALT. Why?
0560   D328             ;
0561   D328 00 16 00 00 PATTRN1:	.DB	0,22,0,0,0,0	;(* serial number bytes *).
0561   D32C 00 00 
0562   D32E             ;
0563   D32E             ;   Search the command table for a match with what has just
0564   D32E             ; been entered. If a match is found, then we jump to the
0565   D32E             ; proper section. Else jump to (UNKNOWN).
0566   D32E             ; On return, the (C) register is set to the command number
0567   D32E             ; that matched (or NUMCMDS+1 if no match).
0568   D32E             ;
0569   D32E 21 10 D3    SEARCH:	LD	HL,CMDTBL
0570   D331 0E 00       		LD	C,0
0571   D333 79          SEARCH1:	LD	A,C
0572   D334 FE 06       	CP	NUMCMDS		;this commands exists.
0573   D336 D0          	RET	NC
0574   D337 11 CE D7    	LD	DE,FCB+1		;check this one.
0575   D33A 06 04       	LD	B,4			;max command length.
0576   D33C 1A          SEARCH2:	LD	A,(DE)	
0577   D33D BE          	CP	(HL)
0578   D33E C2 4F D3    	JP	NZ,SEARCH3		;not a match.
0579   D341 13          	INC	DE
0580   D342 23          	INC	HL
0581   D343 05          	DEC	B
0582   D344 C2 3C D3    	JP	NZ,SEARCH2
0583   D347 1A          	LD	A,(DE)		;allow a 3 character command to match.
0584   D348 FE 20       	CP	' '
0585   D34A C2 54 D3    	JP	NZ,SEARCH4
0586   D34D 79          	LD	A,C			;set return register for this command.
0587   D34E C9          	RET	
0588   D34F 23          SEARCH3:	INC	HL
0589   D350 05          		DEC	B
0590   D351 C2 4F D3    		JP	NZ,SEARCH3
0591   D354 0C          SEARCH4:	INC	C
0592   D355 C3 33 D3    		JP	SEARCH1
0593   D358             ;
0594   D358             ;   Set the input buffer to empty and then start the command
0595   D358             ; processor (ccp).
0596   D358             ;
0597   D358 AF          CLEARBUF: 	XOR	A
0598   D359 32 07 D0    		LD	(INBUFF+1),A	;second byte is actual length.
0599   D35C             ;
0600   D35C             ;**************************************************************
0601   D35C             ;*
0602   D35C             ;*
0603   D35C             ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
0604   D35C             ;*
0605   D35C             ;**************************************************************
0606   D35C             ;*
0607   D35C 31 AB D7    COMMAND:	LD	SP,CCPSTACK	;setup stack area.
0608   D35F C5          	PUSH	BC			;note that (C) should be equal to:
0609   D360 79          	LD	A,C			;(uuuudddd) where 'uuuu' is the user number
0610   D361 1F          	RRA				;and 'dddd' is the drive number.
0611   D362 1F          	RRA	
0612   D363 1F          	RRA	
0613   D364 1F          	RRA	
0614   D365 E6 0F       	AND	0FH			;isolate the user number.
0615   D367 5F          	LD	E,A
0616   D368 CD 15 D1    	CALL	GETSETUC		;and set it.
0617   D36B CD B8 D0    	CALL	RESDSK		;reset the disk system.
0618   D36E 32 AB D7    	LD	(BATCH),A		;clear batch mode flag.
0619   D371 C1          	POP	BC
0620   D372 79          	LD	A,C
0621   D373 E6 0F       	AND	0FH			;isolate the drive number.
0622   D375 32 EF D7    	LD	(CDRIVE),A		;and save.
0623   D378 CD BD D0    	CALL	DSKSEL		;...and select.
0624   D37B 3A 07 D0    	LD	A,(INBUFF+1)
0625   D37E B7          	OR	A			;anything in input buffer already?
0626   D37F C2 98 D3    	JP	NZ,CMMND2		;yes, we just process it.
0627   D382             ;
0628   D382             ;   Entry point to get a command line from the console.
0629   D382             ;
0630   D382 31 AB D7    CMMND1:	LD	SP,CCPSTACK	;set stack straight.
0631   D385 CD 98 D0    	CALL	CRLF			;start a new line on the screen.
0632   D388 CD D0 D1    	CALL	GETDSK		;get current drive.
0633   D38B C6 41       	ADD	A,'A'
0634   D38D CD 8C D0    	CALL	PRINT			;print current drive.
0635   D390 3E 3E       	LD	A,'>'
0636   D392 CD 8C D0    	CALL	PRINT			;and add prompt.
0637   D395 CD 39 D1    	CALL	GETINP		;get line from user.
0638   D398             ;
0639   D398             ;   Process command line here.
0640   D398             ;
0641   D398 11 80 00    CMMND2:	LD	DE,TBUFF
0642   D39B CD D8 D1    	CALL	DMASET		;set standard dma address.
0643   D39E CD D0 D1    	CALL	GETDSK
0644   D3A1 32 EF D7    	LD	(CDRIVE),A		;set current drive.
0645   D3A4 CD 5E D2    	CALL	CONVFST		;convert name typed in.
0646   D3A7 C4 09 D2    	CALL	NZ,SYNERR		;wild cards are not allowed.
0647   D3AA 3A F0 D7    	LD	A,(CHGDRV)		;if a change in drives was indicated,
0648   D3AD B7          	OR	A			;then treat this as an unknown command
0649   D3AE C2 A5 D6    	JP	NZ,UNKNOWN		;which gets executed.
0650   D3B1 CD 2E D3    	CALL	SEARCH		;else search command table for a match.
0651   D3B4             ;
0652   D3B4             ;   Note that an unknown command returns
0653   D3B4             ; with (A) pointing to the last address
0654   D3B4             ; in our table which is (UNKNOWN).
0655   D3B4             ;
0656   D3B4 21 C1 D3    	LD	HL,CMDADR		;now, look thru our address table for command (A).
0657   D3B7 5F          	LD	E,A			;set (DE) to command number.
0658   D3B8 16 00       	LD	D,0
0659   D3BA 19          	ADD	HL,DE
0660   D3BB 19          	ADD	HL,DE			;(HL)=(CMDADR)+2*(command number).
0661   D3BC 7E          	LD	A,(HL)		;now pick out this address.
0662   D3BD 23          	INC	HL
0663   D3BE 66          	LD	H,(HL)
0664   D3BF 6F          	LD	L,A
0665   D3C0 E9          	JP	(HL)			;now execute it.
0666   D3C1             ;
0667   D3C1             ;   CP/M command address table.
0668   D3C1             ;
0669   D3C1 77 D4 1F D5 CMDADR:	.DW	DIRECT,ERASE,TYPE,SAVE
0669   D3C5 5D D5 AD D5 
0670   D3C9 10 D6 8E D6 		.DW	RENAME,USER,UNKNOWN
0670   D3CD A5 D6 
0671   D3CF             ;
0672   D3CF             ;   Halt the system. Reason for this is unknown at present.
0673   D3CF             ;
0674   D3CF 21 F3 76    HALT:		LD	HL,76F3H		;'DI HLT' instructions.
0675   D3D2 22 00 D0    	LD	(CBASE),HL
0676   D3D5 21 00 D0    	LD	HL,CBASE
0677   D3D8 E9          	JP	(HL)
0678   D3D9             ;
0679   D3D9             ;   Read error while TYPEing a file.
0680   D3D9             ;
0681   D3D9 01 DF D3    RDERROR:	LD	BC,RDERR
0682   D3DC C3 A7 D0    		JP	PLINE
0683   D3DF 52 65 61 64 RDERR:	.TEXT	"Read error"
0683   D3E3 20 65 72 72 
0683   D3E7 6F 72 
0684   D3E9 00          		.DB	0
0685   D3EA             ;
0686   D3EA             ;   Required file was not located.
0687   D3EA             ;
0688   D3EA 01 F0 D3    NONE:		LD	BC,NOFILE
0689   D3ED C3 A7 D0    		JP	PLINE
0690   D3F0 4E 6F 20 66 NOFILE:	.TEXT	"No file"
0690   D3F4 69 6C 65 
0691   D3F7 00          		.DB	0
0692   D3F8             ;
0693   D3F8             ;   Decode a command of the form 'A>filename number{ filename}.
0694   D3F8             ; Note that a drive specifier is not allowed on the first file
0695   D3F8             ; name. On return, the number is in register (A). Any error
0696   D3F8             ; causes 'filename?' to be printed and the command is aborted.
0697   D3F8             ;
0698   D3F8 CD 5E D2    DECODE:	CALL	CONVFST		;convert filename.
0699   D3FB 3A F0 D7    	LD	A,(CHGDRV)		;do not allow a drive to be specified.
0700   D3FE B7          	OR	A
0701   D3FF C2 09 D2    	JP	NZ,SYNERR
0702   D402 21 CE D7    	LD	HL,FCB+1		;convert number now.
0703   D405 01 0B 00    	LD	BC,11			;(B)=sum register, (C)=max digit count.
0704   D408 7E          DECODE1:	LD	A,(HL)
0705   D409 FE 20       	CP	' '			;a space terminates the numeral.
0706   D40B CA 33 D4    	JP	Z,DECODE3
0707   D40E 23          	INC	HL
0708   D40F D6 30       	SUB	'0'			;make binary from ascii.
0709   D411 FE 0A       	CP	10			;legal digit?
0710   D413 D2 09 D2    	JP	NC,SYNERR
0711   D416 57          	LD	D,A			;yes, save it in (D).
0712   D417 78          	LD	A,B			;compute (B)=(B)*10 and check for overflow.
0713   D418 E6 E0       	AND	0E0H
0714   D41A C2 09 D2    	JP	NZ,SYNERR
0715   D41D 78          	LD	A,B
0716   D41E 07          	RLCA	
0717   D41F 07          	RLCA	
0718   D420 07          	RLCA				;(A)=(B)*8
0719   D421 80          	ADD	A,B			;.......*9
0720   D422 DA 09 D2    	JP	C,SYNERR
0721   D425 80          	ADD	A,B			;.......*10
0722   D426 DA 09 D2    	JP	C,SYNERR
0723   D429 82          	ADD	A,D			;add in new digit now.
0724   D42A DA 09 D2    DECODE2:	JP	C,SYNERR
0725   D42D 47          	LD	B,A			;and save result.
0726   D42E 0D          	DEC	C			;only look at 11 digits.
0727   D42F C2 08 D4    	JP	NZ,DECODE1
0728   D432 C9          	RET	
0729   D433 7E          DECODE3:	LD	A,(HL)		;spaces must follow (why?).
0730   D434 FE 20       	CP	' '
0731   D436 C2 09 D2    	JP	NZ,SYNERR
0732   D439 23          	INC	HL
0733   D43A 0D          DECODE4:	DEC	C
0734   D43B C2 33 D4    	JP	NZ,DECODE3
0735   D43E 78          	LD	A,B			;set (A)=the numeric value entered.
0736   D43F C9          	RET	
0737   D440             ;
0738   D440             ;   Move 3 bytes from (HL) to (DE). Note that there is only
0739   D440             ; one reference to this at (A2D5h).
0740   D440             ;
0741   D440 06 03       MOVE3:	LD	B,3
0742   D442             ;
0743   D442             ;   Move (B) bytes from (HL) to (DE).
0744   D442             ;
0745   D442 7E          HL2DE:	LD	A,(HL)
0746   D443 12          	LD	(DE),A
0747   D444 23          	INC	HL
0748   D445 13          	INC	DE
0749   D446 05          	DEC	B
0750   D447 C2 42 D4    	JP	NZ,HL2DE
0751   D44A C9          	RET	
0752   D44B             ;
0753   D44B             ;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
0754   D44B             ;
0755   D44B 21 80 00    EXTRACT:	LD	HL,TBUFF
0756   D44E 81          	ADD	A,C
0757   D44F CD 59 D2    	CALL	ADDHL
0758   D452 7E          	LD	A,(HL)
0759   D453 C9          	RET	
0760   D454             ;
0761   D454             ;  Check drive specified. If it means a change, then the new
0762   D454             ; drive will be selected. In any case, the drive byte of the
0763   D454             ; fcb will be set to null (means use current drive).
0764   D454             ;
0765   D454 AF          DSELECT:	XOR	A			;null out first byte of fcb.
0766   D455 32 CD D7    	LD	(FCB),A	
0767   D458 3A F0 D7    	LD	A,(CHGDRV)		;a drive change indicated?
0768   D45B B7          	OR	A
0769   D45C C8          	RET	Z
0770   D45D 3D          	DEC	A			;yes, is it the same as the current drive?
0771   D45E 21 EF D7    	LD	HL,CDRIVE
0772   D461 BE          	CP	(HL)
0773   D462 C8          	RET	Z
0774   D463 C3 BD D0    	JP	DSKSEL		;no. Select it then.
0775   D466             ;
0776   D466             ;   Check the drive selection and reset it to the previous
0777   D466             ; drive if it was changed for the preceeding command.
0778   D466             ;
0779   D466 3A F0 D7    RESETDR:	LD	A,(CHGDRV)		;drive change indicated?
0780   D469 B7          	OR	A
0781   D46A C8          	RET	Z
0782   D46B 3D          	DEC	A			;yes, was it a different drive?
0783   D46C 21 EF D7    	LD	HL,CDRIVE
0784   D46F BE          	CP	(HL)
0785   D470 C8          	RET	Z
0786   D471 3A EF D7    	LD	A,(CDRIVE)		;yes, re-select our old drive.
0787   D474 C3 BD D0    	JP	DSKSEL
0788   D477             ;
0789   D477             ;**************************************************************
0790   D477             ;*
0791   D477             ;*           D I R E C T O R Y   C O M M A N D
0792   D477             ;*
0793   D477             ;**************************************************************
0794   D477             ;
0795   D477 CD 5E D2    DIRECT:	CALL	CONVFST		;convert file name.
0796   D47A CD 54 D4    	CALL	DSELECT		;select indicated drive.
0797   D47D 21 CE D7    	LD	HL,FCB+1		;was any file indicated?
0798   D480 7E          	LD	A,(HL)
0799   D481 FE 20       	CP	' '
0800   D483 C2 8F D4    	JP	NZ,DIRECT2
0801   D486 06 0B       	LD	B,11			;no. Fill field with '?' - same as *.*.
0802   D488 36 3F       DIRECT1:	LD	(HL),'?'
0803   D48A 23          	INC	HL
0804   D48B 05          	DEC	B
0805   D48C C2 88 D4    	JP	NZ,DIRECT1
0806   D48F 1E 00       DIRECT2:	LD	E,0			;set initial cursor position.
0807   D491 D5          	PUSH	DE
0808   D492 CD E9 D0    	CALL	SRCHFCB		;get first file name.
0809   D495 CC EA D3    	CALL	Z,NONE		;none found at all?
0810   D498 CA 1B D5    DIRECT3:	JP	Z,DIRECT9		;terminate if no more names.
0811   D49B 3A EE D7    	LD	A,(RTNCODE)	;get file's position in segment (0-3).
0812   D49E 0F          	RRCA	
0813   D49F 0F          	RRCA	
0814   D4A0 0F          	RRCA	
0815   D4A1 E6 60       	AND	60H			;(A)=position*32
0816   D4A3 4F          	LD	C,A
0817   D4A4 3E 0A       	LD	A,10
0818   D4A6 CD 4B D4    	CALL	EXTRACT		;extract the tenth entry in fcb.
0819   D4A9 17          	RLA				;check system file status bit.
0820   D4AA DA 0F D5    	JP	C,DIRECT8		;we don't list them.
0821   D4AD D1          	POP	DE
0822   D4AE 7B          	LD	A,E			;bump name count.
0823   D4AF 1C          	INC	E
0824   D4B0 D5          	PUSH	DE
0825   D4B1 E6 03       	AND	03H			;at end of line?
0826   D4B3 F5          	PUSH	AF
0827   D4B4 C2 CC D4    	JP	NZ,DIRECT4
0828   D4B7 CD 98 D0    	CALL	CRLF			;yes, end this line and start another.
0829   D4BA C5          	PUSH	BC
0830   D4BB CD D0 D1    	CALL	GETDSK		;start line with ('A:').
0831   D4BE C1          	POP	BC
0832   D4BF C6 41       	ADD	A,'A'
0833   D4C1 CD 92 D0    	CALL	PRINTB
0834   D4C4 3E 3A       	LD	A,':'
0835   D4C6 CD 92 D0    	CALL	PRINTB
0836   D4C9 C3 D4 D4    	JP	DIRECT5
0837   D4CC CD A2 D0    DIRECT4:	CALL	SPACE			;add seperator between file names.
0838   D4CF 3E 3A       	LD	A,':'
0839   D4D1 CD 92 D0    	CALL	PRINTB
0840   D4D4 CD A2 D0    DIRECT5:	CALL	SPACE
0841   D4D7 06 01       		LD	B,1			;'extract' each file name character at a time.
0842   D4D9 78          DIRECT6:	LD	A,B
0843   D4DA CD 4B D4    	CALL	EXTRACT
0844   D4DD E6 7F       	AND	7FH			;strip bit 7 (status bit).
0845   D4DF FE 20       	CP	' '			;are we at the end of the name?
0846   D4E1 C2 F9 D4    	JP	NZ,DRECT65
0847   D4E4 F1          	POP	AF			;yes, don't print spaces at the end of a line.
0848   D4E5 F5          	PUSH	AF
0849   D4E6 FE 03       	CP	3
0850   D4E8 C2 F7 D4    	JP	NZ,DRECT63
0851   D4EB 3E 09       	LD	A,9			;first check for no extension.
0852   D4ED CD 4B D4    	CALL	EXTRACT
0853   D4F0 E6 7F       	AND	7FH
0854   D4F2 FE 20       	CP	' '
0855   D4F4 CA 0E D5    	JP	Z,DIRECT7		;don't print spaces.
0856   D4F7 3E 20       DRECT63:	LD	A,' '			;else print them.
0857   D4F9 CD 92 D0    DRECT65:	CALL	PRINTB
0858   D4FC 04          	INC	B			;bump to next character psoition.
0859   D4FD 78          	LD	A,B
0860   D4FE FE 0C       	CP	12			;end of the name?
0861   D500 D2 0E D5    	JP	NC,DIRECT7
0862   D503 FE 09       	CP	9			;nope, starting extension?
0863   D505 C2 D9 D4    	JP	NZ,DIRECT6
0864   D508 CD A2 D0    	CALL	SPACE			;yes, add seperating space.
0865   D50B C3 D9 D4    	JP	DIRECT6
0866   D50E F1          DIRECT7:	POP	AF			;get the next file name.
0867   D50F CD C2 D1    DIRECT8:	CALL	CHKCON		;first check console, quit on anything.
0868   D512 C2 1B D5    	JP	NZ,DIRECT9
0869   D515 CD E4 D0    	CALL	SRCHNXT		;get next name.
0870   D518 C3 98 D4    	JP	DIRECT3		;and continue with our list.
0871   D51B D1          DIRECT9:	POP	DE			;restore the stack and return to command level.
0872   D51C C3 86 D7    		JP	GETBACK
0873   D51F             ;
0874   D51F             ;**************************************************************
0875   D51F             ;*
0876   D51F             ;*                E R A S E   C O M M A N D
0877   D51F             ;*
0878   D51F             ;**************************************************************
0879   D51F             ;
0880   D51F CD 5E D2    ERASE:	CALL	CONVFST		;convert file name.
0881   D522 FE 0B       	CP	11			;was '*.*' entered?
0882   D524 C2 42 D5    	JP	NZ,ERASE1
0883   D527 01 52 D5    	LD	BC,YESNO		;yes, ask for confirmation.
0884   D52A CD A7 D0    	CALL	PLINE
0885   D52D CD 39 D1    	CALL	GETINP
0886   D530 21 07 D0    	LD	HL,INBUFF+1
0887   D533 35          	DEC	(HL)			;must be exactly 'y'.
0888   D534 C2 82 D3    	JP	NZ,CMMND1
0889   D537 23          	INC	HL
0890   D538 7E          	LD	A,(HL)
0891   D539 FE 59       	CP	'Y'
0892   D53B C2 82 D3    	JP	NZ,CMMND1
0893   D53E 23          	INC	HL
0894   D53F 22 88 D0    	LD	(INPOINT),HL	;save input line pointer.
0895   D542 CD 54 D4    ERASE1:	CALL	DSELECT		;select desired disk.
0896   D545 11 CD D7    	LD	DE,FCB
0897   D548 CD EF D0    	CALL	DELETE		;delete the file.
0898   D54B 3C          	INC	A
0899   D54C CC EA D3    	CALL	Z,NONE		;not there?
0900   D54F C3 86 D7    	JP	GETBACK		;return to command level now.
0901   D552 41 6C 6C 20 YESNO:	.TEXT	"All (y/n)?"
0901   D556 28 79 2F 6E 
0901   D55A 29 3F 
0902   D55C 00          		.DB	0
0903   D55D             ;
0904   D55D             ;**************************************************************
0905   D55D             ;*
0906   D55D             ;*            T Y P E   C O M M A N D
0907   D55D             ;*
0908   D55D             ;**************************************************************
0909   D55D             ;
0910   D55D CD 5E D2    TYPE:		CALL	CONVFST		;convert file name.
0911   D560 C2 09 D2    	JP	NZ,SYNERR		;wild cards not allowed.
0912   D563 CD 54 D4    	CALL	DSELECT		;select indicated drive.
0913   D566 CD D0 D0    	CALL	OPENFCB		;open the file.
0914   D569 CA A7 D5    	JP	Z,TYPE5		;not there?
0915   D56C CD 98 D0    	CALL	CRLF			;ok, start a new line on the screen.
0916   D56F 21 F1 D7    	LD	HL,NBYTES		;initialize byte counter.
0917   D572 36 FF       	LD	(HL),0FFH		;set to read first sector.
0918   D574 21 F1 D7    TYPE1:	LD	HL,NBYTES
0919   D577 7E          TYPE2:	LD	A,(HL)		;have we written the entire sector?
0920   D578 FE 80       	CP	128
0921   D57A DA 87 D5    	JP	C,TYPE3
0922   D57D E5          	PUSH	HL			;yes, read in the next one.
0923   D57E CD FE D0    	CALL	READFCB
0924   D581 E1          	POP	HL
0925   D582 C2 A0 D5    	JP	NZ,TYPE4		;end or error?
0926   D585 AF          	XOR	A			;ok, clear byte counter.
0927   D586 77          	LD	(HL),A
0928   D587 34          TYPE3:	INC	(HL)			;count this byte.
0929   D588 21 80 00    	LD	HL,TBUFF		;and get the (A)th one from the buffer (TBUFF).
0930   D58B CD 59 D2    	CALL	ADDHL
0931   D58E 7E          	LD	A,(HL)
0932   D58F FE 1A       	CP	CNTRLZ		;end of file mark?
0933   D591 CA 86 D7    	JP	Z,GETBACK
0934   D594 CD 8C D0    	CALL	PRINT			;no, print it.
0935   D597 CD C2 D1    	CALL	CHKCON		;check console, quit if anything ready.
0936   D59A C2 86 D7    	JP	NZ,GETBACK
0937   D59D C3 74 D5    	JP	TYPE1
0938   D5A0             ;
0939   D5A0             ;   Get here on an end of file or read error.
0940   D5A0             ;
0941   D5A0 3D          TYPE4:	DEC	A			;read error?
0942   D5A1 CA 86 D7    	JP	Z,GETBACK	
0943   D5A4 CD D9 D3    	CALL	RDERROR		;yes, print message.
0944   D5A7 CD 66 D4    TYPE5:	CALL	RESETDR		;and reset proper drive
0945   D5AA C3 09 D2    		JP	SYNERR		;now print file name with problem.
0946   D5AD             ;
0947   D5AD             ;**************************************************************
0948   D5AD             ;*
0949   D5AD             ;*            S A V E   C O M M A N D
0950   D5AD             ;*
0951   D5AD             ;**************************************************************
0952   D5AD             ;
0953   D5AD CD F8 D3    SAVE:		CALL	DECODE		;get numeric number that follows SAVE.
0954   D5B0 F5          	PUSH	AF			;save number of pages to write.
0955   D5B1 CD 5E D2    	CALL	CONVFST		;convert file name.
0956   D5B4 C2 09 D2    	JP	NZ,SYNERR		;wild cards not allowed.
0957   D5B7 CD 54 D4    	CALL	DSELECT		;select specified drive.
0958   D5BA 11 CD D7    	LD	DE,FCB		;now delete this file.
0959   D5BD D5          	PUSH	DE
0960   D5BE CD EF D0    	CALL	DELETE
0961   D5C1 D1          	POP	DE
0962   D5C2 CD 09 D1    	CALL	CREATE		;and create it again.
0963   D5C5 CA FB D5    	JP	Z,SAVE3		;can't create?
0964   D5C8 AF          	XOR	A			;clear record number byte.
0965   D5C9 32 ED D7    	LD	(FCB+32),A
0966   D5CC F1          	POP	AF			;convert pages to sectors.
0967   D5CD 6F          	LD	L,A
0968   D5CE 26 00       	LD	H,0
0969   D5D0 29          	ADD	HL,HL			;(HL)=number of sectors to write.
0970   D5D1 11 00 01    	LD	DE,TBASE		;and we start from here.
0971   D5D4 7C          SAVE1:	LD	A,H			;done yet?
0972   D5D5 B5          	OR	L
0973   D5D6 CA F1 D5    	JP	Z,SAVE2
0974   D5D9 2B          	DEC	HL			;nope, count this and compute the start
0975   D5DA E5          	PUSH	HL			;of the next 128 byte sector.
0976   D5DB 21 80 00    	LD	HL,128
0977   D5DE 19          	ADD	HL,DE
0978   D5DF E5          	PUSH	HL			;save it and set the transfer address.
0979   D5E0 CD D8 D1    	CALL	DMASET
0980   D5E3 11 CD D7    	LD	DE,FCB		;write out this sector now.
0981   D5E6 CD 04 D1    	CALL	WRTREC
0982   D5E9 D1          	POP	DE			;reset (DE) to the start of the last sector.
0983   D5EA E1          	POP	HL			;restore sector count.
0984   D5EB C2 FB D5    	JP	NZ,SAVE3		;write error?
0985   D5EE C3 D4 D5    	JP	SAVE1
0986   D5F1             ;
0987   D5F1             ;   Get here after writing all of the file.
0988   D5F1             ;
0989   D5F1 11 CD D7    SAVE2:	LD	DE,FCB		;now close the file.
0990   D5F4 CD DA D0    	CALL	CLOSE
0991   D5F7 3C          	INC	A			;did it close ok?
0992   D5F8 C2 01 D6    	JP	NZ,SAVE4
0993   D5FB             ;
0994   D5FB             ;   Print out error message (no space).
0995   D5FB             ;
0996   D5FB 01 07 D6    SAVE3:	LD	BC,NOSPACE
0997   D5FE CD A7 D0    		CALL	PLINE
0998   D601 CD D5 D1    SAVE4:	CALL	STDDMA		;reset the standard dma address.
0999   D604 C3 86 D7    		JP	GETBACK
1000   D607 4E 6F 20 73 NOSPACE:	.TEXT	"No space"
1000   D60B 70 61 63 65 
1001   D60F 00          		.DB	0
1002   D610             ;
1003   D610             ;**************************************************************
1004   D610             ;*
1005   D610             ;*           R E N A M E   C O M M A N D
1006   D610             ;*
1007   D610             ;**************************************************************
1008   D610             ;
1009   D610 CD 5E D2    RENAME:	CALL	CONVFST		;convert first file name.
1010   D613 C2 09 D2    	JP	NZ,SYNERR		;wild cards not allowed.
1011   D616 3A F0 D7    	LD	A,(CHGDRV)		;remember any change in drives specified.
1012   D619 F5          	PUSH	AF
1013   D61A CD 54 D4    	CALL	DSELECT		;and select this drive.
1014   D61D CD E9 D0    	CALL	SRCHFCB		;is this file present?
1015   D620 C2 79 D6    	JP	NZ,RENAME6		;yes, print error message.
1016   D623 21 CD D7    	LD	HL,FCB		;yes, move this name into second slot.
1017   D626 11 DD D7    	LD	DE,FCB+16
1018   D629 06 10       	LD	B,16
1019   D62B CD 42 D4    	CALL	HL2DE
1020   D62E 2A 88 D0    	LD	HL,(INPOINT)	;get input pointer.
1021   D631 EB          	EX	DE,HL
1022   D632 CD 4F D2    	CALL	NONBLANK		;get next non blank character.
1023   D635 FE 3D       	CP	'='			;only allow an '=' or '_' seperator.
1024   D637 CA 3F D6    	JP	Z,RENAME1
1025   D63A FE 5F       	CP	'_'
1026   D63C C2 73 D6    	JP	NZ,RENAME5
1027   D63F EB          RENAME1:	EX	DE,HL
1028   D640 23          	INC	HL			;ok, skip seperator.
1029   D641 22 88 D0    	LD	(INPOINT),HL	;save input line pointer.
1030   D644 CD 5E D2    	CALL	CONVFST		;convert this second file name now.
1031   D647 C2 73 D6    	JP	NZ,RENAME5		;again, no wild cards.
1032   D64A F1          	POP	AF			;if a drive was specified, then it
1033   D64B 47          	LD	B,A			;must be the same as before.
1034   D64C 21 F0 D7    	LD	HL,CHGDRV
1035   D64F 7E          	LD	A,(HL)
1036   D650 B7          	OR	A
1037   D651 CA 59 D6    	JP	Z,RENAME2
1038   D654 B8          	CP	B
1039   D655 70          	LD	(HL),B
1040   D656 C2 73 D6    	JP	NZ,RENAME5		;they were different, error.
1041   D659 70          RENAME2:	LD	(HL),B		;	reset as per the first file specification.
1042   D65A AF          	XOR	A
1043   D65B 32 CD D7    	LD	(FCB),A		;clear the drive byte of the fcb.
1044   D65E CD E9 D0    RENAME3:	CALL	SRCHFCB		;and go look for second file.
1045   D661 CA 6D D6    	JP	Z,RENAME4		;doesn't exist?
1046   D664 11 CD D7    	LD	DE,FCB
1047   D667 CD 0E D1    	CALL	RENAM			;ok, rename the file.
1048   D66A C3 86 D7    	JP	GETBACK
1049   D66D             ;
1050   D66D             ;   Process rename errors here.
1051   D66D             ;
1052   D66D CD EA D3    RENAME4:	CALL	NONE			;file not there.
1053   D670 C3 86 D7    		JP	GETBACK
1054   D673 CD 66 D4    RENAME5:	CALL	RESETDR		;bad command format.
1055   D676 C3 09 D2    		JP	SYNERR
1056   D679 01 82 D6    RENAME6:	LD	BC,EXISTS		;destination file already exists.
1057   D67C CD A7 D0    	CALL	PLINE
1058   D67F C3 86 D7    	JP	GETBACK
1059   D682 46 69 6C 65 EXISTS:	.TEXT	"File exists"
1059   D686 20 65 78 69 
1059   D68A 73 74 73 
1060   D68D 00          		.DB	0
1061   D68E             ;
1062   D68E             ;**************************************************************
1063   D68E             ;*
1064   D68E             ;*             U S E R   C O M M A N D
1065   D68E             ;*
1066   D68E             ;**************************************************************
1067   D68E             ;
1068   D68E CD F8 D3    USER:		CALL	DECODE		;get numeric value following command.
1069   D691 FE 10       	CP	16			;legal user number?
1070   D693 D2 09 D2    	JP	NC,SYNERR
1071   D696 5F          	LD	E,A			;yes but is there anything else?
1072   D697 3A CE D7    	LD	A,(FCB+1)
1073   D69A FE 20       	CP	' '
1074   D69C CA 09 D2    	JP	Z,SYNERR		;yes, that is not allowed.
1075   D69F CD 15 D1    	CALL	GETSETUC		;ok, set user code.
1076   D6A2 C3 89 D7    	JP	GETBACK1
1077   D6A5             ;
1078   D6A5             ;**************************************************************
1079   D6A5             ;*
1080   D6A5             ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
1081   D6A5             ;*
1082   D6A5             ;**************************************************************
1083   D6A5             ;
1084   D6A5 CD F5 D1    UNKNOWN:	CALL	VERIFY		;check for valid system (why?).
1085   D6A8 3A CE D7    	LD	A,(FCB+1)		;anything to execute?
1086   D6AB FE 20       	CP	' '
1087   D6AD C2 C4 D6    	JP	NZ,UNKWN1
1088   D6B0 3A F0 D7    	LD	A,(CHGDRV)		;nope, only a drive change?
1089   D6B3 B7          	OR	A
1090   D6B4 CA 89 D7    	JP	Z,GETBACK1		;neither???
1091   D6B7 3D          	DEC	A
1092   D6B8 32 EF D7    	LD	(CDRIVE),A		;ok, store new drive.
1093   D6BB CD 29 D1    	CALL	MOVECD		;set (TDRIVE) also.
1094   D6BE CD BD D0    	CALL	DSKSEL		;and select this drive.
1095   D6C1 C3 89 D7    	JP	GETBACK1		;then return.
1096   D6C4             ;
1097   D6C4             ;   Here a file name was typed. Prepare to execute it.
1098   D6C4             ;
1099   D6C4 11 D6 D7    UNKWN1:	LD	DE,FCB+9		;an extension specified?
1100   D6C7 1A          	LD	A,(DE)
1101   D6C8 FE 20       	CP	' '
1102   D6CA C2 09 D2    	JP	NZ,SYNERR		;yes, not allowed.
1103   D6CD D5          UNKWN2:	PUSH	DE
1104   D6CE CD 54 D4    	CALL	DSELECT		;select specified drive.
1105   D6D1 D1          	POP	DE
1106   D6D2 21 83 D7    	LD	HL,COMFILE		;set the extension to 'COM'.
1107   D6D5 CD 40 D4    	CALL	MOVE3
1108   D6D8 CD D0 D0    	CALL	OPENFCB		;and open this file.
1109   D6DB CA 6B D7    	JP	Z,UNKWN9		;not present?
1110   D6DE             ;
1111   D6DE             ;   Load in the program.
1112   D6DE             ;
1113   D6DE 21 00 01    		LD	HL,TBASE		;store the program starting here.
1114   D6E1 E5          UNKWN3:	PUSH	HL
1115   D6E2 EB          	EX	DE,HL
1116   D6E3 CD D8 D1    	CALL	DMASET		;set transfer address.
1117   D6E6 11 CD D7    	LD	DE,FCB		;and read the next record.
1118   D6E9 CD F9 D0    	CALL	RDREC
1119   D6EC C2 01 D7    	JP	NZ,UNKWN4		;end of file or read error?
1120   D6EF E1          	POP	HL			;nope, bump pointer for next sector.
1121   D6F0 11 80 00    	LD	DE,128
1122   D6F3 19          	ADD	HL,DE
1123   D6F4 11 00 D0    	LD	DE,CBASE		;enough room for the whole file?
1124   D6F7 7D          	LD	A,L
1125   D6F8 93          	SUB	E
1126   D6F9 7C          	LD	A,H
1127   D6FA 9A          	SBC	A,D
1128   D6FB D2 71 D7    	JP	NC,UNKWN0		;no, it can't fit.
1129   D6FE C3 E1 D6    	JP	UNKWN3
1130   D701             ;
1131   D701             ;   Get here after finished reading.
1132   D701             ;
1133   D701 E1          UNKWN4:	POP	HL
1134   D702 3D          	DEC	A			;normal end of file?
1135   D703 C2 71 D7    	JP	NZ,UNKWN0
1136   D706 CD 66 D4    	CALL	RESETDR		;yes, reset previous drive.
1137   D709 CD 5E D2    	CALL	CONVFST		;convert the first file name that follows
1138   D70C 21 F0 D7    	LD	HL,CHGDRV		;command name.
1139   D70F E5          	PUSH	HL
1140   D710 7E          	LD	A,(HL)		;set drive code in default fcb.
1141   D711 32 CD D7    	LD	(FCB),A
1142   D714 3E 10       	LD	A,16			;put second name 16 bytes later.
1143   D716 CD 60 D2    	CALL	CONVERT		;convert second file name.
1144   D719 E1          	POP	HL
1145   D71A 7E          	LD	A,(HL)		;and set the drive for this second file.
1146   D71B 32 DD D7    	LD	(FCB+16),A
1147   D71E AF          	XOR	A			;clear record byte in fcb.
1148   D71F 32 ED D7    	LD	(FCB+32),A
1149   D722 11 5C 00    	LD	DE,TFCB		;move it into place at(005Ch).
1150   D725 21 CD D7    	LD	HL,FCB
1151   D728 06 21       	LD	B,33
1152   D72A CD 42 D4    	CALL	HL2DE
1153   D72D 21 08 D0    	LD	HL,INBUFF+2	;now move the remainder of the input
1154   D730 7E          UNKWN5:	LD	A,(HL)		;line down to (0080h). Look for a non blank.
1155   D731 B7          	OR	A			;or a null.
1156   D732 CA 3E D7    	JP	Z,UNKWN6
1157   D735 FE 20       	CP	' '
1158   D737 CA 3E D7    	JP	Z,UNKWN6
1159   D73A 23          	INC	HL
1160   D73B C3 30 D7    	JP	UNKWN5
1161   D73E             ;
1162   D73E             ;   Do the line move now. It ends in a null byte.
1163   D73E             ;
1164   D73E 06 00       UNKWN6:	LD	B,0			;keep a character count.
1165   D740 11 81 00    		LD	DE,TBUFF+1		;data gets put here.
1166   D743 7E          UNKWN7:	LD	A,(HL)		;move it now.
1167   D744 12          	LD	(DE),A
1168   D745 B7          	OR	A
1169   D746 CA 4F D7    	JP	Z,UNKWN8
1170   D749 04          	INC	B
1171   D74A 23          	INC	HL
1172   D74B 13          	INC	DE
1173   D74C C3 43 D7    	JP	UNKWN7
1174   D74F 78          UNKWN8:	LD	A,B			;now store the character count.
1175   D750 32 80 00    	LD	(TBUFF),A
1176   D753 CD 98 D0    	CALL	CRLF			;clean up the screen.
1177   D756 CD D5 D1    	CALL	STDDMA		;set standard transfer address.
1178   D759 CD 1A D1    	CALL	SETCDRV		;reset current drive.
1179   D75C CD 00 01    	CALL	TBASE			;and execute the program.
1180   D75F             ;
1181   D75F             ;   Transiant programs return here (or reboot).
1182   D75F             ;
1183   D75F 31 AB D7    	LD	SP,BATCH		;set stack first off.
1184   D762 CD 29 D1    	CALL	MOVECD		;move current drive into place (TDRIVE).
1185   D765 CD BD D0    	CALL	DSKSEL		;and reselect it.
1186   D768 C3 82 D3    	JP	CMMND1		;back to comand mode.
1187   D76B             ;
1188   D76B             ;   Get here if some error occured.
1189   D76B             ;
1190   D76B CD 66 D4    UNKWN9:	CALL	RESETDR		;inproper format.
1191   D76E C3 09 D2    		JP	SYNERR
1192   D771 01 7A D7    UNKWN0:	LD	BC,BADLOAD		;read error or won't fit.
1193   D774 CD A7 D0    	CALL	PLINE
1194   D777 C3 86 D7    	JP	GETBACK
1195   D77A 42 61 64 20 BADLOAD:	.TEXT	"Bad load"
1195   D77E 6C 6F 61 64 
1196   D782 00          		.DB	0
1197   D783 43 4F 4D    COMFILE:	.TEXT	"COM"			;command file extension.
1198   D786             ;
1199   D786             ;   Get here to return to command level. We will reset the
1200   D786             ; previous active drive and then either return to command
1201   D786             ; level directly or print error message and then return.
1202   D786             ;
1203   D786 CD 66 D4    GETBACK:	CALL	RESETDR		;reset previous drive.
1204   D789 CD 5E D2    GETBACK1: 	CALL	CONVFST		;convert first name in (FCB).
1205   D78C 3A CE D7    	LD	A,(FCB+1)		;if this was just a drive change request,
1206   D78F D6 20       	SUB	' '			;make sure it was valid.
1207   D791 21 F0 D7    	LD	HL,CHGDRV
1208   D794 B6          	OR	(HL)
1209   D795 C2 09 D2    	JP	NZ,SYNERR
1210   D798 C3 82 D3    	JP	CMMND1		;ok, return to command level.
1211   D79B             ;
1212   D79B             ;   ccp stack area.
1213   D79B             ;
1214   D79B 00 00 00 00 		.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1214   D79F 00 00 00 00 
1214   D7A3 00 00 00 00 
1214   D7A7 00 00 00 00 
1215   D7AB             CCPSTACK 	.EQU	$	;end of ccp stack area.
1216   D7AB             ;
1217   D7AB             ;   Batch (or SUBMIT) processing information storage.
1218   D7AB             ;
1219   D7AB 00          BATCH:	.DB	0			;batch mode flag (0=not active).
1220   D7AC 00          BATCHFCB: 	.DB	0,
1221   D7AD 24 24 24 20 	.TEXT "$$$     SUB"
1221   D7B1 20 20 20 20 
1221   D7B5 53 55 42 
1222   D7B8 00 00 00 00 	.DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1222   D7BC 00 00 00 00 
1222   D7C0 00 00 00 00 
1222   D7C4 00 00 00 00 
1222   D7C8 00 00 00 00 
1222   D7CC 00 
1223   D7CD             ;
1224   D7CD             ;   File control block setup by the CCP.
1225   D7CD             ;
1226   D7CD 00          FCB:		.DB	0
1227   D7CE 20 20 20 20 	.TEXT	"           "
1227   D7D2 20 20 20 20 
1227   D7D6 20 20 20 
1228   D7D9 00 00 00 00 	.DB	0,0,0,0,0
1228   D7DD 00 
1229   D7DE 20 20 20 20 	.TEXT	"           "
1229   D7E2 20 20 20 20 
1229   D7E6 20 20 20 
1230   D7E9 00 00 00 00 	.DB	0,0,0,0,0
1230   D7ED 00 
1231   D7EE 00          RTNCODE:	.DB	0			;status returned from bdos call.
1232   D7EF 00          CDRIVE:	.DB	0			;currently active drive.
1233   D7F0 00          CHGDRV:	.DB	0			;change in drives flag (0=no change).
1234   D7F1 00 00       NBYTES:	.DW	0			;byte counter used by TYPE.
1235   D7F3             ;
1236   D7F3             ;   Room for expansion?
1237   D7F3             ;
1238   D7F3 00 00 00 00 		.DB	0,0,0,0,0,0,0,0,0,0,0,0,0
1238   D7F7 00 00 00 00 
1238   D7FB 00 00 00 00 
1238   D7FF 00 
1239   D800             ;
1240   D800             ;   Note that the following six bytes must match those at
1241   D800             ; (PATTRN1) or cp/m will HALT. Why?
1242   D800             ;
1243   D800 00 16 00 00 PATTRN2:	.DB	0,22,0,0,0,0	;(* serial number bytes *).
1243   D804 00 00 
1244   D806             ;
1245   D806             ;**************************************************************
1246   D806             ;*
1247   D806             ;*                    B D O S   E N T R Y
1248   D806             ;*
1249   D806             ;**************************************************************
1250   D806             ;
1251   D806 C3 11 D8    FBASE:	JP	FBASE1
1252   D809             ;
1253   D809             ;   Bdos error table.
1254   D809             ;
1255   D809 99 D8       BADSCTR:	.DW	ERROR1		;bad sector on read or write.
1256   D80B A5 D8       BADSLCT:	.DW	ERROR2		;bad disk select.
1257   D80D AB D8       RODISK:	.DW	ERROR3		;disk is read only.
1258   D80F B1 D8       ROFILE:	.DW	ERROR4		;file is read only.
1259   D811             ;
1260   D811             ;   Entry into bdos. (DE) or (E) are the parameters passed. The
1261   D811             ; function number desired is in register (C).
1262   D811             ;
1263   D811 EB          FBASE1:	EX	DE,HL			;save the (DE) parameters.
1264   D812 22 43 DB    	LD	(PARAMS),HL
1265   D815 EB          	EX	DE,HL
1266   D816 7B          	LD	A,E			;and save register (E) in particular.
1267   D817 32 D6 E5    	LD	(EPARAM),A
1268   D81A 21 00 00    	LD	HL,0
1269   D81D 22 45 DB    	LD	(STATUS),HL	;clear return status.
1270   D820 39          	ADD	HL,SP
1271   D821 22 0F DB    	LD	(USRSTACK),HL	;save users stack pointer.
1272   D824 31 41 DB    	LD	SP,STKAREA		;and set our own.
1273   D827 AF          	XOR	A			;clear auto select storage space.
1274   D828 32 E0 E5    	LD	(AUTOFLAG),A
1275   D82B 32 DE E5    	LD	(AUTO),A
1276   D82E 21 74 E5    	LD	HL,GOBACK		;set return address.
1277   D831 E5          	PUSH	HL
1278   D832 79          	LD	A,C			;get function number.
1279   D833 FE 29       	CP	NFUNCTS		;valid function number?
1280   D835 D0          	RET	NC
1281   D836 4B          	LD	C,E			;keep single register function here.
1282   D837 21 47 D8    	LD	HL,FUNCTNS		;now look thru the function table.
1283   D83A 5F          	LD	E,A
1284   D83B 16 00       	LD	D,0			;(DE)=function number.
1285   D83D 19          	ADD	HL,DE
1286   D83E 19          	ADD	HL,DE			;(HL)=(start of table)+2*(function number).
1287   D83F 5E          	LD	E,(HL)
1288   D840 23          	INC	HL
1289   D841 56          	LD	D,(HL)		;now (DE)=address for this function.
1290   D842 2A 43 DB    	LD	HL,(PARAMS)	;retrieve parameters.
1291   D845 EB          	EX	DE,HL			;now (DE) has the original parameters.
1292   D846 E9          	JP	(HL)			;execute desired function.
1293   D847             ;
1294   D847             ;   BDOS function jump table.
1295   D847             ;
1296   D847             NFUNCTS 	.EQU	41			;number of functions in followin table.
1297   D847             ;
1298   D847 03 E6 C8 DA FUNCTNS:	.DW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
1298   D84B 90 D9 CE DA 
1298   D84F 12 E6 0F E6 
1298   D853 D4 DA ED DA 
1299   D857 F3 DA F8 DA 	.DW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
1299   D85B E1 D9 FE DA 
1299   D85F 7E E4 83 E4 
1299   D863 45 E4 9C E4 
1300   D867 A5 E4 AB E4 	.DW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
1300   D86B C8 E4 D7 E4 
1300   D86F E0 E4 E6 E4 
1300   D873 EC E4 
1301   D875 F5 E4 FE E4 	.DW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
1301   D879 04 E5 0A E5 
1301   D87D 11 E5 2C DD 
1301   D881 17 E5 1D E5 
1302   D885 26 E5 2D E5 	.DW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
1302   D889 41 E5 47 E5 
1302   D88D 4D E5 0E E4 
1302   D891 53 E5 04 DB 
1303   D895 04 DB 9B E5 	.DW	RTN,WTSPECL
1304   D899             ;
1305   D899             ;   Bdos error message section.
1306   D899             ;
1307   D899 21 CA D8    ERROR1:	LD	HL,BADSEC		;bad sector message.
1308   D89C CD E5 D8    	CALL	PRTERR		;print it and get a 1 char responce.
1309   D89F FE 03       	CP	CNTRLC		;re-boot request (control-c)?
1310   D8A1 CA 00 00    	JP	Z,0			;yes.
1311   D8A4 C9          	RET				;no, return to retry i/o function.
1312   D8A5             ;
1313   D8A5 21 D5 D8    ERROR2:	LD	HL,BADSEL		;bad drive selected.
1314   D8A8 C3 B4 D8    		JP	ERROR5
1315   D8AB             ;
1316   D8AB 21 E1 D8    ERROR3:	LD	HL,DISKRO		;disk is read only.
1317   D8AE C3 B4 D8    		JP	ERROR5
1318   D8B1             ;
1319   D8B1 21 DC D8    ERROR4:	LD	HL,FILERO		;file is read only.
1320   D8B4             ;
1321   D8B4 CD E5 D8    ERROR5:	CALL	PRTERR
1322   D8B7 C3 00 00    		JP	0			;always reboot on these errors.
1323   D8BA             ;
1324   D8BA 42 64 6F 73 BDOSERR:	.TEXT	"Bdos Err On "
1324   D8BE 20 45 72 72 
1324   D8C2 20 4F 6E 20 
1325   D8C6 20 3A 20 24 BDOSDRV:	.TEXT	" : $"
1326   D8CA 42 61 64 20 BADSEC:	.TEXT	"Bad Sector$"
1326   D8CE 53 65 63 74 
1326   D8D2 6F 72 24 
1327   D8D5 53 65 6C 65 BADSEL:	.TEXT	"Select$"
1327   D8D9 63 74 24 
1328   D8DC 46 69 6C 65 FILERO:	.TEXT	"File "
1328   D8E0 20 
1329   D8E1 52 2F 4F 24 DISKRO:	.TEXT	"R/O$"
1330   D8E5             ;
1331   D8E5             ;   Print bdos error message.
1332   D8E5             ;
1333   D8E5 E5          PRTERR:	PUSH	HL			;save second message pointer.
1334   D8E6 CD C9 D9    	CALL	OUTCRLF		;send (cr)(lf).
1335   D8E9 3A 42 DB    	LD	A,(ACTIVE)		;get active drive.
1336   D8EC C6 41       	ADD	A,'A'			;make ascii.
1337   D8EE 32 C6 D8    	LD	(BDOSDRV),A	;and put in message.
1338   D8F1 01 BA D8    	LD	BC,BDOSERR		;and print it.
1339   D8F4 CD D3 D9    	CALL	PRTMESG
1340   D8F7 C1          	POP	BC			;print second message line now.
1341   D8F8 CD D3 D9    	CALL	PRTMESG
1342   D8FB             ;
1343   D8FB             ;   Get an input character. We will check our 1 character
1344   D8FB             ; buffer first. This may be set by the console status routine.
1345   D8FB             ;
1346   D8FB 21 0E DB    GETCHAR:	LD	HL,CHARBUF	;check character buffer.
1347   D8FE 7E          	LD	A,(HL)		;anything present already?
1348   D8FF 36 00       	LD	(HL),0		;...either case clear it.
1349   D901 B7          	OR	A
1350   D902 C0          	RET	NZ			;yes, use it.
1351   D903 C3 09 E6    	JP	CONIN			;nope, go get a character responce.
1352   D906             ;
1353   D906             ;   Input and echo a character.
1354   D906             ;
1355   D906 CD FB D8    GETECHO:	CALL	GETCHAR		;input a character.
1356   D909 CD 14 D9    	CALL	CHKCHAR		;carriage control?
1357   D90C D8          	RET	C			;no, a regular control char so don't echo.
1358   D90D F5          	PUSH	AF			;ok, save character now.
1359   D90E 4F          	LD	C,A
1360   D90F CD 90 D9    	CALL	OUTCON		;and echo it.
1361   D912 F1          	POP	AF			;get character and return.
1362   D913 C9          	RET	
1363   D914             ;
1364   D914             ;   Check character in (A). Set the zero flag on a carriage
1365   D914             ; control character and the carry flag on any other control
1366   D914             ; character.
1367   D914             ;
1368   D914 FE 0D       CHKCHAR:	CP	CR			;check for carriage return, line feed, backspace,
1369   D916 C8          	RET	Z			;or a tab.
1370   D917 FE 0A       	CP	LF
1371   D919 C8          	RET	Z
1372   D91A FE 09       	CP	TAB
1373   D91C C8          	RET	Z
1374   D91D FE 08       	CP	BS
1375   D91F C8          	RET	Z
1376   D920 FE 20       	CP	' '			;other control char? Set carry flag.
1377   D922 C9          	RET	
1378   D923             ;
1379   D923             ;   Check the console during output. Halt on a control-s, then
1380   D923             ; reboot on a control-c. If anything else is ready, clear the
1381   D923             ; zero flag and return (the calling routine may want to do
1382   D923             ; something).
1383   D923             ;
1384   D923 3A 0E DB    CKCONSOL: 	LD	A,(CHARBUF)	;check buffer.
1385   D926 B7          	OR	A			;if anything, just return without checking.
1386   D927 C2 45 D9    	JP	NZ,CKCON2
1387   D92A CD 06 E6    	CALL	CONST			;nothing in buffer. Check console.
1388   D92D E6 01       	AND	01H			;look at bit 0.
1389   D92F C8          	RET	Z			;return if nothing.
1390   D930 CD 09 E6    	CALL	CONIN			;ok, get it.
1391   D933 FE 13       	CP	CNTRLS		;if not control-s, return with zero cleared.
1392   D935 C2 42 D9    	JP	NZ,CKCON1
1393   D938 CD 09 E6    	CALL	CONIN			;halt processing until another char
1394   D93B FE 03       	CP	CNTRLC		;is typed. Control-c?
1395   D93D CA 00 00    	JP	Z,0			;yes, reboot now.
1396   D940 AF          	XOR	A			;no, just pretend nothing was ever ready.
1397   D941 C9          	RET	
1398   D942 32 0E DB    CKCON1:	LD	(CHARBUF),A	;save character in buffer for later processing.
1399   D945 3E 01       CKCON2:	LD	A,1			;set (A) to non zero to mean something is ready.
1400   D947 C9          		RET	
1401   D948             ;
1402   D948             ;   Output (C) to the screen. If the printer flip-flop flag
1403   D948             ; is set, we will send character to printer also. The console
1404   D948             ; will be checked in the process.
1405   D948             ;
1406   D948 3A 0A DB    OUTCHAR:	LD	A,(OUTFLAG)	;check output flag.
1407   D94B B7          	OR	A			;anything and we won't generate output.
1408   D94C C2 62 D9    	JP	NZ,OUTCHR1
1409   D94F C5          	PUSH	BC
1410   D950 CD 23 D9    	CALL	CKCONSOL		;check console (we don't care whats there).
1411   D953 C1          	POP	BC
1412   D954 C5          	PUSH	BC
1413   D955 CD 0C E6    	CALL	CONOUT		;output (C) to the screen.
1414   D958 C1          	POP	BC
1415   D959 C5          	PUSH	BC
1416   D95A 3A 0D DB    	LD	A,(PRTFLAG)	;check printer flip-flop flag.
1417   D95D B7          	OR	A
1418   D95E C4 0F E6    	CALL	NZ,LIST		;print it also if non-zero.
1419   D961 C1          	POP	BC
1420   D962 79          OUTCHR1:	LD	A,C			;update cursors position.
1421   D963 21 0C DB    	LD	HL,CURPOS
1422   D966 FE 7F       	CP	DEL			;rubouts don't do anything here.
1423   D968 C8          	RET	Z
1424   D969 34          	INC	(HL)			;bump line pointer.
1425   D96A FE 20       	CP	' '			;and return if a normal character.
1426   D96C D0          	RET	NC
1427   D96D 35          	DEC	(HL)			;restore and check for the start of the line.
1428   D96E 7E          	LD	A,(HL)
1429   D96F B7          	OR	A
1430   D970 C8          	RET	Z			;ingnore control characters at the start of the line.
1431   D971 79          	LD	A,C
1432   D972 FE 08       	CP	BS			;is it a backspace?
1433   D974 C2 79 D9    	JP	NZ,OUTCHR2
1434   D977 35          	DEC	(HL)			;yes, backup pointer.
1435   D978 C9          	RET	
1436   D979 FE 0A       OUTCHR2:	CP	LF			;is it a line feed?
1437   D97B C0          	RET	NZ			;ignore anything else.
1438   D97C 36 00       	LD	(HL),0		;reset pointer to start of line.
1439   D97E C9          	RET	
1440   D97F             ;
1441   D97F             ;   Output (A) to the screen. If it is a control character
1442   D97F             ; (other than carriage control), use ^x format.
1443   D97F             ;
1444   D97F 79          SHOWIT:	LD	A,C
1445   D980 CD 14 D9    	CALL	CHKCHAR		;check character.
1446   D983 D2 90 D9    	JP	NC,OUTCON		;not a control, use normal output.
1447   D986 F5          	PUSH	AF
1448   D987 0E 5E       	LD	C,'^'			;for a control character, preceed it with '^'.
1449   D989 CD 48 D9    	CALL	OUTCHAR
1450   D98C F1          	POP	AF
1451   D98D F6 40       	OR	'@'			;and then use the letter equivelant.
1452   D98F 4F          	LD	C,A
1453   D990             ;
1454   D990             ;   Function to output (C) to the console device and expand tabs
1455   D990             ; if necessary.
1456   D990             ;
1457   D990 79          OUTCON:	LD	A,C
1458   D991 FE 09       	CP	TAB			;is it a tab?
1459   D993 C2 48 D9    	JP	NZ,OUTCHAR		;use regular output.
1460   D996 0E 20       OUTCON1:	LD	C,' '			;yes it is, use spaces instead.
1461   D998 CD 48 D9    	CALL	OUTCHAR
1462   D99B 3A 0C DB    	LD	A,(CURPOS)		;go until the cursor is at a multiple of 8
1463   D99E             
1464   D99E E6 07       	AND	07H			;position.
1465   D9A0 C2 96 D9    	JP	NZ,OUTCON1
1466   D9A3 C9          	RET	
1467   D9A4             ;
1468   D9A4             ;   Echo a backspace character. Erase the prevoius character
1469   D9A4             ; on the screen.
1470   D9A4             ;
1471   D9A4 CD AC D9    BACKUP:	CALL	BACKUP1		;backup the screen 1 place.
1472   D9A7 0E 20       	LD	C,' '			;then blank that character.
1473   D9A9 CD 0C E6    	CALL	CONOUT
1474   D9AC 0E 08       BACKUP1:	LD	C,BS			;then back space once more.
1475   D9AE C3 0C E6    		JP	CONOUT
1476   D9B1             ;
1477   D9B1             ;   Signal a deleted line. Print a '#' at the end and start
1478   D9B1             ; over.
1479   D9B1             ;
1480   D9B1 0E 23       NEWLINE:	LD	C,'#'
1481   D9B3 CD 48 D9    	CALL	OUTCHAR		;print this.
1482   D9B6 CD C9 D9    	CALL	OUTCRLF		;start new line.
1483   D9B9 3A 0C DB    NEWLN1:	LD	A,(CURPOS)		;move the cursor to the starting position.
1484   D9BC 21 0B DB    	LD	HL,STARTING
1485   D9BF BE          	CP	(HL)
1486   D9C0 D0          	RET	NC			;there yet?
1487   D9C1 0E 20       	LD	C,' '
1488   D9C3 CD 48 D9    	CALL	OUTCHAR		;nope, keep going.
1489   D9C6 C3 B9 D9    	JP	NEWLN1
1490   D9C9             ;
1491   D9C9             ;   Output a (cr) (lf) to the console device (screen).
1492   D9C9             ;
1493   D9C9 0E 0D       OUTCRLF:	LD	C,CR
1494   D9CB CD 48 D9    	CALL	OUTCHAR
1495   D9CE 0E 0A       	LD	C,LF
1496   D9D0 C3 48 D9    	JP	OUTCHAR
1497   D9D3             ;
1498   D9D3             ;   Print message pointed to by (BC). It will end with a '$'.
1499   D9D3             ;
1500   D9D3 0A          PRTMESG:	LD	A,(BC)		;check for terminating character.
1501   D9D4 FE 24       	CP	'$'
1502   D9D6 C8          	RET	Z
1503   D9D7 03          	INC	BC
1504   D9D8 C5          	PUSH	BC			;otherwise, bump pointer and print it.
1505   D9D9 4F          	LD	C,A
1506   D9DA CD 90 D9    	CALL	OUTCON
1507   D9DD C1          	POP	BC
1508   D9DE C3 D3 D9    	JP	PRTMESG
1509   D9E1             ;
1510   D9E1             ;   Function to execute a buffered read.
1511   D9E1             ;
1512   D9E1 3A 0C DB    RDBUFF:	LD	A,(CURPOS)		;use present location as starting one.
1513   D9E4 32 0B DB    	LD	(STARTING),A
1514   D9E7 2A 43 DB    	LD	HL,(PARAMS)	;get the maximum buffer space.
1515   D9EA 4E          	LD	C,(HL)
1516   D9EB 23          	INC	HL			;point to first available space.
1517   D9EC E5          	PUSH	HL			;and save.
1518   D9ED 06 00       	LD	B,0			;keep a character count.
1519   D9EF C5          RDBUF1:	PUSH	BC
1520   D9F0 E5          		PUSH	HL
1521   D9F1 CD FB D8    RDBUF2:	CALL	GETCHAR		;get the next input character.
1522   D9F4 E6 7F       	AND	7FH			;strip bit 7.
1523   D9F6 E1          	POP	HL			;reset registers.
1524   D9F7 C1          	POP	BC
1525   D9F8 FE 0D       	CP	CR			;en of the line?
1526   D9FA CA C1 DA    	JP	Z,RDBUF17
1527   D9FD FE 0A       	CP	LF
1528   D9FF CA C1 DA    	JP	Z,RDBUF17
1529   DA02 FE 08       	CP	BS			;how about a backspace?
1530   DA04 C2 16 DA    	JP	NZ,RDBUF3
1531   DA07 78          	LD	A,B			;yes, but ignore at the beginning of the line.
1532   DA08 B7          	OR	A
1533   DA09 CA EF D9    	JP	Z,RDBUF1
1534   DA0C 05          	DEC	B			;ok, update counter.
1535   DA0D 3A 0C DB    	LD	A,(CURPOS)		;if we backspace to the start of the line,
1536   DA10 32 0A DB    	LD	(OUTFLAG),A	;treat as a cancel (control-x).
1537   DA13 C3 70 DA    	JP	RDBUF10
1538   DA16 FE 7F       RDBUF3:	CP	DEL			;user typed a rubout?
1539   DA18 C2 26 DA    	JP	NZ,RDBUF4
1540   DA1B 78          	LD	A,B			;ignore at the start of the line.
1541   DA1C B7          	OR	A
1542   DA1D CA EF D9    	JP	Z,RDBUF1
1543   DA20 7E          	LD	A,(HL)		;ok, echo the prevoius character.
1544   DA21 05          	DEC	B			;and reset pointers (counters).
1545   DA22 2B          	DEC	HL
1546   DA23 C3 A9 DA    	JP	RDBUF15
1547   DA26 FE 05       RDBUF4:	CP	CNTRLE		;physical end of line?
1548   DA28 C2 37 DA    	JP	NZ,RDBUF5
1549   DA2B C5          	PUSH	BC			;yes, do it.
1550   DA2C E5          	PUSH	HL
1551   DA2D CD C9 D9    	CALL	OUTCRLF
1552   DA30 AF          	XOR	A			;and update starting position.
1553   DA31 32 0B DB    	LD	(STARTING),A
1554   DA34 C3 F1 D9    	JP	RDBUF2
1555   DA37 FE 10       RDBUF5:	CP	CNTRLP		;control-p?
1556   DA39 C2 48 DA    	JP	NZ,RDBUF6
1557   DA3C E5          	PUSH	HL			;yes, flip the print flag filp-flop byte.
1558   DA3D 21 0D DB    	LD	HL,PRTFLAG
1559   DA40 3E 01       	LD	A,1			;PRTFLAG=1-PRTFLAG
1560   DA42 96          	SUB	(HL)
1561   DA43 77          	LD	(HL),A
1562   DA44 E1          	POP	HL
1563   DA45 C3 EF D9    	JP	RDBUF1
1564   DA48 FE 18       RDBUF6:	CP	CNTRLX		;control-x (cancel)?
1565   DA4A C2 5F DA    	JP	NZ,RDBUF8
1566   DA4D E1          	POP	HL
1567   DA4E 3A 0B DB    RDBUF7:	LD	A,(STARTING)	;yes, backup the cursor to here.
1568   DA51 21 0C DB    	LD	HL,CURPOS
1569   DA54 BE          	CP	(HL)
1570   DA55 D2 E1 D9    	JP	NC,RDBUFF		;done yet?
1571   DA58 35          	DEC	(HL)			;no, decrement pointer and output back up one space.
1572   DA59 CD A4 D9    	CALL	BACKUP
1573   DA5C C3 4E DA    	JP	RDBUF7
1574   DA5F FE 15       RDBUF8:	CP	CNTRLU		;cntrol-u (cancel line)?
1575   DA61 C2 6B DA    	JP	NZ,RDBUF9
1576   DA64 CD B1 D9    	CALL	NEWLINE		;start a new line.
1577   DA67 E1          	POP	HL
1578   DA68 C3 E1 D9    	JP	RDBUFF
1579   DA6B FE 12       RDBUF9:	CP	CNTRLR		;control-r?
1580   DA6D C2 A6 DA    		JP	NZ,RDBUF14
1581   DA70 C5          RDBUF10:	PUSH	BC			;yes, start a new line and retype the old one.
1582   DA71 CD B1 D9    	CALL	NEWLINE
1583   DA74 C1          	POP	BC
1584   DA75 E1          	POP	HL
1585   DA76 E5          	PUSH	HL
1586   DA77 C5          	PUSH	BC
1587   DA78 78          RDBUF11:	LD	A,B			;done whole line yet?
1588   DA79 B7          	OR	A
1589   DA7A CA 8A DA    	JP	Z,RDBUF12
1590   DA7D 23          	INC	HL			;nope, get next character.
1591   DA7E 4E          	LD	C,(HL)
1592   DA7F 05          	DEC	B			;count it.
1593   DA80 C5          	PUSH	BC
1594   DA81 E5          	PUSH	HL
1595   DA82 CD 7F D9    	CALL	SHOWIT		;and display it.
1596   DA85 E1          	POP	HL
1597   DA86 C1          	POP	BC
1598   DA87 C3 78 DA    	JP	RDBUF11
1599   DA8A E5          RDBUF12:	PUSH	HL			;done with line. If we were displaying
1600   DA8B 3A 0A DB    	LD	A,(OUTFLAG)	;then update cursor position.
1601   DA8E B7          	OR	A
1602   DA8F CA F1 D9    	JP	Z,RDBUF2
1603   DA92 21 0C DB    	LD	HL,CURPOS		;because this line is shorter, we must
1604   DA95 96          	SUB	(HL)			;back up the cursor (not the screen however)
1605   DA96 32 0A DB    	LD	(OUTFLAG),A	;some number of positions.
1606   DA99 CD A4 D9    RDBUF13:	CALL	BACKUP		;note that as long as (OUTFLAG) is non
1607   DA9C 21 0A DB    	LD	HL,OUTFLAG		;zero, the screen will not be changed.
1608   DA9F 35          	DEC	(HL)
1609   DAA0 C2 99 DA    	JP	NZ,RDBUF13
1610   DAA3 C3 F1 D9    	JP	RDBUF2		;now just get the next character.
1611   DAA6             ;
1612   DAA6             ;   Just a normal character, put this in our buffer and echo.
1613   DAA6             ;
1614   DAA6 23          RDBUF14:	INC	HL
1615   DAA7 77          	LD	(HL),A		;store character.
1616   DAA8 04          	INC	B			;and count it.
1617   DAA9 C5          RDBUF15:	PUSH	BC
1618   DAAA E5          	PUSH	HL
1619   DAAB 4F          	LD	C,A			;echo it now.
1620   DAAC CD 7F D9    	CALL	SHOWIT
1621   DAAF E1          	POP	HL
1622   DAB0 C1          	POP	BC
1623   DAB1 7E          	LD	A,(HL)		;was it an abort request?
1624   DAB2 FE 03       	CP	CNTRLC		;control-c abort?
1625   DAB4 78          	LD	A,B
1626   DAB5 C2 BD DA    	JP	NZ,RDBUF16
1627   DAB8 FE 01       	CP	1			;only if at start of line.
1628   DABA CA 00 00    	JP	Z,0
1629   DABD B9          RDBUF16:	CP	C			;nope, have we filled the buffer?
1630   DABE DA EF D9    		JP	C,RDBUF1
1631   DAC1 E1          RDBUF17:	POP	HL			;yes end the line and return.
1632   DAC2 70          	LD	(HL),B
1633   DAC3 0E 0D       	LD	C,CR
1634   DAC5 C3 48 D9    	JP	OUTCHAR		;output (cr) and return.
1635   DAC8             ;
1636   DAC8             ;   Function to get a character from the console device.
1637   DAC8             ;
1638   DAC8 CD 06 D9    GETCON:	CALL	GETECHO		;get and echo.
1639   DACB C3 01 DB    		JP	SETSTAT		;save status and return.
1640   DACE             ;
1641   DACE             ;   Function to get a character from the tape reader device.
1642   DACE             ;
1643   DACE CD 15 E6    GETRDR:	CALL	READER		;get a character from reader, set status and return.
1644   DAD1 C3 01 DB    		JP	SETSTAT
1645   DAD4             ;
1646   DAD4             ;  Function to perform direct console i/o. If (C) contains (FF)
1647   DAD4             ; then this is an input request. If (C) contains (FE) then
1648   DAD4             ; this is a status request. Otherwise we are to output (C).
1649   DAD4             ;
1650   DAD4 79          DIRCIO:	LD	A,C			;test for (FF).
1651   DAD5 3C          	INC	A
1652   DAD6 CA E0 DA    	JP	Z,DIRC1
1653   DAD9 3C          	INC	A			;test for (FE).
1654   DADA CA 06 E6    	JP	Z,CONST
1655   DADD C3 0C E6    	JP	CONOUT		;just output (C).
1656   DAE0 CD 06 E6    DIRC1:	CALL	CONST			;this is an input request.
1657   DAE3 B7          	OR	A
1658   DAE4 CA 91 E5    	JP	Z,GOBACK1		;not ready? Just return (directly).
1659   DAE7 CD 09 E6    	CALL	CONIN			;yes, get character.
1660   DAEA C3 01 DB    	JP	SETSTAT		;set status and return.
1661   DAED             ;
1662   DAED             ;   Function to return the i/o byte.
1663   DAED             ;
1664   DAED 3A 03 00    GETIOB:	LD	A,(IOBYTE)
1665   DAF0 C3 01 DB    		JP	SETSTAT
1666   DAF3             ;
1667   DAF3             ;   Function to set the i/o byte.
1668   DAF3             ;
1669   DAF3 21 03 00    SETIOB:	LD	HL,IOBYTE
1670   DAF6 71          	LD	(HL),C
1671   DAF7 C9          	RET	
1672   DAF8             ;
1673   DAF8             ;   Function to print the character string pointed to by (DE)
1674   DAF8             ; on the console device. The string ends with a '$'.
1675   DAF8             ;
1676   DAF8 EB          PRTSTR:	EX	DE,HL
1677   DAF9 4D          	LD	C,L
1678   DAFA 44          	LD	B,H			;now (BC) points to it.
1679   DAFB C3 D3 D9    	JP	PRTMESG
1680   DAFE             ;
1681   DAFE             ;   Function to interigate the console device.
1682   DAFE             ;
1683   DAFE CD 23 D9    GETCSTS:	CALL	CKCONSOL
1684   DB01             ;
1685   DB01             ;   Get here to set the status and return to the cleanup
1686   DB01             ; section. Then back to the user.
1687   DB01             ;
1688   DB01 32 45 DB    SETSTAT:	LD	(STATUS),A
1689   DB04 C9          RTN:		RET	
1690   DB05             ;
1691   DB05             ;   Set the status to 1 (read or write error code).
1692   DB05             ;
1693   DB05 3E 01       IOERR1:	LD	A,1
1694   DB07 C3 01 DB    		JP	SETSTAT
1695   DB0A             ;
1696   DB0A 00          OUTFLAG:	.DB	0			;output flag (non zero means no output).
1697   DB0B 02          STARTING:	.DB	2			;starting position for cursor.
1698   DB0C 00          CURPOS:	.DB	0			;cursor position (0=start of line).
1699   DB0D 00          PRTFLAG:	.DB	0			;printer flag (control-p toggle). List if non zero.
1700   DB0E 00          CHARBUF:	.DB	0			;single input character buffer.
1701   DB0F             ;
1702   DB0F             ;   Stack area for BDOS calls.
1703   DB0F             ;
1704   DB0F 00 00       USRSTACK: 	.DW	0			;save users stack pointer here.
1705   DB11             ;
1706   DB11 00 00 00 00 	.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1706   DB15 00 00 00 00 
1706   DB19 00 00 00 00 
1706   DB1D 00 00 00 00 
1706   DB21 00 00 00 00 
1706   DB25 00 00 00 00 
1707   DB29 00 00 00 00 	.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1707   DB2D 00 00 00 00 
1707   DB31 00 00 00 00 
1707   DB35 00 00 00 00 
1707   DB39 00 00 00 00 
1707   DB3D 00 00 00 00 
1708   DB41             STKAREA 	.EQU	$			;end of stack area.
1709   DB41             ;
1710   DB41 00          USERNO:	.DB	0			;current user number.
1711   DB42 00          ACTIVE:	.DB	0			;currently active drive.
1712   DB43 00 00       PARAMS:	.DW	0			;save (DE) parameters here on entry.
1713   DB45 00 00       STATUS:	.DW	0			;status returned from bdos function.
1714   DB47             ;
1715   DB47             ;   Select error occured, jump to error routine.
1716   DB47             ;
1717   DB47 21 0B D8    SLCTERR:	LD	HL,BADSLCT
1718   DB4A             ;
1719   DB4A             ;   Jump to (HL) indirectly.
1720   DB4A             ;
1721   DB4A 5E          JUMPHL:	LD	E,(HL)
1722   DB4B 23          	INC	HL
1723   DB4C 56          	LD	D,(HL)		;now (DE) contain the desired address.
1724   DB4D EB          	EX	DE,HL
1725   DB4E E9          	JP	(HL)
1726   DB4F             ;
1727   DB4F             ;   Block move. (DE) to (HL), (C) bytes total.
1728   DB4F             ;
1729   DB4F 0C          DE2HL:	INC	C			;is count down to zero?
1730   DB50 0D          DE2HL1:	DEC	C	
1731   DB51 C8          	RET	Z			;yes, we are done.
1732   DB52 1A          	LD	A,(DE)		;no, move one more byte.
1733   DB53 77          	LD	(HL),A
1734   DB54 13          	INC	DE
1735   DB55 23          	INC	HL
1736   DB56 C3 50 DB    	JP	DE2HL1		;and repeat.
1737   DB59             ;
1738   DB59             ;   Select the desired drive.
1739   DB59             ;
1740   DB59 3A 42 DB    SELECT:	LD	A,(ACTIVE)		;get active disk.
1741   DB5C 4F          	LD	C,A
1742   DB5D CD 1B E6    	CALL	SELDSK		;select it.
1743   DB60 7C          	LD	A,H			;valid drive?
1744   DB61 B5          	OR	L			;valid drive?
1745   DB62 C8          	RET	Z			;return if not.
1746   DB63             ;
1747   DB63             ;   Here, the BIOS returned the address of the parameter block
1748   DB63             ; in (HL). We will extract the necessary pointers and save them.
1749   DB63             ;
1750   DB63 5E          	LD	E,(HL)		;yes, get address of translation table into (DE).
1751   DB64 23          	INC	HL
1752   DB65 56          	LD	D,(HL)
1753   DB66 23          	INC	HL
1754   DB67 22 B3 E5    	LD	(SCRATCH1),HL	;save pointers to scratch areas.
1755   DB6A 23          	INC	HL
1756   DB6B 23          	INC	HL
1757   DB6C 22 B5 E5    	LD	(SCRATCH2),HL	;ditto.
1758   DB6F 23          	INC	HL
1759   DB70 23          	INC	HL
1760   DB71 22 B7 E5    	LD	(SCRATCH3),HL	;ditto.
1761   DB74 23          	INC	HL
1762   DB75 23          	INC	HL
1763   DB76 EB          	EX	DE,HL			;now save the translation table address.
1764   DB77 22 D0 E5    	LD	(XLATE),HL
1765   DB7A 21 B9 E5    	LD	HL,DIRBUF		;put the next 8 bytes here.
1766   DB7D 0E 08       	LD	C,8			;they consist of the directory buffer
1767   DB7F CD 4F DB    	CALL	DE2HL			;pointer, parameter block pointer,
1768   DB82 2A BB E5    	LD	HL,(DISKPB)	;check and allocation vectors.
1769   DB85 EB          	EX	DE,HL
1770   DB86 21 C1 E5    	LD	HL,SECTORS		;move parameter block into our ram.
1771   DB89 0E 0F       	LD	C,15			;it is 15 bytes long.
1772   DB8B CD 4F DB    	CALL	DE2HL
1773   DB8E 2A C6 E5    	LD	HL,(DSKSIZE)	;check disk size.
1774   DB91 7C          	LD	A,H			;more than 256 blocks on this?
1775   DB92 21 DD E5    	LD	HL,BIGDISK
1776   DB95 36 FF       	LD	(HL),0FFH		;set to samll.
1777   DB97 B7          	OR	A
1778   DB98 CA 9D DB    	JP	Z,SELECT1
1779   DB9B 36 00       	LD	(HL),0		;wrong, set to large.
1780   DB9D 3E FF       SELECT1:	LD	A,0FFH		;clear the zero flag.
1781   DB9F B7          	OR	A
1782   DBA0 C9          	RET	
1783   DBA1             ;
1784   DBA1             ;   Routine to home the disk track head and clear pointers.
1785   DBA1             ;
1786   DBA1 CD 18 E6    HOMEDRV:	CALL	HOME			;home the head.
1787   DBA4 AF          	XOR	A
1788   DBA5 2A B5 E5    	LD	HL,(SCRATCH2)	;set our track pointer also.
1789   DBA8 77          	LD	(HL),A
1790   DBA9 23          	INC	HL
1791   DBAA 77          	LD	(HL),A
1792   DBAB 2A B7 E5    	LD	HL,(SCRATCH3)	;and our sector pointer.
1793   DBAE 77          	LD	(HL),A
1794   DBAF 23          	INC	HL
1795   DBB0 77          	LD	(HL),A
1796   DBB1 C9          	RET	
1797   DBB2             ;
1798   DBB2             ;   Do the actual disk read and check the error return status.
1799   DBB2             ;
1800   DBB2 CD 27 E6    DOREAD:	CALL	READ
1801   DBB5 C3 BB DB    		JP	IORET
1802   DBB8             ;
1803   DBB8             ;   Do the actual disk write and handle any bios error.
1804   DBB8             ;
1805   DBB8 CD 2A E6    DOWRITE:	CALL	WRITE
1806   DBBB B7          IORET:	OR	A
1807   DBBC C8          	RET	Z			;return unless an error occured.
1808   DBBD 21 09 D8    	LD	HL,BADSCTR		;bad read/write on this sector.
1809   DBC0 C3 4A DB    	JP	JUMPHL
1810   DBC3             ;
1811   DBC3             ;   Routine to select the track and sector that the desired
1812   DBC3             ; block number falls in.
1813   DBC3             ;
1814   DBC3 2A EA E5    TRKSEC:	LD	HL,(FILEPOS)	;get position of last accessed file
1815   DBC6 0E 02       	LD	C,2			;in directory and compute sector #.
1816   DBC8 CD EA DC    	CALL	SHIFTR		;sector #=file-position/4.
1817   DBCB 22 E5 E5    	LD	(BLKNMBR),HL	;save this as the block number of interest.
1818   DBCE 22 EC E5    	LD	(CKSUMTBL),HL	;what's it doing here too?
1819   DBD1             ;
1820   DBD1             ;   if the sector number has already been set (BLKNMBR), enter
1821   DBD1             ; at this point.
1822   DBD1             ;
1823   DBD1 21 E5 E5    TRKSEC1:	LD	HL,BLKNMBR
1824   DBD4 4E          	LD	C,(HL)		;move sector number into (BC).
1825   DBD5 23          	INC	HL
1826   DBD6 46          	LD	B,(HL)
1827   DBD7 2A B7 E5    	LD	HL,(SCRATCH3)	;get current sector number and
1828   DBDA 5E          	LD	E,(HL)		;move this into (DE).
1829   DBDB 23          	INC	HL
1830   DBDC 56          	LD	D,(HL)
1831   DBDD 2A B5 E5    	LD	HL,(SCRATCH2)	;get current track number.
1832   DBE0 7E          	LD	A,(HL)		;and this into (HL).
1833   DBE1 23          	INC	HL
1834   DBE2 66          	LD	H,(HL)
1835   DBE3 6F          	LD	L,A
1836   DBE4 79          TRKSEC2:	LD	A,C			;is desired sector before current one?
1837   DBE5 93          	SUB	E
1838   DBE6 78          	LD	A,B
1839   DBE7 9A          	SBC	A,D
1840   DBE8 D2 FA DB    	JP	NC,TRKSEC3
1841   DBEB E5          	PUSH	HL			;yes, decrement sectors by one track.
1842   DBEC 2A C1 E5    	LD	HL,(SECTORS)	;get sectors per track.
1843   DBEF 7B          	LD	A,E
1844   DBF0 95          	SUB	L
1845   DBF1 5F          	LD	E,A
1846   DBF2 7A          	LD	A,D
1847   DBF3 9C          	SBC	A,H
1848   DBF4 57          	LD	D,A			;now we have backed up one full track.
1849   DBF5 E1          	POP	HL
1850   DBF6 2B          	DEC	HL			;adjust track counter.
1851   DBF7 C3 E4 DB    	JP	TRKSEC2
1852   DBFA E5          TRKSEC3:	PUSH	HL			;desired sector is after current one.
1853   DBFB 2A C1 E5    	LD	HL,(SECTORS)	;get sectors per track.
1854   DBFE 19          	ADD	HL,DE			;bump sector pointer to next track.
1855   DBFF DA 0F DC    	JP	C,TRKSEC4
1856   DC02 79          	LD	A,C			;is desired sector now before current one?
1857   DC03 95          	SUB	L
1858   DC04 78          	LD	A,B
1859   DC05 9C          	SBC	A,H
1860   DC06 DA 0F DC    	JP	C,TRKSEC4
1861   DC09 EB          	EX	DE,HL			;not yes, increment track counter
1862   DC0A E1          	POP	HL			;and continue until it is.
1863   DC0B 23          	INC	HL
1864   DC0C C3 FA DB    	JP	TRKSEC3
1865   DC0F             ;
1866   DC0F             ;   here we have determined the track number that contains the
1867   DC0F             ; desired sector.
1868   DC0F             ;
1869   DC0F E1          TRKSEC4:	POP	HL			;get track number (HL).
1870   DC10 C5          	PUSH	BC
1871   DC11 D5          	PUSH	DE
1872   DC12 E5          	PUSH	HL
1873   DC13 EB          	EX	DE,HL
1874   DC14 2A CE E5    	LD	HL,(OFFSET)	;adjust for first track offset.
1875   DC17 19          	ADD	HL,DE
1876   DC18 44          	LD	B,H
1877   DC19 4D          	LD	C,L
1878   DC1A CD 1E E6    	CALL	SETTRK		;select this track.
1879   DC1D D1          	POP	DE			;reset current track pointer.
1880   DC1E 2A B5 E5    	LD	HL,(SCRATCH2)
1881   DC21 73          	LD	(HL),E
1882   DC22 23          	INC	HL
1883   DC23 72          	LD	(HL),D
1884   DC24 D1          	POP	DE
1885   DC25 2A B7 E5    	LD	HL,(SCRATCH3)	;reset the first sector on this track.
1886   DC28 73          	LD	(HL),E
1887   DC29 23          	INC	HL
1888   DC2A 72          	LD	(HL),D
1889   DC2B C1          	POP	BC
1890   DC2C 79          	LD	A,C			;now subtract the desired one.
1891   DC2D 93          	SUB	E			;to make it relative (1-# sectors/track).
1892   DC2E 4F          	LD	C,A
1893   DC2F 78          	LD	A,B
1894   DC30 9A          	SBC	A,D
1895   DC31 47          	LD	B,A
1896   DC32 2A D0 E5    	LD	HL,(XLATE)		;translate this sector according to this table.
1897   DC35 EB          	EX	DE,HL
1898   DC36 CD 30 E6    	CALL	SECTRN		;let the bios translate it.
1899   DC39 4D          	LD	C,L
1900   DC3A 44          	LD	B,H
1901   DC3B C3 21 E6    	JP	SETSEC		;and select it.
1902   DC3E             ;
1903   DC3E             ;   Compute block number from record number (SAVNREC) and
1904   DC3E             ; extent number (SAVEXT).
1905   DC3E             ;
1906   DC3E 21 C3 E5    GETBLOCK: 	LD	HL,BLKSHFT		;get logical to physical conversion.
1907   DC41 4E          	LD	C,(HL)		;note that this is base 2 log of ratio.
1908   DC42 3A E3 E5    	LD	A,(SAVNREC)	;get record number.
1909   DC45 B7          GETBLK1:	OR	A			;compute (A)=(A)/2^BLKSHFT.
1910   DC46 1F          	RRA	
1911   DC47 0D          	DEC	C
1912   DC48 C2 45 DC    	JP	NZ,GETBLK1
1913   DC4B 47          	LD	B,A			;save result in (B).
1914   DC4C 3E 08       	LD	A,8
1915   DC4E 96          	SUB	(HL)
1916   DC4F 4F          	LD	C,A			;compute (C)=8-BLKSHFT.
1917   DC50 3A E2 E5    	LD	A,(SAVEXT)
1918   DC53 0D          GETBLK2:	DEC	C			;compute (A)=SAVEXT*2^(8-BLKSHFT).
1919   DC54 CA 5C DC    	JP	Z,GETBLK3
1920   DC57 B7          	OR	A
1921   DC58 17          	RLA	
1922   DC59 C3 53 DC    	JP	GETBLK2
1923   DC5C 80          GETBLK3:	ADD	A,B
1924   DC5D C9          		RET	
1925   DC5E             ;
1926   DC5E             ;   Routine to extract the (BC) block byte from the fcb pointed
1927   DC5E             ; to by (PARAMS). If this is a big-disk, then these are 16 bit
1928   DC5E             ; block numbers, else they are 8 bit numbers.
1929   DC5E             ; Number is returned in (HL).
1930   DC5E             ;
1931   DC5E 2A 43 DB    EXTBLK:	LD	HL,(PARAMS)	;get fcb address.
1932   DC61 11 10 00    	LD	DE,16			;block numbers start 16 bytes into fcb.
1933   DC64 19          	ADD	HL,DE
1934   DC65 09          	ADD	HL,BC
1935   DC66 3A DD E5    	LD	A,(BIGDISK)	;are we using a big-disk?
1936   DC69 B7          	OR	A
1937   DC6A CA 71 DC    	JP	Z,EXTBLK1
1938   DC6D 6E          	LD	L,(HL)		;no, extract an 8 bit number from the fcb.
1939   DC6E 26 00       	LD	H,0
1940   DC70 C9          	RET	
1941   DC71 09          EXTBLK1:	ADD	HL,BC			;yes, extract a 16 bit number.
1942   DC72 5E          	LD	E,(HL)
1943   DC73 23          	INC	HL
1944   DC74 56          	LD	D,(HL)
1945   DC75 EB          	EX	DE,HL			;return in (HL).
1946   DC76 C9          	RET	
1947   DC77             ;
1948   DC77             ;   Compute block number.
1949   DC77             ;
1950   DC77 CD 3E DC    COMBLK:	CALL	GETBLOCK
1951   DC7A 4F          	LD	C,A
1952   DC7B 06 00       	LD	B,0
1953   DC7D CD 5E DC    	CALL	EXTBLK
1954   DC80 22 E5 E5    	LD	(BLKNMBR),HL
1955   DC83 C9          	RET	
1956   DC84             ;
1957   DC84             ;   Check for a zero block number (unused).
1958   DC84             ;
1959   DC84 2A E5 E5    CHKBLK:	LD	HL,(BLKNMBR)
1960   DC87 7D          	LD	A,L			;is it zero?
1961   DC88 B4          	OR	H
1962   DC89 C9          	RET	
1963   DC8A             ;
1964   DC8A             ;   Adjust physical block (BLKNMBR) and convert to logical
1965   DC8A             ; sector (LOGSECT). This is the starting sector of this block.
1966   DC8A             ; The actual sector of interest is then added to this and the
1967   DC8A             ; resulting sector number is stored back in (BLKNMBR). This
1968   DC8A             ; will still have to be adjusted for the track number.
1969   DC8A             ;
1970   DC8A 3A C3 E5    LOGICAL:	LD	A,(BLKSHFT)	;get log2(physical/logical sectors).
1971   DC8D 2A E5 E5    		LD	HL,(BLKNMBR)	;get physical sector desired.
1972   DC90 29          LOGICL1:	ADD	HL,HL			;compute logical sector number.
1973   DC91 3D          	DEC	A			;note logical sectors are 128 bytes long.
1974   DC92 C2 90 DC    	JP	NZ,LOGICL1
1975   DC95 22 E7 E5    	LD	(LOGSECT),HL	;save logical sector.
1976   DC98 3A C4 E5    	LD	A,(BLKMASK)	;get block mask.
1977   DC9B 4F          	LD	C,A
1978   DC9C 3A E3 E5    	LD	A,(SAVNREC)	;get next sector to access.
1979   DC9F A1          	AND	C			;extract the relative position within physical block.
1980   DCA0 B5          	OR	L			;and add it too logical sector.
1981   DCA1 6F          	LD	L,A
1982   DCA2 22 E5 E5    	LD	(BLKNMBR),HL	;and store.
1983   DCA5 C9          	RET	
1984   DCA6             ;
1985   DCA6             ;   Set (HL) to point to extent byte in fcb.
1986   DCA6             ;
1987   DCA6 2A 43 DB    SETEXT:	LD	HL,(PARAMS)
1988   DCA9 11 0C 00    	LD	DE,12			;it is the twelth byte.
1989   DCAC 19          	ADD	HL,DE
1990   DCAD C9          	RET	
1991   DCAE             ;
1992   DCAE             ;   Set (HL) to point to record count byte in fcb and (DE) to
1993   DCAE             ; next record number byte.
1994   DCAE             ;
1995   DCAE 2A 43 DB    SETHLDE:	LD	HL,(PARAMS)
1996   DCB1 11 0F 00    	LD	DE,15			;record count byte (#15).
1997   DCB4 19          	ADD	HL,DE
1998   DCB5 EB          	EX	DE,HL
1999   DCB6 21 11 00    	LD	HL,17			;next record number (#32).
2000   DCB9 19          	ADD	HL,DE
2001   DCBA C9          	RET	
2002   DCBB             ;
2003   DCBB             ;   Save current file data from fcb.
2004   DCBB             ;
2005   DCBB CD AE DC    STRDATA:	CALL	SETHLDE
2006   DCBE 7E          	LD	A,(HL)		;get and store record count byte.
2007   DCBF 32 E3 E5    	LD	(SAVNREC),A
2008   DCC2 EB          	EX	DE,HL
2009   DCC3 7E          	LD	A,(HL)		;get and store next record number byte.
2010   DCC4 32 E1 E5    	LD	(SAVNXT),A
2011   DCC7 CD A6 DC    	CALL	SETEXT		;point to extent byte.
2012   DCCA 3A C5 E5    	LD	A,(EXTMASK)	;get extent mask.
2013   DCCD A6          	AND	(HL)
2014   DCCE 32 E2 E5    	LD	(SAVEXT),A	;and save extent here.
2015   DCD1 C9          	RET	
2016   DCD2             ;
2017   DCD2             ;   Set the next record to access. If (MODE) is set to 2, then
2018   DCD2             ; the last record byte (SAVNREC) has the correct number to access.
2019   DCD2             ; For sequential access, (MODE) will be equal to 1.
2020   DCD2             ;
2021   DCD2 CD AE DC    SETNREC:	CALL	SETHLDE
2022   DCD5 3A D5 E5    	LD	A,(MODE)		;get sequential flag (=1).
2023   DCD8 FE 02       	CP	2			;a 2 indicates that no adder is needed.
2024   DCDA C2 DE DC    	JP	NZ,STNREC1
2025   DCDD AF          	XOR	A			;clear adder (random access?).
2026   DCDE 4F          STNREC1:	LD	C,A
2027   DCDF 3A E3 E5    	LD	A,(SAVNREC)	;get last record number.
2028   DCE2 81          	ADD	A,C			;increment record count.
2029   DCE3 77          	LD	(HL),A		;and set fcb's next record byte.
2030   DCE4 EB          	EX	DE,HL
2031   DCE5 3A E1 E5    	LD	A,(SAVNXT)		;get next record byte from storage.
2032   DCE8 77          	LD	(HL),A		;and put this into fcb as number of records used.
2033   DCE9 C9          	RET	
2034   DCEA             ;
2035   DCEA             ;   Shift (HL) right (C) bits.
2036   DCEA             ;
2037   DCEA 0C          SHIFTR:	INC	C
2038   DCEB 0D          SHIFTR1:	DEC	C
2039   DCEC C8          	RET	Z
2040   DCED 7C          	LD	A,H
2041   DCEE B7          	OR	A
2042   DCEF 1F          	RRA	
2043   DCF0 67          	LD	H,A
2044   DCF1 7D          	LD	A,L
2045   DCF2 1F          	RRA	
2046   DCF3 6F          	LD	L,A
2047   DCF4 C3 EB DC    	JP	SHIFTR1
2048   DCF7             ;
2049   DCF7             ;   Compute the check-sum for the directory buffer. Return
2050   DCF7             ; integer sum in (A).
2051   DCF7             ;
2052   DCF7 0E 80       CHECKSUM: 	LD	C,128			;length of buffer.
2053   DCF9 2A B9 E5    	LD	HL,(DIRBUF)	;get its location.
2054   DCFC AF          	XOR	A			;clear summation byte.
2055   DCFD 86          CHKSUM1:	ADD	A,(HL)		;and compute sum ignoring carries.
2056   DCFE 23          	INC	HL
2057   DCFF 0D          	DEC	C
2058   DD00 C2 FD DC    	JP	NZ,CHKSUM1
2059   DD03 C9          	RET	
2060   DD04             ;
2061   DD04             ;   Shift (HL) left (C) bits.
2062   DD04             ;
2063   DD04 0C          SHIFTL:	INC	C
2064   DD05 0D          SHIFTL1:	DEC	C
2065   DD06 C8          	RET	Z
2066   DD07 29          	ADD	HL,HL			;shift left 1 bit.
2067   DD08 C3 05 DD    	JP	SHIFTL1
2068   DD0B             ;
2069   DD0B             ;   Routine to set a bit in a 16 bit value contained in (BC).
2070   DD0B             ; The bit set depends on the current drive selection.
2071   DD0B             ;
2072   DD0B C5          SETBIT:	PUSH	BC			;save 16 bit word.
2073   DD0C 3A 42 DB    	LD	A,(ACTIVE)		;get active drive.
2074   DD0F 4F          	LD	C,A
2075   DD10 21 01 00    	LD	HL,1
2076   DD13 CD 04 DD    	CALL	SHIFTL		;shift bit 0 into place.
2077   DD16 C1          	POP	BC			;now 'or' this with the original word.
2078   DD17 79          	LD	A,C
2079   DD18 B5          	OR	L
2080   DD19 6F          	LD	L,A			;low byte done, do high byte.
2081   DD1A 78          	LD	A,B
2082   DD1B B4          	OR	H
2083   DD1C 67          	LD	H,A
2084   DD1D C9          	RET	
2085   DD1E             ;
2086   DD1E             ;   Extract the write protect status bit for the current drive.
2087   DD1E             ; The result is returned in (A), bit 0.
2088   DD1E             ;
2089   DD1E 2A AD E5    GETWPRT:	LD	HL,(WRTPRT)	;get status bytes.
2090   DD21 3A 42 DB    	LD	A,(ACTIVE)		;which drive is current?
2091   DD24 4F          	LD	C,A
2092   DD25 CD EA DC    	CALL	SHIFTR		;shift status such that bit 0 is the
2093   DD28 7D          	LD	A,L			;one of interest for this drive.
2094   DD29 E6 01       	AND	01H			;and isolate it.
2095   DD2B C9          	RET	
2096   DD2C             ;
2097   DD2C             ;   Function to write protect the current disk.
2098   DD2C             ;
2099   DD2C 21 AD E5    WRTPRTD:	LD	HL,WRTPRT		;point to status word.
2100   DD2F 4E          	LD	C,(HL)		;set (BC) equal to the status.
2101   DD30 23          	INC	HL
2102   DD31 46          	LD	B,(HL)
2103   DD32 CD 0B DD    	CALL	SETBIT		;and set this bit according to current drive.
2104   DD35 22 AD E5    	LD	(WRTPRT),HL	;then save.
2105   DD38 2A C8 E5    	LD	HL,(DIRSIZE)	;now save directory size limit.
2106   DD3B 23          	INC	HL			;remember the last one.
2107   DD3C EB          	EX	DE,HL
2108   DD3D 2A B3 E5    	LD	HL,(SCRATCH1)	;and store it here.
2109   DD40 73          	LD	(HL),E		;put low byte.
2110   DD41 23          	INC	HL
2111   DD42 72          	LD	(HL),D		;then high byte.
2112   DD43 C9          	RET	
2113   DD44             ;
2114   DD44             ;   Check for a read only file.
2115   DD44             ;
2116   DD44 CD 5E DD    CHKROFL:	CALL	FCB2HL		;set (HL) to file entry in directory buffer.
2117   DD47 11 09 00    CKROF1:	LD	DE,9			;look at bit 7 of the ninth byte.
2118   DD4A 19          	ADD	HL,DE
2119   DD4B 7E          	LD	A,(HL)
2120   DD4C 17          	RLA	
2121   DD4D D0          	RET	NC			;return if ok.
2122   DD4E 21 0F D8    	LD	HL,ROFILE		;else, print error message and terminate.
2123   DD51 C3 4A DB    	JP	JUMPHL
2124   DD54             ;
2125   DD54             ;   Check the write protect status of the active disk.
2126   DD54             ;
2127   DD54 CD 1E DD    CHKWPRT:	CALL	GETWPRT
2128   DD57 C8          	RET	Z			;return if ok.
2129   DD58 21 0D D8    	LD	HL,RODISK		;else print message and terminate.
2130   DD5B C3 4A DB    	JP	JUMPHL
2131   DD5E             ;
2132   DD5E             ;   Routine to set (HL) pointing to the proper entry in the
2133   DD5E             ; directory buffer.
2134   DD5E             ;
2135   DD5E 2A B9 E5    FCB2HL:	LD	HL,(DIRBUF)	;get address of buffer.
2136   DD61 3A E9 E5    		LD	A,(FCBPOS)		;relative position of file.
2137   DD64             ;
2138   DD64             ;   Routine to add (A) to (HL).
2139   DD64             ;
2140   DD64 85          ADDA2HL:	ADD	A,L
2141   DD65 6F          	LD	L,A
2142   DD66 D0          	RET	NC
2143   DD67 24          	INC	H			;take care of any carry.
2144   DD68 C9          	RET	
2145   DD69             ;
2146   DD69             ;   Routine to get the 's2' byte from the fcb supplied in
2147   DD69             ; the initial parameter specification.
2148   DD69             ;
2149   DD69 2A 43 DB    GETS2:	LD	HL,(PARAMS)	;get address of fcb.
2150   DD6C 11 0E 00    	LD	DE,14			;relative position of 's2'.
2151   DD6F 19          	ADD	HL,DE
2152   DD70 7E          	LD	A,(HL)		;extract this byte.
2153   DD71 C9          	RET	
2154   DD72             ;
2155   DD72             ;   Clear the 's2' byte in the fcb.
2156   DD72             ;
2157   DD72 CD 69 DD    CLEARS2:	CALL	GETS2			;this sets (HL) pointing to it.
2158   DD75 36 00       	LD	(HL),0		;now clear it.
2159   DD77 C9          	RET	
2160   DD78             ;
2161   DD78             ;   Set bit 7 in the 's2' byte of the fcb.
2162   DD78             ;
2163   DD78 CD 69 DD    SETS2B7:	CALL	GETS2			;get the byte.
2164   DD7B F6 80       	OR	80H			;and set bit 7.
2165   DD7D 77          	LD	(HL),A		;then store.
2166   DD7E C9          	RET	
2167   DD7F             ;
2168   DD7F             ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
2169   DD7F             ; the difference. This checks to see if there are more file
2170   DD7F             ; names in the directory. We are at (FILEPOS) and there are
2171   DD7F             ; (SCRATCH1) of them to check.
2172   DD7F             ;
2173   DD7F 2A EA E5    MOREFLS:	LD	HL,(FILEPOS)	;we are here.
2174   DD82 EB          	EX	DE,HL
2175   DD83 2A B3 E5    	LD	HL,(SCRATCH1)	;and don't go past here.
2176   DD86 7B          	LD	A,E			;compute difference but don't keep.
2177   DD87 96          	SUB	(HL)
2178   DD88 23          	INC	HL
2179   DD89 7A          	LD	A,D
2180   DD8A 9E          	SBC	A,(HL)		;set carry if no more names.
2181   DD8B C9          	RET	
2182   DD8C             ;
2183   DD8C             ;   Call this routine to prevent (SCRATCH1) from being greater
2184   DD8C             ; than (FILEPOS).
2185   DD8C             ;
2186   DD8C CD 7F DD    CHKNMBR:	CALL	MOREFLS		;SCRATCH1 too big?
2187   DD8F D8          	RET	C
2188   DD90 13          	INC	DE			;yes, reset it to (FILEPOS).
2189   DD91 72          	LD	(HL),D
2190   DD92 2B          	DEC	HL
2191   DD93 73          	LD	(HL),E
2192   DD94 C9          	RET	
2193   DD95             ;
2194   DD95             ;   Compute (HL)=(DE)-(HL)
2195   DD95             ;
2196   DD95 7B          SUBHL:	LD	A,E			;compute difference.
2197   DD96 95          	SUB	L
2198   DD97 6F          	LD	L,A			;store low byte.
2199   DD98 7A          	LD	A,D
2200   DD99 9C          	SBC	A,H
2201   DD9A 67          	LD	H,A			;and then high byte.
2202   DD9B C9          	RET	
2203   DD9C             ;
2204   DD9C             ;   Set the directory checksum byte.
2205   DD9C             ;
2206   DD9C 0E FF       SETDIR:	LD	C,0FFH
2207   DD9E             ;
2208   DD9E             ;   Routine to set or compare the directory checksum byte. If
2209   DD9E             ; (C)=0ffh, then this will set the checksum byte. Else the byte
2210   DD9E             ; will be checked. If the check fails (the disk has been changed),
2211   DD9E             ; then this disk will be write protected.
2212   DD9E             ;
2213   DD9E 2A EC E5    CHECKDIR: 	LD	HL,(CKSUMTBL)
2214   DDA1 EB          	EX	DE,HL
2215   DDA2 2A CC E5    	LD	HL,(ALLOC1)
2216   DDA5 CD 95 DD    	CALL	SUBHL
2217   DDA8 D0          	RET	NC			;ok if (CKSUMTBL) > (ALLOC1), so return.
2218   DDA9 C5          	PUSH	BC
2219   DDAA CD F7 DC    	CALL	CHECKSUM		;else compute checksum.
2220   DDAD 2A BD E5    	LD	HL,(CHKVECT)	;get address of checksum table.
2221   DDB0 EB          	EX	DE,HL
2222   DDB1 2A EC E5    	LD	HL,(CKSUMTBL)
2223   DDB4 19          	ADD	HL,DE			;set (HL) to point to byte for this drive.
2224   DDB5 C1          	POP	BC
2225   DDB6 0C          	INC	C			;set or check ?
2226   DDB7 CA C4 DD    	JP	Z,CHKDIR1
2227   DDBA BE          	CP	(HL)			;check them.
2228   DDBB C8          	RET	Z			;return if they are the same.
2229   DDBC CD 7F DD    	CALL	MOREFLS		;not the same, do we care?
2230   DDBF D0          	RET	NC
2231   DDC0 CD 2C DD    	CALL	WRTPRTD		;yes, mark this as write protected.
2232   DDC3 C9          	RET	
2233   DDC4 77          CHKDIR1:	LD	(HL),A		;just set the byte.
2234   DDC5 C9          		RET	
2235   DDC6             ;
2236   DDC6             ;   Do a write to the directory of the current disk.
2237   DDC6             ;
2238   DDC6 CD 9C DD    DIRWRITE: 	CALL	SETDIR		;set checksum byte.
2239   DDC9 CD E0 DD    	CALL	DIRDMA		;set directory dma address.
2240   DDCC 0E 01       	LD	C,1			;tell the bios to actually write.
2241   DDCE CD B8 DB    	CALL	DOWRITE		;then do the write.
2242   DDD1 C3 DA DD    	JP	DEFDMA
2243   DDD4             ;
2244   DDD4             ;   Read from the directory.
2245   DDD4             ;
2246   DDD4 CD E0 DD    DIRREAD:	CALL	DIRDMA		;set the directory dma address.
2247   DDD7 CD B2 DB    	CALL	DOREAD		;and read it.
2248   DDDA             ;
2249   DDDA             ;   Routine to set the dma address to the users choice.
2250   DDDA             ;
2251   DDDA 21 B1 E5    DEFDMA:	LD	HL,USERDMA		;reset the default dma address and return.
2252   DDDD C3 E3 DD    		JP	DIRDMA1
2253   DDE0             ;
2254   DDE0             ;   Routine to set the dma address for directory work.
2255   DDE0             ;
2256   DDE0 21 B9 E5    DIRDMA:	LD	HL,DIRBUF
2257   DDE3             ;
2258   DDE3             ;   Set the dma address. On entry, (HL) points to
2259   DDE3             ; word containing the desired dma address.
2260   DDE3             ;
2261   DDE3 4E          DIRDMA1:	LD	C,(HL)
2262   DDE4 23          	INC	HL
2263   DDE5 46          	LD	B,(HL)		;setup (BC) and go to the bios to set it.
2264   DDE6 C3 24 E6    	JP	SETDMA
2265   DDE9             ;
2266   DDE9             ;   Move the directory buffer into user's dma space.
2267   DDE9             ;
2268   DDE9 2A B9 E5    MOVEDIR:	LD	HL,(DIRBUF)	;buffer is located here, and
2269   DDEC EB          	EX	DE,HL
2270   DDED 2A B1 E5    	LD	HL,(USERDMA)	; put it here.
2271   DDF0 0E 80       	LD	C,128			;this is its length.
2272   DDF2 C3 4F DB    	JP	DE2HL			;move it now and return.
2273   DDF5             ;
2274   DDF5             ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
2275   DDF5             ;
2276   DDF5 21 EA E5    CKFILPOS: 	LD	HL,FILEPOS
2277   DDF8 7E          	LD	A,(HL)
2278   DDF9 23          	INC	HL
2279   DDFA BE          	CP	(HL)			;are both bytes the same?
2280   DDFB C0          	RET	NZ
2281   DDFC 3C          	INC	A			;yes, but are they each 0ffh?
2282   DDFD C9          	RET	
2283   DDFE             ;
2284   DDFE             ;   Set location (FILEPOS) to 0ffffh.
2285   DDFE             ;
2286   DDFE 21 FF FF    STFILPOS: 	LD	HL,0FFFFH
2287   DE01 22 EA E5    	LD	(FILEPOS),HL
2288   DE04 C9          	RET	
2289   DE05             ;
2290   DE05             ;   Move on to the next file position within the current
2291   DE05             ; directory buffer. If no more exist, set pointer to 0ffffh
2292   DE05             ; and the calling routine will check for this. Enter with (C)
2293   DE05             ; equal to 0ffh to cause the checksum byte to be set, else we
2294   DE05             ; will check this disk and set write protect if checksums are
2295   DE05             ; not the same (applies only if another directory sector must
2296   DE05             ; be read).
2297   DE05             ;
2298   DE05 2A C8 E5    NXENTRY:	LD	HL,(DIRSIZE)	;get directory entry size limit.
2299   DE08 EB          	EX	DE,HL
2300   DE09 2A EA E5    	LD	HL,(FILEPOS)	;get current count.
2301   DE0C 23          	INC	HL			;go on to the next one.
2302   DE0D 22 EA E5    	LD	(FILEPOS),HL
2303   DE10 CD 95 DD    	CALL	SUBHL			;(HL)=(DIRSIZE)-(FILEPOS)
2304   DE13 D2 19 DE    	JP	NC,NXENT1		;is there more room left?
2305   DE16 C3 FE DD    	JP	STFILPOS		;no. Set this flag and return.
2306   DE19 3A EA E5    NXENT1:	LD	A,(FILEPOS)	;get file position within directory.
2307   DE1C E6 03       	AND	03H			;only look within this sector (only 4 entries fit).
2308   DE1E 06 05       	LD	B,5			;convert to relative position (32 bytes each).
2309   DE20 87          NXENT2:	ADD	A,A			;note that this is not efficient code.
2310   DE21 05          	DEC	B			;5 'ADD A's would be better.
2311   DE22 C2 20 DE    	JP	NZ,NXENT2
2312   DE25 32 E9 E5    	LD	(FCBPOS),A		;save it as position of fcb.
2313   DE28 B7          	OR	A
2314   DE29 C0          	RET	NZ			;return if we are within buffer.
2315   DE2A C5          	PUSH	BC
2316   DE2B CD C3 DB    	CALL	TRKSEC		;we need the next directory sector.
2317   DE2E CD D4 DD    	CALL	DIRREAD
2318   DE31 C1          	POP	BC
2319   DE32 C3 9E DD    	JP	CHECKDIR
2320   DE35             ;
2321   DE35             ;   Routine to to get a bit from the disk space allocation
2322   DE35             ; map. It is returned in (A), bit position 0. On entry to here,
2323   DE35             ; set (BC) to the block number on the disk to check.
2324   DE35             ; On return, (D) will contain the original bit position for
2325   DE35             ; this block number and (HL) will point to the address for it.
2326   DE35             ;
2327   DE35 79          CKBITMAP: 	LD	A,C			;determine bit number of interest.
2328   DE36 E6 07       	AND	07H			;compute (D)=(E)=(C and 7)+1.
2329   DE38 3C          	INC	A
2330   DE39 5F          	LD	E,A			;save particular bit number.
2331   DE3A 57          	LD	D,A
2332   DE3B             ;
2333   DE3B             ;   compute (BC)=(BC)/8.
2334   DE3B             ;
2335   DE3B 79          	LD	A,C
2336   DE3C 0F          	RRCA				;now shift right 3 bits.
2337   DE3D 0F          	RRCA	
2338   DE3E 0F          	RRCA	
2339   DE3F E6 1F       	AND	1FH			;and clear bits 7,6,5.
2340   DE41 4F          	LD	C,A
2341   DE42 78          	LD	A,B
2342   DE43 87          	ADD	A,A			;now shift (B) into bits 7,6,5.
2343   DE44 87          	ADD	A,A
2344   DE45 87          	ADD	A,A
2345   DE46 87          	ADD	A,A
2346   DE47 87          	ADD	A,A
2347   DE48 B1          	OR	C			;and add in (C).
2348   DE49 4F          	LD	C,A			;ok, (C) ha been completed.
2349   DE4A 78          	LD	A,B			;is there a better way of doing this?
2350   DE4B 0F          	RRCA	
2351   DE4C 0F          	RRCA	
2352   DE4D 0F          	RRCA	
2353   DE4E E6 1F       	AND	1FH
2354   DE50 47          	LD	B,A			;and now (B) is completed.
2355   DE51             ;
2356   DE51             ;   use this as an offset into the disk space allocation
2357   DE51             ; table.
2358   DE51             ;
2359   DE51 2A BF E5    	LD	HL,(ALOCVECT)
2360   DE54 09          	ADD	HL,BC
2361   DE55 7E          	LD	A,(HL)		;now get correct byte.
2362   DE56 07          CKBMAP1:	RLCA				;get correct bit into position 0.
2363   DE57 1D          	DEC	E
2364   DE58 C2 56 DE    	JP	NZ,CKBMAP1
2365   DE5B C9          	RET	
2366   DE5C             ;
2367   DE5C             ;   Set or clear the bit map such that block number (BC) will be marked
2368   DE5C             ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
2369   DE5C             ; 1 then it will be set (don't use anyother values).
2370   DE5C             ;
2371   DE5C D5          STBITMAP: 	PUSH	DE
2372   DE5D CD 35 DE    	CALL	CKBITMAP		;get the byte of interest.
2373   DE60 E6 FE       	AND	0FEH			;clear the affected bit.
2374   DE62 C1          	POP	BC
2375   DE63 B1          	OR	C			;and now set it acording to (C).
2376   DE64             ;
2377   DE64             ;  entry to restore the original bit position and then store
2378   DE64             ; in table. (A) contains the value, (D) contains the bit
2379   DE64             ; position (1-8), and (HL) points to the address within the
2380   DE64             ; space allocation table for this byte.
2381   DE64             ;
2382   DE64 0F          STBMAP1:	RRCA				;restore original bit position.
2383   DE65 15          	DEC	D
2384   DE66 C2 64 DE    	JP	NZ,STBMAP1
2385   DE69 77          	LD	(HL),A		;and stor byte in table.
2386   DE6A C9          	RET	
2387   DE6B             ;
2388   DE6B             ;   Set/clear space used bits in allocation map for this file.
2389   DE6B             ; On entry, (C)=1 to set the map and (C)=0 to clear it.
2390   DE6B             ;
2391   DE6B CD 5E DD    SETFILE:	CALL	FCB2HL		;get address of fcb
2392   DE6E 11 10 00    	LD	DE,16
2393   DE71 19          	ADD	HL,DE			;get to block number bytes.
2394   DE72 C5          	PUSH	BC
2395   DE73 0E 11       	LD	C,17			;check all 17 bytes (max) of table.
2396   DE75 D1          SETFL1:	POP	DE
2397   DE76 0D          	DEC	C			;done all bytes yet?
2398   DE77 C8          	RET	Z
2399   DE78 D5          	PUSH	DE
2400   DE79 3A DD E5    	LD	A,(BIGDISK)	;check disk size for 16 bit block numbers.
2401   DE7C B7          	OR	A
2402   DE7D CA 88 DE    	JP	Z,SETFL2
2403   DE80 C5          	PUSH	BC			;only 8 bit numbers. set (BC) to this one.
2404   DE81 E5          	PUSH	HL
2405   DE82 4E          	LD	C,(HL)		;get low byte from table, always
2406   DE83 06 00       	LD	B,0			;set high byte to zero.
2407   DE85 C3 8E DE    	JP	SETFL3
2408   DE88 0D          SETFL2:	DEC	C			;for 16 bit block numbers, adjust counter.
2409   DE89 C5          	PUSH	BC
2410   DE8A 4E          	LD	C,(HL)		;now get both the low and high bytes.
2411   DE8B 23          	INC	HL
2412   DE8C 46          	LD	B,(HL)
2413   DE8D E5          	PUSH	HL
2414   DE8E 79          SETFL3:	LD	A,C			;block used?
2415   DE8F B0          	OR	B
2416   DE90 CA 9D DE    	JP	Z,SETFL4
2417   DE93 2A C6 E5    	LD	HL,(DSKSIZE)	;is this block number within the
2418   DE96 7D          	LD	A,L			;space on the disk?
2419   DE97 91          	SUB	C
2420   DE98 7C          	LD	A,H
2421   DE99 98          	SBC	A,B
2422   DE9A D4 5C DE    	CALL	NC,STBITMAP	;yes, set the proper bit.
2423   DE9D E1          SETFL4:	POP	HL			;point to next block number in fcb.
2424   DE9E 23          	INC	HL
2425   DE9F C1          	POP	BC
2426   DEA0 C3 75 DE    	JP	SETFL1
2427   DEA3             ;
2428   DEA3             ;   Construct the space used allocation bit map for the active
2429   DEA3             ; drive. If a file name starts with '$' and it is under the
2430   DEA3             ; current user number, then (STATUS) is set to minus 1. Otherwise
2431   DEA3             ; it is not set at all.
2432   DEA3             ;
2433   DEA3 2A C6 E5    BITMAP:	LD	HL,(DSKSIZE)	;compute size of allocation table.
2434   DEA6 0E 03       	LD	C,3
2435   DEA8 CD EA DC    	CALL	SHIFTR		;(HL)=(HL)/8.
2436   DEAB 23          	INC	HL			;at lease 1 byte.
2437   DEAC 44          	LD	B,H
2438   DEAD 4D          	LD	C,L			;set (BC) to the allocation table length.
2439   DEAE             ;
2440   DEAE             ;   Initialize the bitmap for this drive. Right now, the first
2441   DEAE             ; two bytes are specified by the disk parameter block. However
2442   DEAE             ; a patch could be entered here if it were necessary to setup
2443   DEAE             ; this table in a special mannor. For example, the bios could
2444   DEAE             ; determine locations of 'bad blocks' and set them as already
2445   DEAE             ; 'used' in the map.
2446   DEAE             ;
2447   DEAE 2A BF E5    	LD	HL,(ALOCVECT)		;now zero out the table now.
2448   DEB1 36 00       BITMAP1:	LD	(HL),0
2449   DEB3 23          	INC	HL
2450   DEB4 0B          	DEC	BC
2451   DEB5 78          	LD	A,B
2452   DEB6 B1          	OR	C
2453   DEB7 C2 B1 DE    	JP	NZ,BITMAP1
2454   DEBA 2A CA E5    	LD	HL,(ALLOC0)	;get initial space used by directory.
2455   DEBD EB          	EX	DE,HL
2456   DEBE 2A BF E5    	LD	HL,(ALOCVECT)	;and put this into map.
2457   DEC1 73          	LD	(HL),E
2458   DEC2 23          	INC	HL
2459   DEC3 72          	LD	(HL),D
2460   DEC4             ;
2461   DEC4             ;   End of initialization portion.
2462   DEC4             ;
2463   DEC4 CD A1 DB    	CALL	HOMEDRV		;now home the drive.
2464   DEC7 2A B3 E5    	LD	HL,(SCRATCH1)
2465   DECA 36 03       	LD	(HL),3		;force next directory request to read
2466   DECC 23          	INC	HL			;in a sector.
2467   DECD 36 00       	LD	(HL),0
2468   DECF CD FE DD    	CALL	STFILPOS		;clear initial file position also.
2469   DED2 0E FF       BITMAP2:	LD	C,0FFH		;read next file name in directory
2470   DED4 CD 05 DE    	CALL	NXENTRY		;and set checksum byte.
2471   DED7 CD F5 DD    	CALL	CKFILPOS		;is there another file?
2472   DEDA C8          	RET	Z
2473   DEDB CD 5E DD    	CALL	FCB2HL		;yes, get its address.
2474   DEDE 3E E5       	LD	A,0E5H
2475   DEE0 BE          	CP	(HL)			;empty file entry?
2476   DEE1 CA D2 DE    	JP	Z,BITMAP2
2477   DEE4 3A 41 DB    	LD	A,(USERNO)		;no, correct user number?
2478   DEE7 BE          	CP	(HL)
2479   DEE8 C2 F6 DE    	JP	NZ,BITMAP3
2480   DEEB 23          	INC	HL
2481   DEEC 7E          	LD	A,(HL)		;yes, does name start with a '$'?
2482   DEED D6 24       	SUB	'$'
2483   DEEF C2 F6 DE    	JP	NZ,BITMAP3
2484   DEF2 3D          	DEC	A			;yes, set atatus to minus one.
2485   DEF3 32 45 DB    	LD	(STATUS),A
2486   DEF6 0E 01       BITMAP3:	LD	C,1			;now set this file's space as used in bit map.
2487   DEF8 CD 6B DE    	CALL	SETFILE
2488   DEFB CD 8C DD    	CALL	CHKNMBR		;keep (SCRATCH1) in bounds.
2489   DEFE C3 D2 DE    	JP	BITMAP2
2490   DF01             ;
2491   DF01             ;   Set the status (STATUS) and return.
2492   DF01             ;
2493   DF01 3A D4 E5    STSTATUS: 	LD	A,(FNDSTAT)
2494   DF04 C3 01 DB    		JP	SETSTAT
2495   DF07             ;
2496   DF07             ;   Check extents in (A) and (C). Set the zero flag if they
2497   DF07             ; are the same. The number of 16k chunks of disk space that
2498   DF07             ; the directory extent covers is expressad is (EXTMASK+1).
2499   DF07             ; No registers are modified.
2500   DF07             ;
2501   DF07 C5          SAMEXT:	PUSH	BC
2502   DF08 F5          	PUSH	AF
2503   DF09 3A C5 E5    	LD	A,(EXTMASK)	;get extent mask and use it to
2504   DF0C 2F          	CPL				;to compare both extent numbers.
2505   DF0D 47          	LD	B,A			;save resulting mask here.
2506   DF0E 79          	LD	A,C			;mask first extent and save in (C).
2507   DF0F A0          	AND	B
2508   DF10 4F          	LD	C,A
2509   DF11 F1          	POP	AF			;now mask second extent and compare
2510   DF12 A0          	AND	B			;with the first one.
2511   DF13 91          	SUB	C
2512   DF14 E6 1F       	AND	1FH			;(* only check buts 0-4 *)
2513   DF16 C1          	POP	BC			;the zero flag is set if they are the same.
2514   DF17 C9          	RET				;restore (BC) and return.
2515   DF18             ;
2516   DF18             ;   Search for the first occurence of a file name. On entry,
2517   DF18             ; register (C) should contain the number of bytes of the fcb
2518   DF18             ; that must match.
2519   DF18             ;
2520   DF18 3E FF       FINDFST:	LD	A,0FFH
2521   DF1A 32 D4 E5    	LD	(FNDSTAT),A
2522   DF1D 21 D8 E5    	LD	HL,COUNTER		;save character count.
2523   DF20 71          	LD	(HL),C
2524   DF21 2A 43 DB    	LD	HL,(PARAMS)	;get filename to match.
2525   DF24 22 D9 E5    	LD	(SAVEFCB),HL	;and save.
2526   DF27 CD FE DD    	CALL	STFILPOS		;clear initial file position (set to 0ffffh).
2527   DF2A CD A1 DB    	CALL	HOMEDRV		;home the drive.
2528   DF2D             ;
2529   DF2D             ;   Entry to locate the next occurence of a filename within the
2530   DF2D             ; directory. The disk is not expected to have been changed. If
2531   DF2D             ; it was, then it will be write protected.
2532   DF2D             ;
2533   DF2D 0E 00       FINDNXT:	LD	C,0			;write protect the disk if changed.
2534   DF2F CD 05 DE    	CALL	NXENTRY		;get next filename entry in directory.
2535   DF32 CD F5 DD    	CALL	CKFILPOS		;is file position = 0ffffh?
2536   DF35 CA 94 DF    	JP	Z,FNDNXT6		;yes, exit now then.
2537   DF38 2A D9 E5    	LD	HL,(SAVEFCB)	;set (DE) pointing to filename to match.
2538   DF3B EB          	EX	DE,HL
2539   DF3C 1A          	LD	A,(DE)
2540   DF3D FE E5       	CP	0E5H			;empty directory entry?
2541   DF3F CA 4A DF    	JP	Z,FNDNXT1		;(* are we trying to reserect erased entries? *)
2542   DF42 D5          	PUSH	DE
2543   DF43 CD 7F DD    	CALL	MOREFLS		;more files in directory?
2544   DF46 D1          	POP	DE
2545   DF47 D2 94 DF    	JP	NC,FNDNXT6		;no more. Exit now.
2546   DF4A CD 5E DD    FNDNXT1:	CALL	FCB2HL		;get address of this fcb in directory.
2547   DF4D 3A D8 E5    	LD	A,(COUNTER)	;get number of bytes (characters) to check.
2548   DF50 4F          	LD	C,A
2549   DF51 06 00       	LD	B,0			;initialize byte position counter.
2550   DF53 79          FNDNXT2:	LD	A,C			;are we done with the compare?
2551   DF54 B7          	OR	A
2552   DF55 CA 83 DF    	JP	Z,FNDNXT5
2553   DF58 1A          	LD	A,(DE)		;no, check next byte.
2554   DF59 FE 3F       	CP	'?'			;don't care about this character?
2555   DF5B CA 7C DF    	JP	Z,FNDNXT4
2556   DF5E 78          	LD	A,B			;get bytes position in fcb.
2557   DF5F FE 0D       	CP	13			;don't care about the thirteenth byte either.
2558   DF61 CA 7C DF    	JP	Z,FNDNXT4
2559   DF64 FE 0C       	CP	12			;extent byte?
2560   DF66 1A          	LD	A,(DE)
2561   DF67 CA 73 DF    	JP	Z,FNDNXT3
2562   DF6A 96          	SUB	(HL)			;otherwise compare characters.
2563   DF6B E6 7F       	AND	7FH
2564   DF6D C2 2D DF    	JP	NZ,FINDNXT		;not the same, check next entry.
2565   DF70 C3 7C DF    	JP	FNDNXT4		;so far so good, keep checking.
2566   DF73 C5          FNDNXT3:	PUSH	BC			;check the extent byte here.
2567   DF74 4E          	LD	C,(HL)
2568   DF75 CD 07 DF    	CALL	SAMEXT
2569   DF78 C1          	POP	BC
2570   DF79 C2 2D DF    	JP	NZ,FINDNXT		;not the same, look some more.
2571   DF7C             ;
2572   DF7C             ;   So far the names compare. Bump pointers to the next byte
2573   DF7C             ; and continue until all (C) characters have been checked.
2574   DF7C             ;
2575   DF7C 13          FNDNXT4:	INC	DE			;bump pointers.
2576   DF7D 23          	INC	HL
2577   DF7E 04          	INC	B
2578   DF7F 0D          	DEC	C			;adjust character counter.
2579   DF80 C3 53 DF    	JP	FNDNXT2
2580   DF83 3A EA E5    FNDNXT5:	LD	A,(FILEPOS)	;return the position of this entry.
2581   DF86 E6 03       	AND	03H
2582   DF88 32 45 DB    	LD	(STATUS),A
2583   DF8B 21 D4 E5    	LD	HL,FNDSTAT
2584   DF8E 7E          	LD	A,(HL)
2585   DF8F 17          	RLA	
2586   DF90 D0          	RET	NC
2587   DF91 AF          	XOR	A
2588   DF92 77          	LD	(HL),A
2589   DF93 C9          	RET	
2590   DF94             ;
2591   DF94             ;   Filename was not found. Set appropriate status.
2592   DF94             ;
2593   DF94 CD FE DD    FNDNXT6:	CALL	STFILPOS		;set (FILEPOS) to 0ffffh.
2594   DF97 3E FF       	LD	A,0FFH		;say not located.
2595   DF99 C3 01 DB    	JP	SETSTAT
2596   DF9C             ;
2597   DF9C             ;   Erase files from the directory. Only the first byte of the
2598   DF9C             ; fcb will be affected. It is set to (E5).
2599   DF9C             ;
2600   DF9C CD 54 DD    ERAFILE:	CALL	CHKWPRT		;is disk write protected?
2601   DF9F 0E 0C       	LD	C,12			;only compare file names.
2602   DFA1 CD 18 DF    	CALL	FINDFST		;get first file name.
2603   DFA4 CD F5 DD    ERAFIL1:	CALL	CKFILPOS		;any found?
2604   DFA7 C8          	RET	Z			;nope, we must be done.
2605   DFA8 CD 44 DD    	CALL	CHKROFL		;is file read only?
2606   DFAB CD 5E DD    	CALL	FCB2HL		;nope, get address of fcb and
2607   DFAE 36 E5       	LD	(HL),0E5H		;set first byte to 'empty'.
2608   DFB0 0E 00       	LD	C,0			;clear the space from the bit map.
2609   DFB2 CD 6B DE    	CALL	SETFILE
2610   DFB5 CD C6 DD    	CALL	DIRWRITE		;now write the directory sector back out.
2611   DFB8 CD 2D DF    	CALL	FINDNXT		;find the next file name.
2612   DFBB C3 A4 DF    	JP	ERAFIL1		;and repeat process.
2613   DFBE             ;
2614   DFBE             ;   Look through the space allocation map (bit map) for the
2615   DFBE             ; next available block. Start searching at block number (BC-1).
2616   DFBE             ; The search procedure is to look for an empty block that is
2617   DFBE             ; before the starting block. If not empty, look at a later
2618   DFBE             ; block number. In this way, we return the closest empty block
2619   DFBE             ; on either side of the 'target' block number. This will speed
2620   DFBE             ; access on random devices. For serial devices, this should be
2621   DFBE             ; changed to look in the forward direction first and then start
2622   DFBE             ; at the front and search some more.
2623   DFBE             ;
2624   DFBE             ;   On return, (DE)= block number that is empty and (HL) =0
2625   DFBE             ; if no empry block was found.
2626   DFBE             ;
2627   DFBE 50          FNDSPACE: 	LD	D,B			;set (DE) as the block that is checked.
2628   DFBF 59          		LD	E,C
2629   DFC0             ;
2630   DFC0             ;   Look before target block. Registers (BC) are used as the lower
2631   DFC0             ; pointer and (DE) as the upper pointer.
2632   DFC0             ;
2633   DFC0 79          FNDSPA1:	LD	A,C			;is block 0 specified?
2634   DFC1 B0          	OR	B
2635   DFC2 CA D1 DF    	JP	Z,FNDSPA2
2636   DFC5 0B          	DEC	BC			;nope, check previous block.
2637   DFC6 D5          	PUSH	DE
2638   DFC7 C5          	PUSH	BC
2639   DFC8 CD 35 DE    	CALL	CKBITMAP
2640   DFCB 1F          	RRA				;is this block empty?
2641   DFCC D2 EC DF    	JP	NC,FNDSPA3		;yes. use this.
2642   DFCF             ;
2643   DFCF             ;   Note that the above logic gets the first block that it finds
2644   DFCF             ; that is empty. Thus a file could be written 'backward' making
2645   DFCF             ; it very slow to access. This could be changed to look for the
2646   DFCF             ; first empty block and then continue until the start of this
2647   DFCF             ; empty space is located and then used that starting block.
2648   DFCF             ; This should help speed up access to some files especially on
2649   DFCF             ; a well used disk with lots of fairly small 'holes'.
2650   DFCF             ;
2651   DFCF C1          	POP	BC			;nope, check some more.
2652   DFD0 D1          	POP	DE
2653   DFD1             ;
2654   DFD1             ;   Now look after target block.
2655   DFD1             ;
2656   DFD1 2A C6 E5    FNDSPA2:	LD	HL,(DSKSIZE)	;is block (DE) within disk limits?
2657   DFD4 7B          	LD	A,E
2658   DFD5 95          	SUB	L
2659   DFD6 7A          	LD	A,D
2660   DFD7 9C          	SBC	A,H
2661   DFD8 D2 F4 DF    	JP	NC,FNDSPA4
2662   DFDB 13          	INC	DE			;yes, move on to next one.
2663   DFDC C5          	PUSH	BC
2664   DFDD D5          	PUSH	DE
2665   DFDE 42          	LD	B,D
2666   DFDF 4B          	LD	C,E
2667   DFE0 CD 35 DE    	CALL	CKBITMAP		;check it.
2668   DFE3 1F          	RRA				;empty?
2669   DFE4 D2 EC DF    	JP	NC,FNDSPA3
2670   DFE7 D1          	POP	DE			;nope, continue searching.
2671   DFE8 C1          	POP	BC
2672   DFE9 C3 C0 DF    	JP	FNDSPA1
2673   DFEC             ;
2674   DFEC             ;   Empty block found. Set it as used and return with (HL)
2675   DFEC             ; pointing to it (true?).
2676   DFEC             ;
2677   DFEC 17          FNDSPA3:	RLA				;reset byte.
2678   DFED 3C          	INC	A			;and set bit 0.
2679   DFEE CD 64 DE    	CALL	STBMAP1		;update bit map.
2680   DFF1 E1          	POP	HL			;set return registers.
2681   DFF2 D1          	POP	DE
2682   DFF3 C9          	RET	
2683   DFF4             ;
2684   DFF4             ;   Free block was not found. If (BC) is not zero, then we have
2685   DFF4             ; not checked all of the disk space.
2686   DFF4             ;
2687   DFF4 79          FNDSPA4:	LD	A,C
2688   DFF5 B0          	OR	B
2689   DFF6 C2 C0 DF    	JP	NZ,FNDSPA1
2690   DFF9 21 00 00    	LD	HL,0			;set 'not found' status.
2691   DFFC C9          	RET	
2692   DFFD             ;
2693   DFFD             ;   Move a complete fcb entry into the directory and write it.
2694   DFFD             ;
2695   DFFD 0E 00       FCBSET:	LD	C,0
2696   DFFF 1E 20       		LD	E,32			;length of each entry.
2697   E001             ;
2698   E001             ;   Move (E) bytes from the fcb pointed to by (PARAMS) into
2699   E001             ; fcb in directory starting at relative byte (C). This updated
2700   E001             ; directory buffer is then written to the disk.
2701   E001             ;
2702   E001 D5          UPDATE:	PUSH	DE
2703   E002 06 00       	LD	B,0			;set (BC) to relative byte position.
2704   E004 2A 43 DB    	LD	HL,(PARAMS)	;get address of fcb.
2705   E007 09          	ADD	HL,BC			;compute starting byte.
2706   E008 EB          	EX	DE,HL
2707   E009 CD 5E DD    	CALL	FCB2HL		;get address of fcb to update in directory.
2708   E00C C1          	POP	BC			;set (C) to number of bytes to change.
2709   E00D CD 4F DB    	CALL	DE2HL
2710   E010 CD C3 DB    UPDATE1:	CALL	TRKSEC		;determine the track and sector affected.
2711   E013 C3 C6 DD    		JP	DIRWRITE		;then write this sector out.
2712   E016             ;
2713   E016             ;   Routine to change the name of all files on the disk with a
2714   E016             ; specified name. The fcb contains the current name as the
2715   E016             ; first 12 characters and the new name 16 bytes into the fcb.
2716   E016             ;
2717   E016 CD 54 DD    CHGNAMES: 	CALL	CHKWPRT		;check for a write protected disk.
2718   E019 0E 0C       	LD	C,12			;match first 12 bytes of fcb only.
2719   E01B CD 18 DF    	CALL	FINDFST		;get first name.
2720   E01E 2A 43 DB    	LD	HL,(PARAMS)	;get address of fcb.
2721   E021 7E          	LD	A,(HL)		;get user number.
2722   E022 11 10 00    	LD	DE,16			;move over to desired name.
2723   E025 19          	ADD	HL,DE
2724   E026 77          	LD	(HL),A		;keep same user number.
2725   E027 CD F5 DD    CHGNAM1:	CALL	CKFILPOS		;any matching file found?
2726   E02A C8          	RET	Z			;no, we must be done.
2727   E02B CD 44 DD    	CALL	CHKROFL		;check for read only file.
2728   E02E 0E 10       	LD	C,16			;start 16 bytes into fcb.
2729   E030 1E 0C       	LD	E,12			;and update the first 12 bytes of directory.
2730   E032 CD 01 E0    	CALL	UPDATE
2731   E035 CD 2D DF    	CALL	FINDNXT		;get te next file name.
2732   E038 C3 27 E0    	JP	CHGNAM1		;and continue.
2733   E03B             ;
2734   E03B             ;   Update a files attributes. The procedure is to search for
2735   E03B             ; every file with the same name as shown in fcb (ignoring bit 7)
2736   E03B             ; and then to update it (which includes bit 7). No other changes
2737   E03B             ; are made.
2738   E03B             ;
2739   E03B 0E 0C       SAVEATTR: 	LD	C,12			;match first 12 bytes.
2740   E03D CD 18 DF    		CALL	FINDFST		;look for first filename.
2741   E040 CD F5 DD    SAVATR1:	CALL	CKFILPOS		;was one found?
2742   E043 C8          	RET	Z			;nope, we must be done.
2743   E044 0E 00       	LD	C,0			;yes, update the first 12 bytes now.
2744   E046 1E 0C       	LD	E,12
2745   E048 CD 01 E0    	CALL	UPDATE		;update filename and write directory.
2746   E04B CD 2D DF    	CALL	FINDNXT		;and get the next file.
2747   E04E C3 40 E0    	JP	SAVATR1		;then continue until done.
2748   E051             ;
2749   E051             ;  Open a file (name specified in fcb).
2750   E051             ;
2751   E051 0E 0F       OPENIT:	LD	C,15			;compare the first 15 bytes.
2752   E053 CD 18 DF    	CALL	FINDFST		;get the first one in directory.
2753   E056 CD F5 DD    	CALL	CKFILPOS		;any at all?
2754   E059 C8          	RET	Z
2755   E05A CD A6 DC    OPENIT1:	CALL	SETEXT		;point to extent byte within users fcb.
2756   E05D 7E          	LD	A,(HL)		;and get it.
2757   E05E F5          	PUSH	AF			;save it and address.
2758   E05F E5          	PUSH	HL
2759   E060 CD 5E DD    	CALL	FCB2HL		;point to fcb in directory.
2760   E063 EB          	EX	DE,HL
2761   E064 2A 43 DB    	LD	HL,(PARAMS)	;this is the users copy.
2762   E067 0E 20       	LD	C,32			;move it into users space.
2763   E069 D5          	PUSH	DE
2764   E06A CD 4F DB    	CALL	DE2HL
2765   E06D CD 78 DD    	CALL	SETS2B7		;set bit 7 in 's2' byte (unmodified).
2766   E070 D1          	POP	DE			;now get the extent byte from this fcb.
2767   E071 21 0C 00    	LD	HL,12
2768   E074 19          	ADD	HL,DE
2769   E075 4E          	LD	C,(HL)		;into (C).
2770   E076 21 0F 00    	LD	HL,15			;now get the record count byte into (B).
2771   E079 19          	ADD	HL,DE
2772   E07A 46          	LD	B,(HL)
2773   E07B E1          	POP	HL			;keep the same extent as the user had originally.
2774   E07C F1          	POP	AF
2775   E07D 77          	LD	(HL),A
2776   E07E 79          	LD	A,C			;is it the same as in the directory fcb?
2777   E07F BE          	CP	(HL)	
2778   E080 78          	LD	A,B			;if yes, then use the same record count.
2779   E081 CA 8B E0    	JP	Z,OPENIT2
2780   E084 3E 00       	LD	A,0			;if the user specified an extent greater than
2781   E086 DA 8B E0    	JP	C,OPENIT2		;the one in the directory, then set record count to 0.
2782   E089 3E 80       	LD	A,128			;otherwise set to maximum.
2783   E08B 2A 43 DB    OPENIT2:	LD	HL,(PARAMS)	;set record count in users fcb to (A).
2784   E08E 11 0F 00    	LD	DE,15
2785   E091 19          	ADD	HL,DE			;compute relative position.
2786   E092 77          	LD	(HL),A		;and set the record count.
2787   E093 C9          	RET	
2788   E094             ;
2789   E094             ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
2790   E094             ; point to a zero value (16 bit).
2791   E094             ;   Return with zero flag set it (DE) was moved. Registers (DE)
2792   E094             ; and (HL) are not changed. However (A) is.
2793   E094             ;
2794   E094 7E          MOVEWORD: 	LD	A,(HL)		;check for a zero word.
2795   E095 23          	INC	HL
2796   E096 B6          	OR	(HL)			;both bytes zero?
2797   E097 2B          	DEC	HL
2798   E098 C0          	RET	NZ			;nope, just return.
2799   E099 1A          	LD	A,(DE)		;yes, move two bytes from (DE) into
2800   E09A 77          	LD	(HL),A		;this zero space.
2801   E09B 13          	INC	DE
2802   E09C 23          	INC	HL
2803   E09D 1A          	LD	A,(DE)
2804   E09E 77          	LD	(HL),A
2805   E09F 1B          	DEC	DE			;don't disturb these registers.
2806   E0A0 2B          	DEC	HL
2807   E0A1 C9          	RET	
2808   E0A2             ;
2809   E0A2             ;   Get here to close a file specified by (fcb).
2810   E0A2             ;
2811   E0A2 AF          CLOSEIT:	XOR	A			;clear status and file position bytes.
2812   E0A3 32 45 DB    	LD	(STATUS),A
2813   E0A6 32 EA E5    	LD	(FILEPOS),A
2814   E0A9 32 EB E5    	LD	(FILEPOS+1),A
2815   E0AC CD 1E DD    	CALL	GETWPRT		;get write protect bit for this drive.
2816   E0AF C0          	RET	NZ			;just return if it is set.
2817   E0B0 CD 69 DD    	CALL	GETS2			;else get the 's2' byte.
2818   E0B3 E6 80       	AND	80H			;and look at bit 7 (file unmodified?).
2819   E0B5 C0          	RET	NZ			;just return if set.
2820   E0B6 0E 0F       	LD	C,15			;else look up this file in directory.
2821   E0B8 CD 18 DF    	CALL	FINDFST
2822   E0BB CD F5 DD    	CALL	CKFILPOS		;was it found?
2823   E0BE C8          	RET	Z			;just return if not.
2824   E0BF 01 10 00    	LD	BC,16			;set (HL) pointing to records used section.
2825   E0C2 CD 5E DD    	CALL	FCB2HL
2826   E0C5 09          	ADD	HL,BC
2827   E0C6 EB          	EX	DE,HL
2828   E0C7 2A 43 DB    	LD	HL,(PARAMS)	;do the same for users specified fcb.
2829   E0CA 09          	ADD	HL,BC
2830   E0CB 0E 10       	LD	C,16			;this many bytes are present in this extent.
2831   E0CD 3A DD E5    CLOSEIT1: 	LD	A,(BIGDISK)	;8 or 16 bit record numbers?
2832   E0D0 B7          	OR	A
2833   E0D1 CA E8 E0    	JP	Z,CLOSEIT4
2834   E0D4 7E          	LD	A,(HL)		;just 8 bit. Get one from users fcb.
2835   E0D5 B7          	OR	A
2836   E0D6 1A          	LD	A,(DE)		;now get one from directory fcb.
2837   E0D7 C2 DB E0    	JP	NZ,CLOSEIT2
2838   E0DA 77          	LD	(HL),A		;users byte was zero. Update from directory.
2839   E0DB B7          CLOSEIT2: 	OR	A
2840   E0DC C2 E1 E0    	JP	NZ,CLOSEIT3
2841   E0DF 7E          	LD	A,(HL)		;directories byte was zero, update from users fcb.
2842   E0E0 12          	LD	(DE),A
2843   E0E1 BE          CLOSEIT3: 	CP	(HL)			;if neither one of these bytes were zero,
2844   E0E2 C2 1F E1    	JP	NZ,CLOSEIT7	;then close error if they are not the same.
2845   E0E5 C3 FD E0    	JP	CLOSEIT5		;ok so far, get to next byte in fcbs.
2846   E0E8 CD 94 E0    CLOSEIT4: 	CALL	MOVEWORD		;update users fcb if it is zero.
2847   E0EB EB          	EX	DE,HL
2848   E0EC CD 94 E0    	CALL	MOVEWORD		;update directories fcb if it is zero.
2849   E0EF EB          	EX	DE,HL
2850   E0F0 1A          	LD	A,(DE)		;if these two values are no different,
2851   E0F1 BE          	CP	(HL)			;then a close error occured.
2852   E0F2 C2 1F E1    	JP	NZ,CLOSEIT7
2853   E0F5 13          	INC	DE			;check second byte.
2854   E0F6 23          	INC	HL
2855   E0F7 1A          	LD	A,(DE)
2856   E0F8 BE          	CP	(HL)
2857   E0F9 C2 1F E1    	JP	NZ,CLOSEIT7
2858   E0FC 0D          	DEC	C			;remember 16 bit values.
2859   E0FD 13          CLOSEIT5: 	INC	DE			;bump to next item in table.
2860   E0FE 23          	INC	HL
2861   E0FF 0D          	DEC	C			;there are 16 entries only.
2862   E100 C2 CD E0    	JP	NZ,CLOSEIT1	;continue if more to do.
2863   E103 01 EC FF    	LD	BC,0FFECH		;backup 20 places (extent byte).
2864   E106 09          	ADD	HL,BC
2865   E107 EB          	EX	DE,HL
2866   E108 09          	ADD	HL,BC
2867   E109 1A          	LD	A,(DE)
2868   E10A BE          	CP	(HL)			;directory's extent already greater than the
2869   E10B DA 17 E1    	JP	C,CLOSEIT6		;users extent?
2870   E10E 77          	LD	(HL),A		;no, update directory extent.
2871   E10F 01 03 00    	LD	BC,3			;and update the record count byte in
2872   E112 09          	ADD	HL,BC			;directories fcb.
2873   E113 EB          	EX	DE,HL
2874   E114 09          	ADD	HL,BC
2875   E115 7E          	LD	A,(HL)		;get from user.
2876   E116 12          	LD	(DE),A		;and put in directory.
2877   E117 3E FF       CLOSEIT6: 	LD	A,0FFH		;set 'was open and is now closed' byte.
2878   E119 32 D2 E5    	LD	(CLOSEFLG),A
2879   E11C C3 10 E0    	JP	UPDATE1		;update the directory now.
2880   E11F 21 45 DB    CLOSEIT7: 	LD	HL,STATUS		;set return status and then return.
2881   E122 35          	DEC	(HL)
2882   E123 C9          	RET	
2883   E124             ;
2884   E124             ;   Routine to get the next empty space in the directory. It
2885   E124             ; will then be cleared for use.
2886   E124             ;
2887   E124 CD 54 DD    GETEMPTY: 	CALL	CHKWPRT		;make sure disk is not write protected.
2888   E127 2A 43 DB    	LD	HL,(PARAMS)	;save current parameters (fcb).
2889   E12A E5          	PUSH	HL
2890   E12B 21 AC E5    	LD	HL,EMPTYFCB	;use special one for empty space.
2891   E12E 22 43 DB    	LD	(PARAMS),HL
2892   E131 0E 01       	LD	C,1			;search for first empty spot in directory.
2893   E133 CD 18 DF    	CALL	FINDFST		;(* only check first byte *)
2894   E136 CD F5 DD    	CALL	CKFILPOS		;none?
2895   E139 E1          	POP	HL
2896   E13A 22 43 DB    	LD	(PARAMS),HL	;restore original fcb address.
2897   E13D C8          	RET	Z			;return if no more space.
2898   E13E EB          	EX	DE,HL
2899   E13F 21 0F 00    	LD	HL,15			;point to number of records for this file.
2900   E142 19          	ADD	HL,DE
2901   E143 0E 11       	LD	C,17			;and clear all of this space.
2902   E145 AF          	XOR	A
2903   E146 77          GETMT1:	LD	(HL),A
2904   E147 23          	INC	HL
2905   E148 0D          	DEC	C
2906   E149 C2 46 E1    	JP	NZ,GETMT1
2907   E14C 21 0D 00    	LD	HL,13			;clear the 's1' byte also.
2908   E14F 19          	ADD	HL,DE
2909   E150 77          	LD	(HL),A
2910   E151 CD 8C DD    	CALL	CHKNMBR		;keep (SCRATCH1) within bounds.
2911   E154 CD FD DF    	CALL	FCBSET		;write out this fcb entry to directory.
2912   E157 C3 78 DD    	JP	SETS2B7		;set 's2' byte bit 7 (unmodified at present).
2913   E15A             ;
2914   E15A             ;   Routine to close the current extent and open the next one
2915   E15A             ; for reading.
2916   E15A             ;
2917   E15A AF          GETNEXT:	XOR	A
2918   E15B 32 D2 E5    	LD	(CLOSEFLG),A	;clear close flag.
2919   E15E CD A2 E0    	CALL	CLOSEIT		;close this extent.
2920   E161 CD F5 DD    	CALL	CKFILPOS
2921   E164 C8          	RET	Z			;not there???
2922   E165 2A 43 DB    	LD	HL,(PARAMS)	;get extent byte.
2923   E168 01 0C 00    	LD	BC,12
2924   E16B 09          	ADD	HL,BC
2925   E16C 7E          	LD	A,(HL)		;and increment it.
2926   E16D 3C          	INC	A
2927   E16E E6 1F       	AND	1FH			;keep within range 0-31.
2928   E170 77          	LD	(HL),A
2929   E171 CA 83 E1    	JP	Z,GTNEXT1		;overflow?
2930   E174 47          	LD	B,A			;mask extent byte.
2931   E175 3A C5 E5    	LD	A,(EXTMASK)
2932   E178 A0          	AND	B
2933   E179 21 D2 E5    	LD	HL,CLOSEFLG	;check close flag (0ffh is ok).
2934   E17C A6          	AND	(HL)
2935   E17D CA 8E E1    	JP	Z,GTNEXT2		;if zero, we must read in next extent.
2936   E180 C3 AC E1    	JP	GTNEXT3		;else, it is already in memory.
2937   E183 01 02 00    GTNEXT1:	LD	BC,2			;Point to the 's2' byte.
2938   E186 09          	ADD	HL,BC
2939   E187 34          	INC	(HL)			;and bump it.
2940   E188 7E          	LD	A,(HL)		;too many extents?
2941   E189 E6 0F       	AND	0FH
2942   E18B CA B6 E1    	JP	Z,GTNEXT5		;yes, set error code.
2943   E18E             ;
2944   E18E             ;   Get here to open the next extent.
2945   E18E             ;
2946   E18E 0E 0F       GTNEXT2:	LD	C,15			;set to check first 15 bytes of fcb.
2947   E190 CD 18 DF    	CALL	FINDFST		;find the first one.
2948   E193 CD F5 DD    	CALL	CKFILPOS		;none available?
2949   E196 C2 AC E1    	JP	NZ,GTNEXT3
2950   E199 3A D3 E5    	LD	A,(RDWRTFLG)	;no extent present. Can we open an empty one?
2951   E19C 3C          	INC	A			;0ffh means reading (so not possible).
2952   E19D CA B6 E1    	JP	Z,GTNEXT5		;or an error.
2953   E1A0 CD 24 E1    	CALL	GETEMPTY		;we are writing, get an empty entry.
2954   E1A3 CD F5 DD    	CALL	CKFILPOS		;none?
2955   E1A6 CA B6 E1    	JP	Z,GTNEXT5		;error if true.
2956   E1A9 C3 AF E1    	JP	GTNEXT4		;else we are almost done.
2957   E1AC CD 5A E0    GTNEXT3:	CALL	OPENIT1		;open this extent.
2958   E1AF CD BB DC    GTNEXT4:	CALL	STRDATA		;move in updated data (rec #, extent #, etc.)
2959   E1B2 AF          	XOR	A			;clear status and return.
2960   E1B3 C3 01 DB    	JP	SETSTAT
2961   E1B6             ;
2962   E1B6             ;   Error in extending the file. Too many extents were needed
2963   E1B6             ; or not enough space on the disk.
2964   E1B6             ;
2965   E1B6 CD 05 DB    GTNEXT5:	CALL	IOERR1		;set error code, clear bit 7 of 's2'
2966   E1B9 C3 78 DD    		JP	SETS2B7		;so this is not written on a close.
2967   E1BC             ;
2968   E1BC             ;   Read a sequential file.
2969   E1BC             ;
2970   E1BC 3E 01       RDSEQ:	LD	A,1			;set sequential access mode.
2971   E1BE 32 D5 E5    		LD	(MODE),A
2972   E1C1 3E FF       RDSEQ1:	LD	A,0FFH		;don't allow reading unwritten space.
2973   E1C3 32 D3 E5    	LD	(RDWRTFLG),A
2974   E1C6 CD BB DC    	CALL	STRDATA		;put rec# and ext# into fcb.
2975   E1C9 3A E3 E5    	LD	A,(SAVNREC)	;get next record to read.
2976   E1CC 21 E1 E5    	LD	HL,SAVNXT		;get number of records in extent.
2977   E1CF BE          	CP	(HL)			;within this extent?
2978   E1D0 DA E6 E1    	JP	C,RDSEQ2
2979   E1D3 FE 80       	CP	128			;no. Is this extent fully used?
2980   E1D5 C2 FB E1    	JP	NZ,RDSEQ3		;no. End-of-file.
2981   E1D8 CD 5A E1    	CALL	GETNEXT		;yes, open the next one.
2982   E1DB AF          	XOR	A			;reset next record to read.
2983   E1DC 32 E3 E5    	LD	(SAVNREC),A
2984   E1DF 3A 45 DB    	LD	A,(STATUS)		;check on open, successful?
2985   E1E2 B7          	OR	A
2986   E1E3 C2 FB E1    	JP	NZ,RDSEQ3		;no, error.
2987   E1E6 CD 77 DC    RDSEQ2:	CALL	COMBLK		;ok. compute block number to read.
2988   E1E9 CD 84 DC    	CALL	CHKBLK		;check it. Within bounds?
2989   E1EC CA FB E1    	JP	Z,RDSEQ3		;no, error.
2990   E1EF CD 8A DC    	CALL	LOGICAL		;convert (BLKNMBR) to logical sector (128 byte).
2991   E1F2 CD D1 DB    	CALL	TRKSEC1		;set the track and sector for this block #.
2992   E1F5 CD B2 DB    	CALL	DOREAD		;and read it.
2993   E1F8 C3 D2 DC    	JP	SETNREC		;and set the next record to be accessed.
2994   E1FB             ;
2995   E1FB             ;   Read error occured. Set status and return.
2996   E1FB             ;
2997   E1FB C3 05 DB    RDSEQ3:	JP	IOERR1
2998   E1FE             ;
2999   E1FE             ;   Write the next sequential record.
3000   E1FE             ;
3001   E1FE 3E 01       WTSEQ:	LD	A,1			;set sequential access mode.
3002   E200 32 D5 E5    		LD	(MODE),A
3003   E203 3E 00       WTSEQ1:	LD	A,0			;allow an addition empty extent to be opened.
3004   E205 32 D3 E5    	LD	(RDWRTFLG),A
3005   E208 CD 54 DD    	CALL	CHKWPRT		;check write protect status.
3006   E20B 2A 43 DB    	LD	HL,(PARAMS)	
3007   E20E CD 47 DD    	CALL	CKROF1		;check for read only file, (HL) already set to fcb.
3008   E211 CD BB DC    	CALL	STRDATA		;put updated data into fcb.
3009   E214 3A E3 E5    	LD	A,(SAVNREC)	;get record number to write.
3010   E217 FE 80       	CP	128			;within range?
3011   E219 D2 05 DB    	JP	NC,IOERR1		;no, error(?).
3012   E21C CD 77 DC    	CALL	COMBLK		;compute block number.
3013   E21F CD 84 DC    	CALL	CHKBLK		;check number.
3014   E222 0E 00       	LD	C,0			;is there one to write to?
3015   E224 C2 6E E2    	JP	NZ,WTSEQ6		;yes, go do it.
3016   E227 CD 3E DC    	CALL	GETBLOCK		;get next block number within fcb to use.
3017   E22A 32 D7 E5    	LD	(RELBLOCK),A	;and save.
3018   E22D 01 00 00    	LD	BC,0			;start looking for space from the start
3019   E230 B7          	OR	A			;if none allocated as yet.
3020   E231 CA 3B E2    	JP	Z,WTSEQ2
3021   E234 4F          	LD	C,A			;extract previous block number from fcb
3022   E235 0B          	DEC	BC			;so we can be closest to it.
3023   E236 CD 5E DC    	CALL	EXTBLK
3024   E239 44          	LD	B,H
3025   E23A 4D          	LD	C,L
3026   E23B CD BE DF    WTSEQ2:	CALL	FNDSPACE		;find the next empty block nearest number (BC).
3027   E23E 7D          	LD	A,L			;check for a zero number.
3028   E23F B4          	OR	H
3029   E240 C2 48 E2    	JP	NZ,WTSEQ3
3030   E243 3E 02       	LD	A,2			;no more space?
3031   E245 C3 01 DB    	JP	SETSTAT
3032   E248 22 E5 E5    WTSEQ3:	LD	(BLKNMBR),HL	;save block number to access.
3033   E24B EB          	EX	DE,HL			;put block number into (DE).
3034   E24C 2A 43 DB    	LD	HL,(PARAMS)	;now we must update the fcb for this
3035   E24F 01 10 00    	LD	BC,16			;newly allocated block.
3036   E252 09          	ADD	HL,BC
3037   E253 3A DD E5    	LD	A,(BIGDISK)	;8 or 16 bit block numbers?
3038   E256 B7          	OR	A
3039   E257 3A D7 E5    	LD	A,(RELBLOCK)	;(* update this entry *)
3040   E25A CA 64 E2    	JP	Z,WTSEQ4		;zero means 16 bit ones.
3041   E25D CD 64 DD    	CALL	ADDA2HL		;(HL)=(HL)+(A)
3042   E260 73          	LD	(HL),E		;store new block number.
3043   E261 C3 6C E2    	JP	WTSEQ5
3044   E264 4F          WTSEQ4:	LD	C,A			;compute spot in this 16 bit table.
3045   E265 06 00       	LD	B,0
3046   E267 09          	ADD	HL,BC
3047   E268 09          	ADD	HL,BC
3048   E269 73          	LD	(HL),E		;stuff block number (DE) there.
3049   E26A 23          	INC	HL
3050   E26B 72          	LD	(HL),D
3051   E26C 0E 02       WTSEQ5:	LD	C,2			;set (C) to indicate writing to un-used disk space.
3052   E26E 3A 45 DB    WTSEQ6:	LD	A,(STATUS)		;are we ok so far?
3053   E271 B7          	OR	A
3054   E272 C0          	RET	NZ
3055   E273 C5          	PUSH	BC			;yes, save write flag for bios (register C).
3056   E274 CD 8A DC    	CALL	LOGICAL		;convert (BLKNMBR) over to loical sectors.
3057   E277 3A D5 E5    	LD	A,(MODE)		;get access mode flag (1=sequential,
3058   E27A 3D          	DEC	A			;0=random, 2=special?).
3059   E27B 3D          	DEC	A
3060   E27C C2 BB E2    	JP	NZ,WTSEQ9
3061   E27F             ;
3062   E27F             ;   Special random i/o from function #40. Maybe for M/PM, but the
3063   E27F             ; current block, if it has not been written to, will be zeroed
3064   E27F             ; out and then written (reason?).
3065   E27F             ;
3066   E27F C1          	POP	BC
3067   E280 C5          	PUSH	BC
3068   E281 79          	LD	A,C			;get write status flag (2=writing unused space).
3069   E282 3D          	DEC	A
3070   E283 3D          	DEC	A
3071   E284 C2 BB E2    	JP	NZ,WTSEQ9
3072   E287 E5          	PUSH	HL
3073   E288 2A B9 E5    	LD	HL,(DIRBUF)	;zero out the directory buffer.
3074   E28B 57          	LD	D,A			;note that (A) is zero here.
3075   E28C 77          WTSEQ7:	LD	(HL),A
3076   E28D 23          	INC	HL
3077   E28E 14          	INC	D			;do 128 bytes.
3078   E28F F2 8C E2    	JP	P,WTSEQ7
3079   E292 CD E0 DD    	CALL	DIRDMA		;tell the bios the dma address for directory access.
3080   E295 2A E7 E5    	LD	HL,(LOGSECT)	;get sector that starts current block.
3081   E298 0E 02       	LD	C,2			;set 'writing to unused space' flag.
3082   E29A 22 E5 E5    WTSEQ8:	LD	(BLKNMBR),HL	;save sector to write.
3083   E29D C5          	PUSH	BC
3084   E29E CD D1 DB    	CALL	TRKSEC1		;determine its track and sector numbers.
3085   E2A1 C1          	POP	BC
3086   E2A2 CD B8 DB    	CALL	DOWRITE		;now write out 128 bytes of zeros.
3087   E2A5 2A E5 E5    	LD	HL,(BLKNMBR)	;get sector number.
3088   E2A8 0E 00       	LD	C,0			;set normal write flag.
3089   E2AA 3A C4 E5    	LD	A,(BLKMASK)	;determine if we have written the entire
3090   E2AD 47          	LD	B,A			;physical block.
3091   E2AE A5          	AND	L
3092   E2AF B8          	CP	B
3093   E2B0 23          	INC	HL			;prepare for the next one.
3094   E2B1 C2 9A E2    	JP	NZ,WTSEQ8		;continue until (BLKMASK+1) sectors written.
3095   E2B4 E1          	POP	HL			;reset next sector number.
3096   E2B5 22 E5 E5    	LD	(BLKNMBR),HL
3097   E2B8 CD DA DD    	CALL	DEFDMA		;and reset dma address.
3098   E2BB             ;
3099   E2BB             ;   Normal disk write. Set the desired track and sector then
3100   E2BB             ; do the actual write.
3101   E2BB             ;
3102   E2BB CD D1 DB    WTSEQ9:	CALL	TRKSEC1		;determine track and sector for this write.
3103   E2BE C1          	POP	BC			;get write status flag.
3104   E2BF C5          	PUSH	BC
3105   E2C0 CD B8 DB    	CALL	DOWRITE		;and write this out.
3106   E2C3 C1          	POP	BC
3107   E2C4 3A E3 E5    	LD	A,(SAVNREC)	;get number of records in file.
3108   E2C7 21 E1 E5    	LD	HL,SAVNXT		;get last record written.
3109   E2CA BE          	CP	(HL)
3110   E2CB DA D2 E2    	JP	C,WTSEQ10
3111   E2CE 77          	LD	(HL),A		;we have to update record count.
3112   E2CF 34          	INC	(HL)
3113   E2D0 0E 02       	LD	C,2
3114   E2D2             ;
3115   E2D2             ;*   This area has been patched to correct disk update problem
3116   E2D2             ;* when using blocking and de-blocking in the BIOS.
3117   E2D2             ;
3118   E2D2 00          WTSEQ10:	NOP				;was 'dcr c'
3119   E2D3 00          	NOP				;was 'dcr c'
3120   E2D4 21 00 00    	LD	HL,0			;was 'jnz wtseq99'
3121   E2D7             ;
3122   E2D7             ; *   End of patch.
3123   E2D7             ;
3124   E2D7 F5          	PUSH	AF
3125   E2D8 CD 69 DD    	CALL	GETS2			;set 'extent written to' flag.
3126   E2DB E6 7F       	AND	7FH			;(* clear bit 7 *)
3127   E2DD 77          	LD	(HL),A
3128   E2DE F1          	POP	AF			;get record count for this extent.
3129   E2DF FE 7F       WTSEQ99:	CP	127			;is it full?
3130   E2E1 C2 00 E3    	JP	NZ,WTSEQ12
3131   E2E4 3A D5 E5    	LD	A,(MODE)		;yes, are we in sequential mode?
3132   E2E7 FE 01       	CP	1
3133   E2E9 C2 00 E3    	JP	NZ,WTSEQ12
3134   E2EC CD D2 DC    	CALL	SETNREC		;yes, set next record number.
3135   E2EF CD 5A E1    	CALL	GETNEXT		;and get next empty space in directory.
3136   E2F2 21 45 DB    	LD	HL,STATUS		;ok?
3137   E2F5 7E          	LD	A,(HL)
3138   E2F6 B7          	OR	A
3139   E2F7 C2 FE E2    	JP	NZ,WTSEQ11
3140   E2FA 3D          	DEC	A			;yes, set record count to -1.
3141   E2FB 32 E3 E5    	LD	(SAVNREC),A
3142   E2FE 36 00       WTSEQ11:	LD	(HL),0		;clear status.
3143   E300 C3 D2 DC    WTSEQ12:	JP	SETNREC		;set next record to access.
3144   E303             ;
3145   E303             ;   For random i/o, set the fcb for the desired record number
3146   E303             ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
3147   E303             ; used as follows:
3148   E303             ;
3149   E303             ;       fcb+35            fcb+34            fcb+33
3150   E303             ;  |     'r-2'      |      'r-1'      |      'r-0'     |
3151   E303             ;  |7             0 | 7             0 | 7             0|
3152   E303             ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
3153   E303             ;  |    overflow   | | extra |  extent   |   record #  |
3154   E303             ;  | ______________| |_extent|__number___|_____________|
3155   E303             ;                     also 's2'
3156   E303             ;
3157   E303             ;   On entry, register (C) contains 0ffh if this is a read
3158   E303             ; and thus we can not access unwritten disk space. Otherwise,
3159   E303             ; another extent will be opened (for writing) if required.
3160   E303             ;
3161   E303 AF          POSITION: 	XOR	A			;set random i/o flag.
3162   E304 32 D5 E5    		LD	(MODE),A
3163   E307             ;
3164   E307             ;   Special entry (function #40). M/PM ?
3165   E307             ;
3166   E307 C5          POSITN1:	PUSH	BC			;save read/write flag.
3167   E308 2A 43 DB    	LD	HL,(PARAMS)	;get address of fcb.
3168   E30B EB          	EX	DE,HL
3169   E30C 21 21 00    	LD	HL,33			;now get byte 'r0'.
3170   E30F 19          	ADD	HL,DE
3171   E310 7E          	LD	A,(HL)
3172   E311 E6 7F       	AND	7FH			;keep bits 0-6 for the record number to access.
3173   E313 F5          	PUSH	AF
3174   E314 7E          	LD	A,(HL)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
3175   E315 17          	RLA	
3176   E316 23          	INC	HL
3177   E317 7E          	LD	A,(HL)
3178   E318 17          	RLA	
3179   E319 E6 1F       	AND	1FH			;and save this in bits 0-4 of (C).
3180   E31B 4F          	LD	C,A			;this is the extent byte.
3181   E31C 7E          	LD	A,(HL)		;now get the extra extent byte.
3182   E31D 1F          	RRA	
3183   E31E 1F          	RRA	
3184   E31F 1F          	RRA	
3185   E320 1F          	RRA	
3186   E321 E6 0F       	AND	0FH
3187   E323 47          	LD	B,A			;and save it in (B).
3188   E324 F1          	POP	AF			;get record number back to (A).
3189   E325 23          	INC	HL			;check overflow byte 'r2'.
3190   E326 6E          	LD	L,(HL)	
3191   E327 2C          	INC	L
3192   E328 2D          	DEC	L
3193   E329 2E 06       	LD	L,6			;prepare for error.
3194   E32B C2 8B E3    	JP	NZ,POSITN5		;out of disk space error.
3195   E32E 21 20 00    	LD	HL,32			;store record number into fcb.
3196   E331 19          	ADD	HL,DE
3197   E332 77          	LD	(HL),A
3198   E333 21 0C 00    	LD	HL,12			;and now check the extent byte.
3199   E336 19          	ADD	HL,DE
3200   E337 79          	LD	A,C
3201   E338 96          	SUB	(HL)			;same extent as before?
3202   E339 C2 47 E3    	JP	NZ,POSITN2
3203   E33C 21 0E 00    	LD	HL,14			;yes, check extra extent byte 's2' also.
3204   E33F 19          	ADD	HL,DE
3205   E340 78          	LD	A,B
3206   E341 96          	SUB	(HL)
3207   E342 E6 7F       	AND	7FH
3208   E344 CA 7F E3    	JP	Z,POSITN3		;same, we are almost done then.
3209   E347             ;
3210   E347             ;  Get here when another extent is required.
3211   E347             ;
3212   E347 C5          POSITN2:	PUSH	BC
3213   E348 D5          	PUSH	DE
3214   E349 CD A2 E0    	CALL	CLOSEIT		;close current extent.
3215   E34C D1          	POP	DE
3216   E34D C1          	POP	BC
3217   E34E 2E 03       	LD	L,3			;prepare for error.
3218   E350 3A 45 DB    	LD	A,(STATUS)
3219   E353 3C          	INC	A
3220   E354 CA 84 E3    	JP	Z,POSITN4		;close error.
3221   E357 21 0C 00    	LD	HL,12			;put desired extent into fcb now.
3222   E35A 19          	ADD	HL,DE
3223   E35B 71          	LD	(HL),C
3224   E35C 21 0E 00    	LD	HL,14			;and store extra extent byte 's2'.
3225   E35F 19          	ADD	HL,DE
3226   E360 70          	LD	(HL),B
3227   E361 CD 51 E0    	CALL	OPENIT		;try and get this extent.
3228   E364 3A 45 DB    	LD	A,(STATUS)		;was it there?
3229   E367 3C          	INC	A
3230   E368 C2 7F E3    	JP	NZ,POSITN3
3231   E36B C1          	POP	BC			;no. can we create a new one (writing?).
3232   E36C C5          	PUSH	BC
3233   E36D 2E 04       	LD	L,4			;prepare for error.
3234   E36F 0C          	INC	C
3235   E370 CA 84 E3    	JP	Z,POSITN4		;nope, reading unwritten space error.
3236   E373 CD 24 E1    	CALL	GETEMPTY		;yes we can, try to find space.
3237   E376 2E 05       	LD	L,5			;prepare for error.
3238   E378 3A 45 DB    	LD	A,(STATUS)
3239   E37B 3C          	INC	A
3240   E37C CA 84 E3    	JP	Z,POSITN4		;out of space?
3241   E37F             ;
3242   E37F             ;   Normal return location. Clear error code and return.
3243   E37F             ;
3244   E37F C1          POSITN3:	POP	BC			;restore stack.
3245   E380 AF          	XOR	A			;and clear error code byte.
3246   E381 C3 01 DB    	JP	SETSTAT
3247   E384             ;
3248   E384             ;   Error. Set the 's2' byte to indicate this (why?).
3249   E384             ;
3250   E384 E5          POSITN4:	PUSH	HL
3251   E385 CD 69 DD    	CALL	GETS2
3252   E388 36 C0       	LD	(HL),0C0H
3253   E38A E1          	POP	HL
3254   E38B             ;
3255   E38B             ;   Return with error code (presently in L).
3256   E38B             ;
3257   E38B C1          POSITN5:	POP	BC
3258   E38C 7D          	LD	A,L			;get error code.
3259   E38D 32 45 DB    	LD	(STATUS),A	
3260   E390 C3 78 DD    	JP	SETS2B7
3261   E393             ;
3262   E393             ;   Read a random record.
3263   E393             ;
3264   E393 0E FF       READRAN:	LD	C,0FFH		;set 'read' status.
3265   E395 CD 03 E3    	CALL	POSITION		;position the file to proper record.
3266   E398 CC C1 E1    	CALL	Z,RDSEQ1		;and read it as usual (if no errors).
3267   E39B C9          	RET	
3268   E39C             ;
3269   E39C             ;   Write to a random record.
3270   E39C             ;
3271   E39C 0E 00       WRITERAN: 	LD	C,0			;set 'writing' flag.
3272   E39E CD 03 E3    	CALL	POSITION		;position the file to proper record.
3273   E3A1 CC 03 E2    	CALL	Z,WTSEQ1		;and write as usual (if no errors).
3274   E3A4 C9          	RET	
3275   E3A5             ;
3276   E3A5             ;   Compute the random record number. Enter with (HL) pointing
3277   E3A5             ; to a fcb an (DE) contains a relative location of a record
3278   E3A5             ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
3279   E3A5             ; byte, and (A) the 'r2' byte.
3280   E3A5             ;
3281   E3A5             ;   On return, the zero flag is set if the record is within
3282   E3A5             ; bounds. Otherwise, an overflow occured.
3283   E3A5             ;
3284   E3A5 EB          COMPRAND: 	EX	DE,HL			;save fcb pointer in (DE).
3285   E3A6 19          	ADD	HL,DE			;compute relative position of record #.
3286   E3A7 4E          	LD	C,(HL)		;get record number into (BC).
3287   E3A8 06 00       	LD	B,0
3288   E3AA 21 0C 00    	LD	HL,12			;now get extent.
3289   E3AD 19          	ADD	HL,DE
3290   E3AE 7E          	LD	A,(HL)		;compute (BC)=(record #)+(extent)*128.
3291   E3AF 0F          	RRCA				;move lower bit into bit 7.
3292   E3B0 E6 80       	AND	80H			;and ignore all other bits.
3293   E3B2 81          	ADD	A,C			;add to our record number.
3294   E3B3 4F          	LD	C,A
3295   E3B4 3E 00       	LD	A,0			;take care of any carry.
3296   E3B6 88          	ADC	A,B
3297   E3B7 47          	LD	B,A
3298   E3B8 7E          	LD	A,(HL)		;now get the upper bits of extent into
3299   E3B9 0F          	RRCA				;bit positions 0-3.
3300   E3BA E6 0F       	AND	0FH			;and ignore all others.
3301   E3BC 80          	ADD	A,B			;add this in to 'r1' byte.
3302   E3BD 47          	LD	B,A
3303   E3BE 21 0E 00    	LD	HL,14			;get the 's2' byte (extra extent).
3304   E3C1 19          	ADD	HL,DE
3305   E3C2 7E          	LD	A,(HL)
3306   E3C3 87          	ADD	A,A			;and shift it left 4 bits (bits 4-7).
3307   E3C4 87          	ADD	A,A
3308   E3C5 87          	ADD	A,A
3309   E3C6 87          	ADD	A,A	
3310   E3C7 F5          	PUSH	AF			;save carry flag (bit 0 of flag byte).
3311   E3C8 80          	ADD	A,B			;now add extra extent into 'r1'.
3312   E3C9 47          	LD	B,A
3313   E3CA F5          	PUSH	AF			;and save carry (overflow byte 'r2').
3314   E3CB E1          	POP	HL			;bit 0 of (L) is the overflow indicator.
3315   E3CC 7D          	LD	A,L
3316   E3CD E1          	POP	HL			;and same for first carry flag.
3317   E3CE B5          	OR	L			;either one of these set?
3318   E3CF E6 01       	AND	01H			;only check the carry flags.
3319   E3D1 C9          	RET	
3320   E3D2             ;
3321   E3D2             ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
3322   E3D2             ; reflect the last record used for a random (or other) file.
3323   E3D2             ; This reads the directory and looks at all extents computing
3324   E3D2             ; the largerst record number for each and keeping the maximum
3325   E3D2             ; value only. Then 'r0', 'r1', and 'r2' will reflect this
3326   E3D2             ; maximum record number. This is used to compute the space used
3327   E3D2             ; by a random file.
3328   E3D2             ;
3329   E3D2 0E 0C       RANSIZE:	LD	C,12			;look thru directory for first entry with
3330   E3D4 CD 18 DF    	CALL	FINDFST		;this name.
3331   E3D7 2A 43 DB    	LD	HL,(PARAMS)	;zero out the 'r0, r1, r2' bytes.
3332   E3DA 11 21 00    	LD	DE,33
3333   E3DD 19          	ADD	HL,DE
3334   E3DE E5          	PUSH	HL
3335   E3DF 72          	LD	(HL),D		;note that (D)=0.
3336   E3E0 23          	INC	HL
3337   E3E1 72          	LD	(HL),D
3338   E3E2 23          	INC	HL
3339   E3E3 72          	LD	(HL),D
3340   E3E4 CD F5 DD    RANSIZ1:	CALL	CKFILPOS		;is there an extent to process?
3341   E3E7 CA 0C E4    	JP	Z,RANSIZ3		;no, we are done.
3342   E3EA CD 5E DD    	CALL	FCB2HL		;set (HL) pointing to proper fcb in dir.
3343   E3ED 11 0F 00    	LD	DE,15			;point to last record in extent.
3344   E3F0 CD A5 E3    	CALL	COMPRAND		;and compute random parameters.
3345   E3F3 E1          	POP	HL
3346   E3F4 E5          	PUSH	HL			;now check these values against those
3347   E3F5 5F          	LD	E,A			;already in fcb.
3348   E3F6 79          	LD	A,C			;the carry flag will be set if those
3349   E3F7 96          	SUB	(HL)			;in the fcb represent a larger size than
3350   E3F8 23          	INC	HL			;this extent does.
3351   E3F9 78          	LD	A,B
3352   E3FA 9E          	SBC	A,(HL)
3353   E3FB 23          	INC	HL
3354   E3FC 7B          	LD	A,E
3355   E3FD 9E          	SBC	A,(HL)
3356   E3FE DA 06 E4    	JP	C,RANSIZ2
3357   E401 73          	LD	(HL),E		;we found a larger (in size) extent.
3358   E402 2B          	DEC	HL			;stuff these values into fcb.
3359   E403 70          	LD	(HL),B
3360   E404 2B          	DEC	HL
3361   E405 71          	LD	(HL),C
3362   E406 CD 2D DF    RANSIZ2:	CALL	FINDNXT		;now get the next extent.
3363   E409 C3 E4 E3    		JP	RANSIZ1		;continue til all done.
3364   E40C E1          RANSIZ3:	POP	HL			;we are done, restore the stack and
3365   E40D C9          		RET				;return.
3366   E40E             ;
3367   E40E             ;   Function to return the random record position of a given
3368   E40E             ; file which has been read in sequential mode up to now.
3369   E40E             ;
3370   E40E 2A 43 DB    SETRAN:	LD	HL,(PARAMS)	;point to fcb.
3371   E411 11 20 00    	LD	DE,32			;and to last used record.
3372   E414 CD A5 E3    	CALL	COMPRAND		;compute random position.
3373   E417 21 21 00    	LD	HL,33			;now stuff these values into fcb.
3374   E41A 19          	ADD	HL,DE
3375   E41B 71          	LD	(HL),C		;move 'r0'.
3376   E41C 23          	INC	HL
3377   E41D 70          	LD	(HL),B		;and 'r1'.
3378   E41E 23          	INC	HL
3379   E41F 77          	LD	(HL),A		;and lastly 'r2'.
3380   E420 C9          	RET	
3381   E421             ;
3382   E421             ;   This routine select the drive specified in (ACTIVE) and
3383   E421             ; update the login vector and bitmap table if this drive was
3384   E421             ; not already active.
3385   E421             ;
3386   E421 2A AF E5    LOGINDRV: 	LD	HL,(LOGIN)		;get the login vector.
3387   E424 3A 42 DB    	LD	A,(ACTIVE)		;get the default drive.
3388   E427 4F          	LD	C,A
3389   E428 CD EA DC    	CALL	SHIFTR		;position active bit for this drive
3390   E42B E5          	PUSH	HL			;into bit 0.
3391   E42C EB          	EX	DE,HL
3392   E42D CD 59 DB    	CALL	SELECT		;select this drive.
3393   E430 E1          	POP	HL
3394   E431 CC 47 DB    	CALL	Z,SLCTERR		;valid drive?
3395   E434 7D          	LD	A,L			;is this a newly activated drive?
3396   E435 1F          	RRA	
3397   E436 D8          	RET	C
3398   E437 2A AF E5    	LD	HL,(LOGIN)		;yes, update the login vector.
3399   E43A 4D          	LD	C,L
3400   E43B 44          	LD	B,H
3401   E43C CD 0B DD    	CALL	SETBIT
3402   E43F 22 AF E5    	LD	(LOGIN),HL		;and save.
3403   E442 C3 A3 DE    	JP	BITMAP		;now update the bitmap.
3404   E445             ;
3405   E445             ;   Function to set the active disk number.
3406   E445             ;
3407   E445 3A D6 E5    SETDSK:	LD	A,(EPARAM)		;get parameter passed and see if this
3408   E448 21 42 DB    	LD	HL,ACTIVE		;represents a change in drives.
3409   E44B BE          	CP	(HL)
3410   E44C C8          	RET	Z
3411   E44D 77          	LD	(HL),A		;yes it does, log it in.
3412   E44E C3 21 E4    	JP	LOGINDRV
3413   E451             ;
3414   E451             ;   This is the 'auto disk select' routine. The firsst byte
3415   E451             ; of the fcb is examined for a drive specification. If non
3416   E451             ; zero then the drive will be selected and loged in.
3417   E451             ;
3418   E451 3E FF       AUTOSEL:	LD	A,0FFH		;say 'auto-select activated'.
3419   E453 32 DE E5    	LD	(AUTO),A
3420   E456 2A 43 DB    	LD	HL,(PARAMS)	;get drive specified.
3421   E459 7E          	LD	A,(HL)
3422   E45A E6 1F       	AND	1FH			;look at lower 5 bits.
3423   E45C 3D          	DEC	A			;adjust for (1=A, 2=B) etc.
3424   E45D 32 D6 E5    	LD	(EPARAM),A		;and save for the select routine.
3425   E460 FE 1E       	CP	1EH			;check for 'no change' condition.
3426   E462 D2 75 E4    	JP	NC,AUTOSL1		;yes, don't change.
3427   E465 3A 42 DB    	LD	A,(ACTIVE)		;we must change, save currently active
3428   E468 32 DF E5    	LD	(OLDDRV),A		;drive.
3429   E46B 7E          	LD	A,(HL)		;and save first byte of fcb also.
3430   E46C 32 E0 E5    	LD	(AUTOFLAG),A	;this must be non-zero.
3431   E46F E6 E0       	AND	0E0H			;whats this for (bits 6,7 are used for
3432   E471 77          	LD	(HL),A		;something)?
3433   E472 CD 45 E4    	CALL	SETDSK		;select and log in this drive.
3434   E475 3A 41 DB    AUTOSL1:	LD	A,(USERNO)		;move user number into fcb.
3435   E478 2A 43 DB    	LD	HL,(PARAMS)	;(* upper half of first byte *)
3436   E47B B6          	OR	(HL)
3437   E47C 77          	LD	(HL),A
3438   E47D C9          	RET				;and return (all done).
3439   E47E             ;
3440   E47E             ;   Function to return the current cp/m version number.
3441   E47E             ;
3442   E47E 3E 22       GETVER:	LD	A,022H		;version 2.2
3443   E480 C3 01 DB    		JP	SETSTAT
3444   E483             ;
3445   E483             ;   Function to reset the disk system.
3446   E483             ;
3447   E483 21 00 00    RSTDSK:	LD	HL,0			;clear write protect status and log
3448   E486 22 AD E5    	LD	(WRTPRT),HL	;in vector.
3449   E489 22 AF E5    	LD	(LOGIN),HL
3450   E48C AF          	XOR	A			;select drive 'A'.
3451   E48D 32 42 DB    	LD	(ACTIVE),A
3452   E490 21 80 00    	LD	HL,TBUFF		;setup default dma address.
3453   E493 22 B1 E5    	LD	(USERDMA),HL
3454   E496 CD DA DD    	CALL	DEFDMA
3455   E499 C3 21 E4    	JP	LOGINDRV		;now log in drive 'A'.
3456   E49C             ;
3457   E49C             ;   Function to open a specified file.
3458   E49C             ;
3459   E49C CD 72 DD    OPENFIL:	CALL	CLEARS2		;clear 's2' byte.
3460   E49F CD 51 E4    	CALL	AUTOSEL		;select proper disk.
3461   E4A2 C3 51 E0    	JP	OPENIT		;and open the file.
3462   E4A5             ;
3463   E4A5             ;   Function to close a specified file.
3464   E4A5             ;
3465   E4A5 CD 51 E4    CLOSEFIL: 	CALL	AUTOSEL		;select proper disk.
3466   E4A8 C3 A2 E0    		JP	CLOSEIT		;and close the file.
3467   E4AB             ;
3468   E4AB             ;   Function to return the first occurence of a specified file
3469   E4AB             ; name. If the first byte of the fcb is '?' then the name will
3470   E4AB             ; not be checked (get the first entry no matter what).
3471   E4AB             ;
3472   E4AB 0E 00       GETFST:	LD	C,0			;prepare for special search.
3473   E4AD EB          	EX	DE,HL
3474   E4AE 7E          	LD	A,(HL)		;is first byte a '?'?
3475   E4AF FE 3F       	CP	'?'
3476   E4B1 CA C2 E4    	JP	Z,GETFST1		;yes, just get very first entry (zero length match).
3477   E4B4 CD A6 DC    	CALL	SETEXT		;get the extension byte from fcb.
3478   E4B7 7E          	LD	A,(HL)		;is it '?'? if yes, then we want
3479   E4B8 FE 3F       	CP	'?'			;an entry with a specific 's2' byte.
3480   E4BA C4 72 DD    	CALL	NZ,CLEARS2		;otherwise, look for a zero 's2' byte.
3481   E4BD CD 51 E4    	CALL	AUTOSEL		;select proper drive.
3482   E4C0 0E 0F       	LD	C,15			;compare bytes 0-14 in fcb (12&13 excluded).
3483   E4C2 CD 18 DF    GETFST1:	CALL	FINDFST		;find an entry and then move it into
3484   E4C5 C3 E9 DD    		JP	MOVEDIR		;the users dma space.
3485   E4C8             ;
3486   E4C8             ;   Function to return the next occurence of a file name.
3487   E4C8             ;
3488   E4C8 2A D9 E5    GETNXT:	LD	HL,(SAVEFCB)	;restore pointers. note that no
3489   E4CB 22 43 DB    	LD	(PARAMS),HL	;other dbos calls are allowed.
3490   E4CE CD 51 E4    	CALL	AUTOSEL		;no error will be returned, but the
3491   E4D1 CD 2D DF    	CALL	FINDNXT		;results will be wrong.
3492   E4D4 C3 E9 DD    	JP	MOVEDIR
3493   E4D7             ;
3494   E4D7             ;   Function to delete a file by name.
3495   E4D7             ;
3496   E4D7 CD 51 E4    DELFILE:	CALL	AUTOSEL		;select proper drive.
3497   E4DA CD 9C DF    	CALL	ERAFILE		;erase the file.
3498   E4DD C3 01 DF    	JP	STSTATUS		;set status and return.
3499   E4E0             ;
3500   E4E0             ;   Function to execute a sequential read of the specified
3501   E4E0             ; record number.
3502   E4E0             ;
3503   E4E0 CD 51 E4    READSEQ:CALL	AUTOSEL		;select proper drive then read.
3504   E4E3 C3 BC E1    		JP	RDSEQ
3505   E4E6             ;
3506   E4E6             ;   Function to write the net sequential record.
3507   E4E6             ;
3508   E4E6 CD 51 E4    WRTSEQ:	CALL	AUTOSEL		;select proper drive then write.
3509   E4E9 C3 FE E1    		JP	WTSEQ
3510   E4EC             ;
3511   E4EC             ;   Create a file function.
3512   E4EC             ;
3513   E4EC CD 72 DD    FCREATE:	CALL	CLEARS2		;clear the 's2' byte on all creates.
3514   E4EF CD 51 E4    	CALL	AUTOSEL		;select proper drive and get the next
3515   E4F2 C3 24 E1    	JP	GETEMPTY		;empty directory space.
3516   E4F5             ;
3517   E4F5             ;   Function to rename a file.
3518   E4F5             
3519   E4F5 CD 51 E4    RENFILE:	CALL	AUTOSEL		;select proper drive and then switch
3520   E4F8 CD 16 E0    	CALL	CHGNAMES		;file names.
3521   E4FB C3 01 DF    	JP	STSTATUS
3522   E4FE             ;
3523   E4FE             ;   Function to return the login vector.
3524   E4FE             ;
3525   E4FE 2A AF E5    GETLOG:	LD	HL,(LOGIN)
3526   E501 C3 29 E5    		JP	GETPRM1
3527   E504             ;
3528   E504             ;   Function to return the current disk assignment.
3529   E504             ;
3530   E504 3A 42 DB    GETCRNT:	LD	A,(ACTIVE)
3531   E507 C3 01 DB    		JP	SETSTAT
3532   E50A             ;
3533   E50A             ;   Function to set the dma address.
3534   E50A             ;
3535   E50A EB          PUTDMA:	EX	DE,HL
3536   E50B 22 B1 E5    	LD	(USERDMA),HL	;save in our space and then get to
3537   E50E C3 DA DD    	JP	DEFDMA		;the bios with this also.
3538   E511             ;
3539   E511             ;   Function to return the allocation vector.
3540   E511             ;
3541   E511 2A BF E5    GETALOC:	LD	HL,(ALOCVECT)
3542   E514 C3 29 E5    		JP	GETPRM1
3543   E517             ;
3544   E517             ;   Function to return the read-only status vector.
3545   E517             ;
3546   E517 2A AD E5    GETROV:	LD	HL,(WRTPRT)
3547   E51A C3 29 E5    		JP	GETPRM1
3548   E51D             ;
3549   E51D             ;   Function to set the file attributes (read-only, system).
3550   E51D             ;
3551   E51D CD 51 E4    SETATTR:	CALL	AUTOSEL		;select proper drive then save attributes.
3552   E520 CD 3B E0    	CALL	SAVEATTR
3553   E523 C3 01 DF    	JP	STSTATUS
3554   E526             ;
3555   E526             ;   Function to return the address of the disk parameter block
3556   E526             ; for the current drive.
3557   E526             ;
3558   E526 2A BB E5    GETPARM:	LD	HL,(DISKPB)
3559   E529 22 45 DB    GETPRM1:	LD	(STATUS),HL
3560   E52C C9          		RET	
3561   E52D             ;
3562   E52D             ;   Function to get or set the user number. If (E) was (FF)
3563   E52D             ; then this is a request to return the current user number.
3564   E52D             ; Else set the user number from (E).
3565   E52D             ;
3566   E52D 3A D6 E5    GETUSER:	LD	A,(EPARAM)		;get parameter.
3567   E530 FE FF       	CP	0FFH			;get user number?
3568   E532 C2 3B E5    	JP	NZ,SETUSER
3569   E535 3A 41 DB    	LD	A,(USERNO)		;yes, just do it.
3570   E538 C3 01 DB    	JP	SETSTAT
3571   E53B E6 1F       SETUSER:	AND	1FH			;no, we should set it instead. keep low
3572   E53D 32 41 DB    	LD	(USERNO),A		;bits (0-4) only.
3573   E540 C9          	RET	
3574   E541             ;
3575   E541             ;   Function to read a random record from a file.
3576   E541             ;
3577   E541 CD 51 E4    RDRANDOM: 	CALL	AUTOSEL		;select proper drive and read.
3578   E544 C3 93 E3    		JP	READRAN
3579   E547             ;
3580   E547             ;   Function to compute the file size for random files.
3581   E547             ;
3582   E547 CD 51 E4    WTRANDOM: 	CALL	AUTOSEL		;select proper drive and write.
3583   E54A C3 9C E3    		JP	WRITERAN
3584   E54D             ;
3585   E54D             ;   Function to compute the size of a random file.
3586   E54D             ;
3587   E54D CD 51 E4    FILESIZE: 	CALL	AUTOSEL		;select proper drive and check file length
3588   E550 C3 D2 E3    		JP	RANSIZE
3589   E553             ;
3590   E553             ;   Function #37. This allows a program to log off any drives.
3591   E553             ; On entry, set (DE) to contain a word with bits set for those
3592   E553             ; drives that are to be logged off. The log-in vector and the
3593   E553             ; write protect vector will be updated. This must be a M/PM
3594   E553             ; special function.
3595   E553             ;
3596   E553 2A 43 DB    LOGOFF:	LD	HL,(PARAMS)	;get drives to log off.
3597   E556 7D          	LD	A,L			;for each bit that is set, we want
3598   E557 2F          	CPL				;to clear that bit in (LOGIN)
3599   E558 5F          	LD	E,A			;and (WRTPRT).
3600   E559 7C          	LD	A,H
3601   E55A 2F          	CPL	
3602   E55B 2A AF E5    	LD	HL,(LOGIN)		;reset the login vector.
3603   E55E A4          	AND	H
3604   E55F 57          	LD	D,A
3605   E560 7D          	LD	A,L
3606   E561 A3          	AND	E
3607   E562 5F          	LD	E,A
3608   E563 2A AD E5    	LD	HL,(WRTPRT)
3609   E566 EB          	EX	DE,HL
3610   E567 22 AF E5    	LD	(LOGIN),HL		;and save.
3611   E56A 7D          	LD	A,L			;now do the write protect vector.
3612   E56B A3          	AND	E
3613   E56C 6F          	LD	L,A
3614   E56D 7C          	LD	A,H
3615   E56E A2          	AND	D
3616   E56F 67          	LD	H,A
3617   E570 22 AD E5    	LD	(WRTPRT),HL	;and save. all done.
3618   E573 C9          	RET	
3619   E574             ;
3620   E574             ;   Get here to return to the user.
3621   E574             ;
3622   E574 3A DE E5    GOBACK:	LD	A,(AUTO)		;was auto select activated?
3623   E577 B7          	OR	A
3624   E578 CA 91 E5    	JP	Z,GOBACK1
3625   E57B 2A 43 DB    	LD	HL,(PARAMS)	;yes, but was a change made?
3626   E57E 36 00       	LD	(HL),0		;(* reset first byte of fcb *)
3627   E580 3A E0 E5    	LD	A,(AUTOFLAG)
3628   E583 B7          	OR	A
3629   E584 CA 91 E5    	JP	Z,GOBACK1
3630   E587 77          	LD	(HL),A		;yes, reset first byte properly.
3631   E588 3A DF E5    	LD	A,(OLDDRV)		;and get the old drive and select it.
3632   E58B 32 D6 E5    	LD	(EPARAM),A
3633   E58E CD 45 E4    	CALL	SETDSK
3634   E591 2A 0F DB    GOBACK1:	LD	HL,(USRSTACK)	;reset the users stack pointer.
3635   E594 F9          	LD	SP,HL
3636   E595 2A 45 DB    	LD	HL,(STATUS)	;get return status.
3637   E598 7D          	LD	A,L			;force version 1.4 compatability.
3638   E599 44          	LD	B,H
3639   E59A C9          	RET				;and go back to user.
3640   E59B             ;
3641   E59B             ;   Function #40. This is a special entry to do random i/o.
3642   E59B             ; For the case where we are writing to unused disk space, this
3643   E59B             ; space will be zeroed out first. This must be a M/PM special
3644   E59B             ; purpose function, because why would any normal program even
3645   E59B             ; care about the previous contents of a sector about to be
3646   E59B             ; written over.
3647   E59B             ;
3648   E59B CD 51 E4    WTSPECL:	CALL	AUTOSEL		;select proper drive.
3649   E59E 3E 02       	LD	A,2			;use special write mode.
3650   E5A0 32 D5 E5    	LD	(MODE),A
3651   E5A3 0E 00       	LD	C,0			;set write indicator.
3652   E5A5 CD 07 E3    	CALL	POSITN1		;position the file.
3653   E5A8 CC 03 E2    	CALL	Z,WTSEQ1		;and write (if no errors).
3654   E5AB C9          	RET	
3655   E5AC             ;
3656   E5AC             ;**************************************************************
3657   E5AC             ;*
3658   E5AC             ;*     BDOS data storage pool.
3659   E5AC             ;*
3660   E5AC             ;**************************************************************
3661   E5AC             ;
3662   E5AC E5          EMPTYFCB: 	.DB	0E5H			;empty directory segment indicator.
3663   E5AD 00 00       WRTPRT:	.DW	0			;write protect status for all 16 drives.
3664   E5AF 00 00       LOGIN:	.DW	0			;drive active word (1 bit per drive).
3665   E5B1 80 00       USERDMA:	.DW	080H			;user's dma address (defaults to 80h).
3666   E5B3             ;
3667   E5B3             ;   Scratch areas from parameter block.
3668   E5B3             ;
3669   E5B3 00 00       SCRATCH1: 	.DW	0			;relative position within dir segment for file (0-3).
3670   E5B5 00 00       SCRATCH2: 	.DW	0			;last selected track number.
3671   E5B7 00 00       SCRATCH3: 	.DW	0			;last selected sector number.
3672   E5B9             ;
3673   E5B9             ;   Disk storage areas from parameter block.
3674   E5B9             ;
3675   E5B9 00 00       DIRBUF:	.DW	0			;address of directory buffer to use.
3676   E5BB 00 00       DISKPB:	.DW	0			;contains address of disk parameter block.
3677   E5BD 00 00       CHKVECT:	.DW	0			;address of check vector.
3678   E5BF 00 00       ALOCVECT: 	.DW	0			;address of allocation vector (bit map).
3679   E5C1             ;
3680   E5C1             ;   Parameter block returned from the bios.
3681   E5C1             ;
3682   E5C1 00 00       SECTORS:	.DW	0			;sectors per track from bios.
3683   E5C3 00          BLKSHFT:	.DB	0			;block shift.
3684   E5C4 00          BLKMASK:	.DB	0			;block mask.
3685   E5C5 00          EXTMASK:	.DB	0			;extent mask.
3686   E5C6 00 00       DSKSIZE:	.DW	0			;disk size from bios (number of blocks-1).
3687   E5C8 00 00       DIRSIZE:	.DW	0			;directory size.
3688   E5CA 00 00       ALLOC0:	.DW	0			;storage for first bytes of bit map (dir space used).
3689   E5CC 00 00       ALLOC1:	.DW	0
3690   E5CE 00 00       OFFSET:	.DW	0			;first usable track number.
3691   E5D0 00 00       XLATE:	.DW	0			;sector translation table address.
3692   E5D2             ;
3693   E5D2             ;
3694   E5D2 00          CLOSEFLG: 	.DB	0			;close flag (=0ffh is extent written ok).
3695   E5D3 00          RDWRTFLG: 	.DB	0			;read/write flag (0ffh=read, 0=write).
3696   E5D4 00          FNDSTAT:	.DB	0			;filename found status (0=found first entry).
3697   E5D5 00          MODE:		.DB	0			;I/o mode select (0=random, 1=sequential, 2=special random).
3698   E5D6 00          EPARAM:	.DB	0			;storage for register (E) on entry to bdos.
3699   E5D7 00          RELBLOCK: 	.DB	0			;relative position within fcb of block number written.
3700   E5D8 00          COUNTER:	.DB	0			;byte counter for directory name searches.
3701   E5D9 00 00 00 00 SAVEFCB:	.DW	0,0			;save space for address of fcb (for directory searches).
3702   E5DD 00          BIGDISK:	.DB	0			;if =0 then disk is > 256 blocks long.
3703   E5DE 00          AUTO:		.DB	0			;if non-zero, then auto select activated.
3704   E5DF 00          OLDDRV:	.DB	0			;on auto select, storage for previous drive.
3705   E5E0 00          AUTOFLAG: 	.DB	0			;if non-zero, then auto select changed drives.
3706   E5E1 00          SAVNXT:	.DB	0			;storage for next record number to access.
3707   E5E2 00          SAVEXT:	.DB	0			;storage for extent number of file.
3708   E5E3 00 00       SAVNREC:	.DW	0			;storage for number of records in file.
3709   E5E5 00 00       BLKNMBR:	.DW	0			;block number (physical sector) used within a file or logical sect
3710   E5E7 00 00       LOGSECT:	.DW	0			;starting logical (128 byte) sector of block (physical sector).
3711   E5E9 00          FCBPOS:	.DB	0			;relative position within buffer for fcb of file of interest.
3712   E5EA 00 00       FILEPOS:	.DW	0			;files position within directory (0 to max entries -1).
3713   E5EC             ;
3714   E5EC             ;   Disk directory buffer checksum bytes. One for each of the
3715   E5EC             ; 16 possible drives.
3716   E5EC             ;
3717   E5EC 00 00 00 00 CKSUMTBL: 	.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
3717   E5F0 00 00 00 00 
3717   E5F4 00 00 00 00 
3717   E5F8 00 00 00 00 
3718   E5FC             
3719   E5FE             		.ORG	BIOS-2
3720   E5FE 06 D8       		.DW	FBASE			;write here the BDOS entry point so BIOS can copy it to page zero
3721   E600             ;**************************************************************
3722   E600             ;*
3723   E600             ;*        B I O S   J U M P   T A B L E
3724   E600             ;*
3725   E600             ;**************************************************************
3726   E600             ;
3727   E600             		.ORG	BIOS
3728   E600 C3 00 00    BOOT:		JP	0			;NOTE WE USE FAKE DESTINATIONS
3729   E603 C3 00 00    WBOOT:	JP	0
3730   E606 C3 00 00    CONST:	JP	0
3731   E609 C3 00 00    CONIN:	JP	0
3732   E60C C3 00 00    CONOUT:	JP	0
3733   E60F C3 00 00    LIST:		JP	0
3734   E612 C3 00 00    PUNCH:	JP	0
3735   E615 C3 00 00    READER:	JP	0
3736   E618 C3 00 00    HOME:		JP	0
3737   E61B C3 00 00    SELDSK:	JP	0
3738   E61E C3 00 00    SETTRK:	JP	0
3739   E621 C3 00 00    SETSEC:	JP	0
3740   E624 C3 00 00    SETDMA:	JP	0
3741   E627 C3 00 00    READ:		JP	0
3742   E62A C3 00 00    WRITE:	JP	0
3743   E62D C3 00 00    PRSTAT:	JP	0
3744   E630 C3 00 00    SECTRN:	JP	0
3745   E633             ;
3746   E633             ;*
3747   E633             ;******************   E N D   O F   C P / M   *****************
3748   E633             ;*
3749   E633             		.END
tasm: Number of errors = 0
