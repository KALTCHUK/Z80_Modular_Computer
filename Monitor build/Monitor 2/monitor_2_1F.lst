0001   0000             ;================================================================================================
0002   0000             ; MONITOR 2.1E - Improved memory compare function. Find difference before displaying content.
0003   0000             ;                Put some NOPs in DISKWRITE and DISKREAD.
0004   0000             ;================================================================================================
0005   0000             IOBYTE		.EQU	3
0006   0000             TPA			.EQU	0100H				; Transient Programs Area
0007   0000             MONITOR		.EQU	0D000H				; Monitor entry point
0008   0000             BIOS		.EQU	0E600H				; BIOS entry point
0009   0000             DMA			.EQU	0080H				; Buffer used by Monitor
0010   0000             DISKPAD		.EQU	0E000H				; Draft area used by disk R/W ops
0011   0000             										; (512 bytes between Monitor and BIOS)
0012   0000             
0013   0000             ;================================================================================================
0014   0000             ; BIOS functions.
0015   0000             ;================================================================================================
0016   0000             LEAP		.EQU	3					; 3 bytes for each entry (JP aaaa)
0017   0000             
0018   0000             BOOT:		.EQU	BIOS				;  0 Initialize.
0019   0000             WBOOT:		.EQU	BIOS+(LEAP*1)		;  1 Warm boot.
0020   0000             CONST:		.EQU	BIOS+(LEAP*2)		;  2 Console status.
0021   0000             CONIN:		.EQU	BIOS+(LEAP*3)		;  3 Console input.
0022   0000             CONOUT:		.EQU	BIOS+(LEAP*4)		;  4 Console OUTput.
0023   0000             LIST:		.EQU	BIOS+(LEAP*5)		;  5 List OUTput.
0024   0000             PUNCH:		.EQU	BIOS+(LEAP*6)		;  6 Punch OUTput.
0025   0000             READER:		.EQU	BIOS+(LEAP*7)		;  7 Reader input.
0026   0000             HOME:		.EQU	BIOS+(LEAP*8)		;  8 Home disk.
0027   0000             SELDSK:		.EQU	BIOS+(LEAP*9)		;  9 Select disk.
0028   0000             SETTRK:		.EQU	BIOS+(LEAP*10)		; 10 Select track.
0029   0000             SETSEC:		.EQU	BIOS+(LEAP*11)		; 11 Select sector.
0030   0000             SETDMA:		.EQU	BIOS+(LEAP*12)		; 12 Set DMA ADDress.
0031   0000             READ:		.EQU	BIOS+(LEAP*13)		; 13 Read 128 bytes.
0032   0000             WRITE:		.EQU	BIOS+(LEAP*14)		; 14 Write 128 bytes.
0033   0000             LISTST:		.EQU	BIOS+(LEAP*15)		; 15 List status.
0034   0000             SECTRAN:	.EQU	BIOS+(LEAP*16)		; 16 Sector translate.
0035   0000             PRINTSEQ:	.EQU	BIOS+(LEAP*17)		; not a BIOS function
0036   0000             
0037   0000             ;================================================================================================
0038   0000             ; ASCII characters.
0039   0000             ;================================================================================================
0040   0000             NUL			.EQU	00H
0041   0000             SOH			.EQU	01H
0042   0000             STX			.EQU	02H
0043   0000             ETX			.EQU	03H
0044   0000             EOT			.EQU	04H
0045   0000             ENQ			.EQU	05H
0046   0000             ACK			.EQU	06H
0047   0000             BEL			.EQU	07H
0048   0000             BS			.EQU	08H			; ^H
0049   0000             HT			.EQU	09H
0050   0000             LF			.EQU	0AH
0051   0000             VT			.EQU	0BH
0052   0000             FF			.EQU	0CH
0053   0000             CR			.EQU	0DH
0054   0000             SO			.EQU	0EH
0055   0000             SI			.EQU	0FH
0056   0000             DLE			.EQU	10H
0057   0000             DC1			.EQU	11H
0058   0000             DC2			.EQU	12H
0059   0000             DC3			.EQU	13H
0060   0000             DC4			.EQU	14H
0061   0000             NAK			.EQU	15H			; ^U
0062   0000             SYN			.EQU	16H
0063   0000             ETB			.EQU	17H
0064   0000             CAN			.EQU	18H			; ^X
0065   0000             EM			.EQU	19H
0066   0000             SUB			.EQU	1AH
0067   0000             ESC			.EQU	1BH
0068   0000             FS			.EQU	1CH
0069   0000             GS			.EQU	1DH
0070   0000             RS			.EQU	1EH
0071   0000             US			.EQU	1FH
0072   0000             
0073   0000             ;================================================================================================
0074   0000             ; Some constants
0075   0000             ;================================================================================================
0076   0000             MAXLBUF		.EQU	DMA+80
0077   0000             PROMPT		.EQU	'>'
0078   0000             MAXTRY		.EQU	10
0079   0000             
0080   0000             ;================================================================================================
0081   0000             ; FLASH card stuff
0082   0000             ;================================================================================================
0083   0000             FLASH_ADDR		.EQU	0B0H			; Base I/O address for compact flash card
0084   0000             CF_DATA			.EQU	(FLASH_ADDR+0)	; R/W
0085   0000             CF_FEATURES		.EQU	(FLASH_ADDR+1)	; W
0086   0000             CF_ERROR		.EQU	(FLASH_ADDR+1)	; R
0087   0000             CF_SECCOUNT		.EQU	(FLASH_ADDR+2)	; W
0088   0000             
0089   0000             CF_SECTOR		.EQU	(FLASH_ADDR+3)	; W
0090   0000             CF_CYL_LOW		.EQU	(FLASH_ADDR+4)	; W
0091   0000             CF_CYL_HI		.EQU	(FLASH_ADDR+5)	; W
0092   0000             CF_HEAD			.EQU	(FLASH_ADDR+6)	; W
0093   0000             
0094   0000             CF_LBA0			.EQU	(FLASH_ADDR+3)	; W
0095   0000             CF_LBA1			.EQU	(FLASH_ADDR+4)	; W
0096   0000             CF_LBA2			.EQU	(FLASH_ADDR+5)	; W
0097   0000             CF_LBA3			.EQU	(FLASH_ADDR+6)	; W
0098   0000             
0099   0000             CF_STATUS		.EQU	(FLASH_ADDR+7)	; R
0100   0000             CF_COMMAND		.EQU	(FLASH_ADDR+7)	; W
0101   0000             
0102   0000             ;CF Features
0103   0000             CF_8BIT			.EQU	1
0104   0000             CF_NOCACHE		.EQU	082H
0105   0000             
0106   0000             ;CF Commands
0107   0000             CF_READ_SEC		.EQU	020H
0108   0000             CF_WRITE_SEC	.EQU	030H
0109   0000             CF_SET_FEAT		.EQU 	0EFH
0110   0000             ;================================================================================================
0111   0000             ; MAIN PROGRAM STARTS HERE
0112   0000             ;================================================================================================
0113   D000             			.ORG MONITOR
0114   D000             
0115   D000 CD AD DC    CYCLE:		CALL PRINTENV
0116   D003 CD 38 DB    			CALL LINER					; Call the line manager
0117   D006 3A 80 00    			LD	A,(DMA)
0118   D009 FE 00       			CP	0
0119   D00B 28 F3       			JR	Z,CYCLE					; User ENTERed an empty line. No need to parse.
0120   D00D 21 2E DD    			LD	HL,CMDTBL
0121   D010 CD E1 DB    			CALL PARSER					; Find command comparing buffer with Command Table.
0122   D013 3C          			INC	A
0123   D014 28 01       			JR	Z,UNK					; No match found in command table.
0124   D016 E9          			JP	(HL)					; Jump to Command Routine
0125   D017 CD 1D DB    UNK:		CALL UNKNOWN
0126   D01A 18 E4       			JR	CYCLE
0127   D01C             			
0128   D01C             ;================================================================================================
0129   D01C             ; Help for main program
0130   D01C             ;================================================================================================
0131   D01C CD 91 DB    HELP:		CALL CRLF
0132   D01F CD 33 E6    			CALL PRINTSEQ
0133   D022 20 4F 70 74 			.DB	" Options:   READ aaaa             read from memory.",CR,LF
0133   D026 69 6F 6E 73 
0133   D02A 3A 20 20 20 
0133   D02E 52 45 41 44 
0133   D032 20 61 61 61 
0133   D036 61 20 20 20 
0133   D03A 20 20 20 20 
0133   D03E 20 20 20 20 
0133   D042 20 20 72 65 
0133   D046 61 64 20 66 
0133   D04A 72 6F 6D 20 
0133   D04E 6D 65 6D 6F 
0133   D052 72 79 2E 0D 
0133   D056 0A 
0134   D057 20 20 20 20 			.DB "            WRITE aaaa,c1 c2 cN   write to memory.",CR,LF
0134   D05B 20 20 20 20 
0134   D05F 20 20 20 20 
0134   D063 57 52 49 54 
0134   D067 45 20 61 61 
0134   D06B 61 61 2C 63 
0134   D06F 31 20 63 32 
0134   D073 20 63 4E 20 
0134   D077 20 20 77 72 
0134   D07B 69 74 65 20 
0134   D07F 74 6F 20 6D 
0134   D083 65 6D 6F 72 
0134   D087 79 2E 0D 0A 
0135   D08B 20 20 20 20 			.DB "            COPY aaaa-bbbb,cccc   copy memory block.",CR,LF
0135   D08F 20 20 20 20 
0135   D093 20 20 20 20 
0135   D097 43 4F 50 59 
0135   D09B 20 61 61 61 
0135   D09F 61 2D 62 62 
0135   D0A3 62 62 2C 63 
0135   D0A7 63 63 63 20 
0135   D0AB 20 20 63 6F 
0135   D0AF 70 79 20 6D 
0135   D0B3 65 6D 6F 72 
0135   D0B7 79 20 62 6C 
0135   D0BB 6F 63 6B 2E 
0135   D0BF 0D 0A 
0136   D0C1 20 20 20 20 			.DB "            FILL aaaa-bbbb,cc     fill memory block.",CR,LF
0136   D0C5 20 20 20 20 
0136   D0C9 20 20 20 20 
0136   D0CD 46 49 4C 4C 
0136   D0D1 20 61 61 61 
0136   D0D5 61 2D 62 62 
0136   D0D9 62 62 2C 63 
0136   D0DD 63 20 20 20 
0136   D0E1 20 20 66 69 
0136   D0E5 6C 6C 20 6D 
0136   D0E9 65 6D 6F 72 
0136   D0ED 79 20 62 6C 
0136   D0F1 6F 63 6B 2E 
0136   D0F5 0D 0A 
0137   D0F7 20 20 20 20 			.DB "            COMPARE aaaa,bbbb     compare memory areas.",CR,LF
0137   D0FB 20 20 20 20 
0137   D0FF 20 20 20 20 
0137   D103 43 4F 4D 50 
0137   D107 41 52 45 20 
0137   D10B 61 61 61 61 
0137   D10F 2C 62 62 62 
0137   D113 62 20 20 20 
0137   D117 20 20 63 6F 
0137   D11B 6D 70 61 72 
0137   D11F 65 20 6D 65 
0137   D123 6D 6F 72 79 
0137   D127 20 61 72 65 
0137   D12B 61 73 2E 0D 
0137   D12F 0A 
0138   D130 20 20 20 20 			.DB	"            DREAD aaaa            read from disk.",CR,LF
0138   D134 20 20 20 20 
0138   D138 20 20 20 20 
0138   D13C 44 52 45 41 
0138   D140 44 20 61 61 
0138   D144 61 61 20 20 
0138   D148 20 20 20 20 
0138   D14C 20 20 20 20 
0138   D150 20 20 72 65 
0138   D154 61 64 20 66 
0138   D158 72 6F 6D 20 
0138   D15C 64 69 73 6B 
0138   D160 2E 0D 0A 
0139   D163 20 20 20 20 			.DB "            DOWN d,ttt,ss         download one sector from disk.",CR,LF
0139   D167 20 20 20 20 
0139   D16B 20 20 20 20 
0139   D16F 44 4F 57 4E 
0139   D173 20 64 2C 74 
0139   D177 74 74 2C 73 
0139   D17B 73 20 20 20 
0139   D17F 20 20 20 20 
0139   D183 20 20 64 6F 
0139   D187 77 6E 6C 6F 
0139   D18B 61 64 20 6F 
0139   D18F 6E 65 20 73 
0139   D193 65 63 74 6F 
0139   D197 72 20 66 72 
0139   D19B 6F 6D 20 64 
0139   D19F 69 73 6B 2E 
0139   D1A3 0D 0A 
0140   D1A5 20 20 20 20 			.DB "            UP d,ttt,ss           upload one sector to disk.",CR,LF
0140   D1A9 20 20 20 20 
0140   D1AD 20 20 20 20 
0140   D1B1 55 50 20 64 
0140   D1B5 2C 74 74 74 
0140   D1B9 2C 73 73 20 
0140   D1BD 20 20 20 20 
0140   D1C1 20 20 20 20 
0140   D1C5 20 20 75 70 
0140   D1C9 6C 6F 61 64 
0140   D1CD 20 6F 6E 65 
0140   D1D1 20 73 65 63 
0140   D1D5 74 6F 72 20 
0140   D1D9 74 6F 20 64 
0140   D1DD 69 73 6B 2E 
0140   D1E1 0D 0A 
0141   D1E3 20 20 20 20 			.DB "            VERIFY d              verify disk.",CR,LF
0141   D1E7 20 20 20 20 
0141   D1EB 20 20 20 20 
0141   D1EF 56 45 52 49 
0141   D1F3 46 59 20 64 
0141   D1F7 20 20 20 20 
0141   D1FB 20 20 20 20 
0141   D1FF 20 20 20 20 
0141   D203 20 20 76 65 
0141   D207 72 69 66 79 
0141   D20B 20 64 69 73 
0141   D20F 6B 2E 0D 0A 
0142   D213 20 20 20 20 			.DB "            FORMAT d              format disk.",CR,LF
0142   D217 20 20 20 20 
0142   D21B 20 20 20 20 
0142   D21F 46 4F 52 4D 
0142   D223 41 54 20 64 
0142   D227 20 20 20 20 
0142   D22B 20 20 20 20 
0142   D22F 20 20 20 20 
0142   D233 20 20 66 6F 
0142   D237 72 6D 61 74 
0142   D23B 20 64 69 73 
0142   D23F 6B 2E 0D 0A 
0143   D243 20 20 20 20 			.DB "            XMODEM aaaa           receive file using xmodem protocol.",CR,LF
0143   D247 20 20 20 20 
0143   D24B 20 20 20 20 
0143   D24F 58 4D 4F 44 
0143   D253 45 4D 20 61 
0143   D257 61 61 61 20 
0143   D25B 20 20 20 20 
0143   D25F 20 20 20 20 
0143   D263 20 20 72 65 
0143   D267 63 65 69 76 
0143   D26B 65 20 66 69 
0143   D26F 6C 65 20 75 
0143   D273 73 69 6E 67 
0143   D277 20 78 6D 6F 
0143   D27B 64 65 6D 20 
0143   D27F 70 72 6F 74 
0143   D283 6F 63 6F 6C 
0143   D287 2E 0D 0A 
0144   D28A 20 20 20 20 			.DB "            HEX2COM aaaa          convert intel hex to executable.",CR,LF
0144   D28E 20 20 20 20 
0144   D292 20 20 20 20 
0144   D296 48 45 58 32 
0144   D29A 43 4F 4D 20 
0144   D29E 61 61 61 61 
0144   D2A2 20 20 20 20 
0144   D2A6 20 20 20 20 
0144   D2AA 20 20 63 6F 
0144   D2AE 6E 76 65 72 
0144   D2B2 74 20 69 6E 
0144   D2B6 74 65 6C 20 
0144   D2BA 68 65 78 20 
0144   D2BE 74 6F 20 65 
0144   D2C2 78 65 63 75 
0144   D2C6 74 61 62 6C 
0144   D2CA 65 2E 0D 0A 
0145   D2CE 20 20 20 20 			.DB "            ASCII2COM aaaa        convert ASCII to executable.",CR,LF
0145   D2D2 20 20 20 20 
0145   D2D6 20 20 20 20 
0145   D2DA 41 53 43 49 
0145   D2DE 49 32 43 4F 
0145   D2E2 4D 20 61 61 
0145   D2E6 61 61 20 20 
0145   D2EA 20 20 20 20 
0145   D2EE 20 20 63 6F 
0145   D2F2 6E 76 65 72 
0145   D2F6 74 20 41 53 
0145   D2FA 43 49 49 20 
0145   D2FE 74 6F 20 65 
0145   D302 78 65 63 75 
0145   D306 74 61 62 6C 
0145   D30A 65 2E 0D 0A 
0146   D30E 20 20 20 20 			.DB "            RUN aaaa              run program.",CR,LF
0146   D312 20 20 20 20 
0146   D316 20 20 20 20 
0146   D31A 52 55 4E 20 
0146   D31E 61 61 61 61 
0146   D322 20 20 20 20 
0146   D326 20 20 20 20 
0146   D32A 20 20 20 20 
0146   D32E 20 20 72 75 
0146   D332 6E 20 70 72 
0146   D336 6F 67 72 61 
0146   D33A 6D 2E 0D 0A 
0147   D33E 20 20 20 20 			.DB "            BOOT",CR,LF,0
0147   D342 20 20 20 20 
0147   D346 20 20 20 20 
0147   D34A 42 4F 4F 54 
0147   D34E 0D 0A 00 
0148   D351 C3 00 D0    			JP	CYCLE
0149   D354             			
0150   D354             ;================================================================================================
0151   D354             ; Read memory operations - READ AAAA
0152   D354             ;================================================================================================
0153   D354 11 84 00    MREAD:		LD	DE,DMA+4
0154   D357 CD 3F DC    			CALL GETWORD		; Get aaaa
0155   D35A FE 01       			CP	1				; Is the argument OK?
0156   D35C C2 00 D0    			JP	NZ,CYCLE
0157   D35F C5          			PUSH BC
0158   D360 D1          			POP	DE				; DE will be the address holder
0159   D361 7B          			LD	A,E
0160   D362 E6 F0       			AND	0F0H
0161   D364 5F          			LD	E,A				; trim addr (xxx0)
0162   D365 CD 7E D3    NEWHDR:		CALL PRINTHDR		; Print the header
0163   D368 3E 10       			LD	A,16
0164   D36A 32 BE DD    			LD	(LINNUM),A
0165   D36D             
0166   D36D CD 67 D4    			CALL SUBMPRN
0167   D370             			
0168   D370 CD 09 E6    TRYAGAIN:	CALL CONIN			; Wait for user's decision
0169   D373 FE 0D       			CP	CR
0170   D375 28 EE       			JR	Z,NEWHDR
0171   D377 FE 1B       			CP	ESC
0172   D379 CA 00 D0    			JP	Z,CYCLE
0173   D37C 18 F2       			JR	TRYAGAIN
0174   D37E             
0175   D37E CD 33 E6    PRINTHDR:	CALL PRINTSEQ
0176   D381 3E 41 44 44 			.DB ">ADDR: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  0123456789ABCDEF",CR,LF,
0176   D385 52 3A 20 30 
0176   D389 30 20 30 31 
0176   D38D 20 30 32 20 
0176   D391 30 33 20 30 
0176   D395 34 20 30 35 
0176   D399 20 30 36 20 
0176   D39D 30 37 20 30 
0176   D3A1 38 20 30 39 
0176   D3A5 20 30 41 20 
0176   D3A9 30 42 20 30 
0176   D3AD 43 20 30 44 
0176   D3B1 20 30 45 20 
0176   D3B5 30 46 20 20 
0176   D3B9 30 31 32 33 
0176   D3BD 34 35 36 37 
0176   D3C1 38 39 41 42 
0176   D3C5 43 44 45 46 
0176   D3C9 0D 0A 
0177   D3CB 3E 2D 2D 2D 			.DB ">----- -----------------------------------------------  ----------------",0
0177   D3CF 2D 2D 20 2D 
0177   D3D3 2D 2D 2D 2D 
0177   D3D7 2D 2D 2D 2D 
0177   D3DB 2D 2D 2D 2D 
0177   D3DF 2D 2D 2D 2D 
0177   D3E3 2D 2D 2D 2D 
0177   D3E7 2D 2D 2D 2D 
0177   D3EB 2D 2D 2D 2D 
0177   D3EF 2D 2D 2D 2D 
0177   D3F3 2D 2D 2D 2D 
0177   D3F7 2D 2D 2D 2D 
0177   D3FB 2D 2D 2D 2D 
0177   D3FF 2D 2D 20 20 
0177   D403 2D 2D 2D 2D 
0177   D407 2D 2D 2D 2D 
0177   D40B 2D 2D 2D 2D 
0177   D40F 2D 2D 2D 2D 
0177   D413 00 
0178   D414 C9          			RET
0179   D415             
0180   D415 CD 91 DB    PRINTFTR:	CALL CRLF
0181   D418 CD 33 E6    			CALL PRINTSEQ
0182   D41B 3E 23 3D 3D 			.DB ">#================= <ENTER> = next page, <ESC> = quit =================#",CR,LF,0
0182   D41F 3D 3D 3D 3D 
0182   D423 3D 3D 3D 3D 
0182   D427 3D 3D 3D 3D 
0182   D42B 3D 3D 3D 20 
0182   D42F 3C 45 4E 54 
0182   D433 45 52 3E 20 
0182   D437 3D 20 6E 65 
0182   D43B 78 74 20 70 
0182   D43F 61 67 65 2C 
0182   D443 20 3C 45 53 
0182   D447 43 3E 20 3D 
0182   D44B 20 71 75 69 
0182   D44F 74 20 3D 3D 
0182   D453 3D 3D 3D 3D 
0182   D457 3D 3D 3D 3D 
0182   D45B 3D 3D 3D 3D 
0182   D45F 3D 3D 3D 23 
0182   D463 0D 0A 00 
0183   D466 C9          			RET
0184   D467             
0185   D467             SUBMPRN:
0186   D467 CD B3 D4    NEWLINE:	CALL PRINTADDR
0187   D46A 06 10       			LD	B,16
0188   D46C C5          NEWCOL:		PUSH BC
0189   D46D 1A          			LD	A,(DE)			; Start printing the memory content
0190   D46E 13          			INC	DE
0191   D46F 47          			LD	B,A
0192   D470 CD 03 DD    			CALL B2HL
0193   D473 4C          			LD	C,H
0194   D474 CD 0C E6    			CALL CONOUT
0195   D477 4D          			LD	C,L
0196   D478 CD 0C E6    			CALL CONOUT
0197   D47B 0E 20       			LD	C,' '
0198   D47D CD 0C E6    			CALL CONOUT
0199   D480 C1          			POP	BC
0200   D481 10 E9       			DJNZ NEWCOL
0201   D483 0E 20       			LD	C,' '
0202   D485 CD 0C E6    			CALL CONOUT
0203   D488 21 F0 FF    			LD	HL,0FFF0H		; This is -10h
0204   D48B 19          			ADD	HL,DE			; Go back to beginning of line
0205   D48C E5          			PUSH HL
0206   D48D D1          			POP	DE
0207   D48E 06 10       			LD	B,16
0208   D490 C5          NEWCOL2:	PUSH BC				; Start printing the printables
0209   D491 0E 2E       			LD	C,'.'
0210   D493 1A          			LD	A,(DE)
0211   D494 FE 20       			CP	20H
0212   D496 FA 9F D4    			JP	M,NOTPRTBL
0213   D499 FE 7F       			CP	7FH
0214   D49B F2 9F D4    			JP	P,NOTPRTBL
0215   D49E 4F          			LD	C,A
0216   D49F CD 0C E6    NOTPRTBL:	CALL CONOUT
0217   D4A2 13          			INC	DE
0218   D4A3 C1          			POP	BC
0219   D4A4 10 EA       			DJNZ NEWCOL2
0220   D4A6 3A BE DD    			LD	A,(LINNUM)
0221   D4A9 3D          			DEC	A
0222   D4AA 32 BE DD    			LD	(LINNUM),A
0223   D4AD 20 B8       			JR	NZ,NEWLINE
0224   D4AF CD 15 D4    			CALL PRINTFTR		; Print footer message
0225   D4B2 C9          			RET
0226   D4B3             
0227   D4B3 CD 91 DB    PRINTADDR:	CALL CRLF
0228   D4B6 CD AD DC    			CALL PRINTENV
0229   D4B9 42          			LD	B,D				; Print the address
0230   D4BA CD 03 DD    			CALL B2HL
0231   D4BD 4C          			LD	C,H
0232   D4BE CD 0C E6    			CALL CONOUT
0233   D4C1 4D          			LD	C,L
0234   D4C2 CD 0C E6    			CALL CONOUT
0235   D4C5 43          			LD	B,E
0236   D4C6 CD 03 DD    			CALL B2HL
0237   D4C9 4C          			LD	C,H
0238   D4CA CD 0C E6    			CALL CONOUT
0239   D4CD 4D          			LD	C,L
0240   D4CE CD 0C E6    			CALL CONOUT
0241   D4D1 0E 3A       			LD	C,':'
0242   D4D3 CD 0C E6    			CALL CONOUT
0243   D4D6 0E 20       			LD	C,' '
0244   D4D8 CD 0C E6    			CALL CONOUT
0245   D4DB C9          			RET
0246   D4DC             			
0247   D4DC             ;================================================================================================
0248   D4DC             ; Write memory operations - WRITE AAAA,C1 C2 C3...
0249   D4DC             ;================================================================================================
0250   D4DC 11 85 00    MWRITE:		LD	DE,DMA+5
0251   D4DF CD 3F DC    			CALL GETWORD		; Get aaaa
0252   D4E2 FE 01       			CP	1				; Is the argument OK?
0253   D4E4 C2 00 D0    			JP	NZ,CYCLE
0254   D4E7 ED 43 C0 DD 			LD	(AAAA),BC		; Save aaaa
0255   D4EB 11 8A 00    			LD	DE,DMA+10
0256   D4EE 13          MWNEXT:		INC	DE
0257   D4EF 1A          			LD	A,(DE)
0258   D4F0 FE 00       			CP	0
0259   D4F2 CA 00 D0    			JP	Z,CYCLE			; End of char string?
0260   D4F5 CD 53 DC    			CALL GETBYTE		; Get cc
0261   D4F8 FE 01       			CP	1				; Is the argument OK?
0262   D4FA C2 00 D0    			JP	NZ,CYCLE
0263   D4FD 2A C0 DD    			LD	HL,(AAAA)
0264   D500 70          			LD	(HL),B			; Put the byte in memory
0265   D501 23          			INC	HL
0266   D502 22 C0 DD    			LD	(AAAA),HL
0267   D505 18 E7       			JR	MWNEXT
0268   D507             
0269   D507             ;================================================================================================
0270   D507             ; Copy memory operations - COPY AAAA-BBBB,CCCC
0271   D507             ;================================================================================================
0272   D507 11 84 00    MCOPY:		LD	DE,DMA+4
0273   D50A CD 3F DC    			CALL GETWORD		; Get aaaa
0274   D50D FE 01       			CP	1				; Is the argument OK?
0275   D50F C2 00 D0    			JP	NZ,CYCLE
0276   D512 ED 43 C0 DD 			LD	(AAAA),BC		; Save aaaa
0277   D516 11 8A 00    			LD	DE,DMA+10
0278   D519 CD 3F DC    			CALL GETWORD		; Get bbbb
0279   D51C FE 01       			CP	1				; Is the argument OK?
0280   D51E C2 00 D0    			JP	NZ,CYCLE
0281   D521 ED 43 C2 DD 			LD	(BBBB),BC		; Save bbbb
0282   D525 11 8F 00    			LD	DE,DMA+15
0283   D528 CD 3F DC    			CALL GETWORD		; Get cccc
0284   D52B FE 01       			CP	1				; Is the argument OK?
0285   D52D C2 00 D0    			JP	NZ,CYCLE
0286   D530 ED 43 C4 DD 			LD	(CCCC),BC		; Save cccc
0287   D534 2A C2 DD    			LD	HL,(BBBB)
0288   D537 ED 5B C0 DD 			LD	DE,(AAAA)
0289   D53B AF          			XOR	A				; Reset carry flag
0290   D53C ED 52       			SBC	HL,DE
0291   D53E 23          			INC	HL
0292   D53F EB          			EX	DE,HL			; HL=source
0293   D540 D5          			PUSH DE
0294   D541 C1          			POP BC				; BC=counter
0295   D542 ED 5B C4 DD 			LD	DE,(CCCC)		; DE=target
0296   D546 ED B0       			LDIR
0297   D548 C3 00 D0    			JP	CYCLE
0298   D54B             
0299   D54B             ;================================================================================================
0300   D54B             ; Fill memory operations - FILL AAAA-BBBB,CC
0301   D54B             ;================================================================================================
0302   D54B 11 84 00    MFILL:		LD	DE,DMA+4
0303   D54E CD 3F DC    			CALL GETWORD		; Get aaaa
0304   D551 FE 01       			CP	1				; Is the argument OK?
0305   D553 C2 00 D0    			JP	NZ,CYCLE
0306   D556 ED 43 C0 DD 			LD	(AAAA),BC		; Save aaaa
0307   D55A 11 8A 00    			LD	DE,DMA+10
0308   D55D CD 3F DC    			CALL GETWORD		; Get bbbb
0309   D560 FE 01       			CP	1				; Is the argument OK?
0310   D562 C2 00 D0    			JP	NZ,CYCLE
0311   D565 ED 43 C2 DD 			LD	(BBBB),BC		; Save bbbb
0312   D569 11 8F 00    			LD	DE,DMA+15
0313   D56C CD 53 DC    			CALL GETBYTE		; Get cc
0314   D56F FE 01       			CP	1				; Is the argument OK?
0315   D571 C2 00 D0    			JP	NZ,CYCLE
0316   D574 2A C0 DD    			LD	HL,(AAAA)
0317   D577 70          			LD	(HL),B			; Put cc in the 1st position of the area to be filled.
0318   D578 2A C2 DD    			LD	HL,(BBBB)
0319   D57B ED 5B C0 DD 			LD	DE,(AAAA)
0320   D57F AF          			XOR	A				; Reset carry flag
0321   D580 ED 52       			SBC	HL,DE
0322   D582 EB          			EX	DE,HL			; HL=source
0323   D583 D5          			PUSH DE
0324   D584 C1          			POP BC				; BC=counter
0325   D585 E5          			PUSH HL
0326   D586 D1          			POP	DE
0327   D587 13          			INC DE
0328   D588 ED B0       			LDIR
0329   D58A C3 00 D0    			JP	CYCLE
0330   D58D             
0331   D58D             ;================================================================================================
0332   D58D             ; Compare two memory areas - COMPARE AAAA,BBBB
0333   D58D             ;================================================================================================
0334   D58D 11 87 00    MCOMP:		LD	DE,DMA+7
0335   D590 CD 3F DC    			CALL GETWORD		; Get aaaa
0336   D593 FE 01       			CP	1				; Is the argument OK?
0337   D595 C2 00 D0    			JP	NZ,CYCLE
0338   D598 ED 43 C0 DD 			LD	(AAAA),BC		; Save aaaa
0339   D59C C5          			PUSH BC
0340   D59D DD E1       			POP	IX
0341   D59F 11 8D 00    			LD	DE,DMA+13
0342   D5A2 CD 3F DC    			CALL GETWORD		; Get bbbb
0343   D5A5 FE 01       			CP	1				; Is the argument OK?
0344   D5A7 C2 00 D0    			JP	NZ,CYCLE
0345   D5AA ED 43 C2 DD 			LD	(BBBB),BC		; Save bbbb
0346   D5AE C5          			PUSH BC
0347   D5AF FD E1       			POP	IY
0348   D5B1 DD 7E 00    MCNBC:		LD	A,(IX+0)
0349   D5B4 FD 46 00    			LD	B,(IY+0)
0350   D5B7 B8          			CP	B
0351   D5B8 20 06       			JR	NZ,MCDIF
0352   D5BA DD 23       			INC	IX
0353   D5BC FD 23       			INC IY
0354   D5BE 18 F1       			JR	MCNBC
0355   D5C0 DD E5       MCDIF:		PUSH IX
0356   D5C2 C1          			POP	BC
0357   D5C3 79          			LD	A,C
0358   D5C4 E6 F0       			AND	0F0H
0359   D5C6 4F          			LD	C,A
0360   D5C7 ED 43 C0 DD 			LD	(AAAA),BC		; Save new aaaa
0361   D5CB FD E5       			PUSH IY
0362   D5CD C1          			POP	BC
0363   D5CE 79          			LD	A,C
0364   D5CF E6 F0       			AND	0F0H
0365   D5D1 4F          			LD	C,A
0366   D5D2 ED 43 C2 DD 			LD	(BBBB),BC		; Save new bbbb
0367   D5D6 ED 5B C0 DD MCNEWL:		LD	DE,(AAAA)
0368   D5DA CD B3 D4    			CALL PRINTADDR
0369   D5DD 06 10       			LD	B,16
0370   D5DF C5          MCNEWC:		PUSH BC
0371   D5E0 1A          			LD	A,(DE)			; Start printing the 1st memory area content
0372   D5E1 13          			INC	DE
0373   D5E2 47          			LD	B,A
0374   D5E3 CD 03 DD    			CALL B2HL
0375   D5E6 4C          			LD	C,H
0376   D5E7 CD 0C E6    			CALL CONOUT
0377   D5EA 4D          			LD	C,L
0378   D5EB CD 0C E6    			CALL CONOUT
0379   D5EE 0E 20       			LD	C,' '
0380   D5F0 CD 0C E6    			CALL CONOUT
0381   D5F3 C1          			POP	BC
0382   D5F4 10 E9       			DJNZ MCNEWC
0383   D5F6             			
0384   D5F6 DD 2A C0 DD 			LD	IX,(AAAA)
0385   D5FA ED 5B C2 DD 			LD	DE,(BBBB)
0386   D5FE CD B3 D4    			CALL PRINTADDR
0387   D601 06 10       			LD	B,16
0388   D603 C5          MCNEWAC:	PUSH BC
0389   D604 1A          			LD	A,(DE)			; Start printing the 2nd memory area content
0390   D605 DD 46 00    			LD	B,(IX)
0391   D608 DD 23       			INC	IX
0392   D60A 13          			INC	DE
0393   D60B B8          			CP	B
0394   D60C 20 0A       			JR	NZ,DIFFER		; if the content is equal, just print '='
0395   D60E 0E 3D       			LD	C,'='
0396   D610 CD 0C E6    			CALL CONOUT
0397   D613 CD 0C E6    			CALL CONOUT
0398   D616 18 0C       			JR	POSDIF
0399   D618 47          DIFFER:		LD	B,A
0400   D619 CD 03 DD    			CALL B2HL
0401   D61C 4C          			LD	C,H
0402   D61D CD 0C E6    			CALL CONOUT
0403   D620 4D          			LD	C,L
0404   D621 CD 0C E6    			CALL CONOUT
0405   D624 0E 20       POSDIF:		LD	C,' '
0406   D626 CD 0C E6    			CALL CONOUT
0407   D629 C1          			POP	BC
0408   D62A 10 D7       			DJNZ MCNEWAC
0409   D62C DD 22 C0 DD 			LD	(AAAA),IX		; save memory positions
0410   D630 ED 53 C2 DD 			LD	(BBBB),DE
0411   D634 CD 91 DB    			CALL CRLF			; print the footer
0412   D637 CD 33 E6    			CALL PRINTSEQ
0413   D63A 3E 20 20 20 			.DB ">      <ENTER> = next line, <ESC> = quit",CR,LF,0
0413   D63E 20 20 20 3C 
0413   D642 45 4E 54 45 
0413   D646 52 3E 20 3D 
0413   D64A 20 6E 65 78 
0413   D64E 74 20 6C 69 
0413   D652 6E 65 2C 20 
0413   D656 3C 45 53 43 
0413   D65A 3E 20 3D 20 
0413   D65E 71 75 69 74 
0413   D662 0D 0A 00 
0414   D665 CD 09 E6    MCAGAIN:	CALL CONIN			; Wait for user's decision
0415   D668 FE 0D       			CP	CR
0416   D66A CA D6 D5    			JP	Z,MCNEWL
0417   D66D FE 1B       			CP	ESC
0418   D66F CA 00 D0    			JP	Z,CYCLE
0419   D672 18 F1       			JR	MCAGAIN
0420   D674             
0421   D674             ;================================================================================================
0422   D674             ; Xmodem Command - XMODEM AAAA
0423   D674             ;================================================================================================
0424   D674 3E C0       XMODEM:		LD	A,0C0H
0425   D676 32 03 00    			LD	(IOBYTE),A
0426   D679 0E 11       			LD	C,DC1
0427   D67B CD 0F E6    			CALL LIST
0428   D67E             			
0429   D67E             			
0430   D67E 11 86 00    			LD	DE,DMA+6
0431   D681 CD 3F DC    			CALL GETWORD		
0432   D684 FE 01       			CP	1					; Is the argument OK?
0433   D686 C2 00 D0    			JP	NZ,CYCLE
0434   D689 ED 43 C0 DD 			LD	(AAAA),BC			; Save address
0435   D68D 3E 00       			LD	A,0
0436   D68F 32 C8 DD    			LD	(RETRY),A			; Init retry counter
0437   D692 3C          			INC	A
0438   D693 32 C9 DD    			LD	(BLOCK),A			; Init block counter
0439   D696             
0440   D696 CD 51 D7    ALIVE:		CALL SENDNAK
0441   D699             ;***********************************
0442   D699 0E 41       			LD	C,'A'
0443   D69B CD 0F E6    			CALL LIST
0444   D69E             ;***********************************			
0445   D69E 06 05       GET1ST:		LD	B,5
0446   D6A0 CD 5D D7    			CALL TOCONIN			; 5s timeout
0447   D6A3 38 0D       			JR	C,REPEAT			; Timed out?
0448   D6A5 FE 04       			CP	EOT
0449   D6A7 28 1A       			JR	Z,GOTEOT			; EOT?
0450   D6A9 FE 18       			CP	CAN
0451   D6AB CA 00 D0    			JP	Z,CYCLE				; CAN?
0452   D6AE FE 01       			CP	SOH
0453   D6B0 28 1F       			JR	Z,GOTSOH			; SOH?
0454   D6B2 3A C8 DD    REPEAT:		LD	A,(RETRY)
0455   D6B5 3C          			INC	A
0456   D6B6 32 C8 DD    			LD	(RETRY),A
0457   D6B9 FE 0A       			CP	MAXTRY
0458   D6BB 20 D9       			JR	NZ,ALIVE			; Try again?
0459   D6BD             OUT3:		
0460   D6BD CD 57 D7    			CALL SENDCAN
0461   D6C0 C3 00 D0    			JP	CYCLE
0462   D6C3             			
0463   D6C3 CD 51 D7    GOTEOT:		CALL SENDNAK
0464   D6C6 06 01       			LD	B,1
0465   D6C8 CD 5D D7    			CALL TOCONIN
0466   D6CB CD 4B D7    			CALL SENDACK
0467   D6CE C3 00 D0    			JP	CYCLE
0468   D6D1             			
0469   D6D1 3E 00       GOTSOH:		LD	A,0
0470   D6D3 32 C6 DD    			LD	(CHKSUM),A			; Reset checksum
0471   D6D6 32 C7 DD    			LD	(BYTECNT),A			; Reset byte counter
0472   D6D9 06 01       			LD	B,1
0473   D6DB CD 5D D7    			CALL TOCONIN			; Get incoming block number
0474   D6DE 38 1F       			JR	C,OUT2				; Timed out?
0475   D6E0 4F          			LD	C,A					; Save incoming block number
0476   D6E1 06 01       			LD	B,1
0477   D6E3 CD 5D D7    			CALL TOCONIN			; Get complement of incoming block number
0478   D6E6 38 17       			JR	C,OUT2				; Timed out?
0479   D6E8 2F          			CPL
0480   D6E9 B9          			CP	C
0481   D6EA 20 13       			JR	NZ,OUT2				; block = //block?
0482   D6EC 3A C9 DD    			LD	A,(BLOCK)
0483   D6EF B9          			CP	C					; Is block number what we expected?
0484   D6F0 28 16       			JR	Z,RECPACK
0485   D6F2 3D          			DEC	A
0486   D6F3 B9          			CP	C					; block number is the anterior? Probably sender missed our ACK.
0487   D6F4 20 09       			JR	NZ,OUT2
0488   D6F6 CD 87 D7    ANTBLK:		CALL PURGE				; Purge input buffer before sending ACK
0489   D6F9 CD 4B D7    			CALL SENDACK
0490   D6FC C3 9E D6    			JP	GET1ST
0491   D6FF CD 87 D7    OUT2:		CALL PURGE
0492   D702 CD 57 D7    			CALL SENDCAN
0493   D705 C3 00 D0    			JP	CYCLE
0494   D708 06 01       RECPACK:	LD	B,1					; Start receiving data packet (128 bytes)
0495   D70A CD 5D D7    			CALL TOCONIN
0496   D70D 38 F0       			JR	C,OUT2				; Timed out?
0497   D70F 2A C0 DD    			LD	HL,(AAAA)
0498   D712 77          			LD	(HL),A				; Put byte in buffer
0499   D713 23          			INC	HL					; Inc buffer pointer
0500   D714 22 C0 DD    			LD	(AAAA),HL
0501   D717 4F          			LD	C,A
0502   D718 3A C6 DD    			LD	A,(CHKSUM)
0503   D71B 81          			ADD	A,C
0504   D71C 32 C6 DD    			LD	(CHKSUM),A			; Update checksum
0505   D71F 3A C7 DD    			LD	A,(BYTECNT)			; Inc byte counter
0506   D722 3C          			INC	A
0507   D723 32 C7 DD    			LD	(BYTECNT),A
0508   D726 FE 80       			CP	128					; Check if we received a full data packet
0509   D728 20 DE       			JR	NZ,RECPACK
0510   D72A 06 01       			LD	B,1
0511   D72C CD 5D D7    			CALL TOCONIN			; Get checksum
0512   D72F 38 CE       			JR	C,OUT2				; Timed out?
0513   D731 4F          			LD	C,A
0514   D732 3A C6 DD    			LD	A,(CHKSUM)
0515   D735 B9          			CP	C
0516   D736 C2 B2 D6    			JP	NZ,REPEAT			; Checksum OK?
0517   D739 3E 00       			LD	A,0
0518   D73B 32 C8 DD    			LD	(RETRY),A			; Reset retry counter
0519   D73E 3A C9 DD    			LD	A,(BLOCK)
0520   D741 3C          			INC	A
0521   D742 32 C9 DD    			LD	(BLOCK),A			; Increment block counter
0522   D745             
0523   D745 CD 4B D7    			CALL SENDACK
0524   D748 C3 9E D6    			JP	GET1ST
0525   D74B             			
0526   D74B 0E 06       SENDACK:	LD C,ACK
0527   D74D CD 0C E6    			CALL CONOUT
0528   D750 C9          			RET
0529   D751             
0530   D751 0E 15       SENDNAK:	LD C,NAK
0531   D753 CD 0C E6    			CALL CONOUT
0532   D756 C9          			RET
0533   D757             
0534   D757 0E 18       SENDCAN:	LD C,CAN
0535   D759 CD 0C E6    			CALL CONOUT
0536   D75C C9          			RET
0537   D75D             
0538   D75D             ;==================================================================================
0539   D75D             ; Timed Out Console Input - X seconds, with X passed on reg B
0540   D75D             ; Incoming byte, if any, returns in A
0541   D75D             ; Carry flag set if timed out.
0542   D75D             ;==================================================================================
0543   D75D C5          TOCONIN:	PUSH	BC
0544   D75E E5          			PUSH	HL
0545   D75F             			
0546   D75F             ;***********************************
0547   D75F 0E 54       			LD	C,'T'
0548   D761 CD 0F E6    			CALL LIST
0549   D764 06 05       			LD	B,5
0550   D766             ;***********************************
0551   D766             			
0552   D766 21 AD 02    LOOP0:		LD	HL,685				;2.5					\
0553   D769 0E 23       LOOP1:		LD	C,35				;1.75	\				|
0554   D76B CD 06 E6    LOOP2:		CALL CONST				;36.5	|t=41.5C+0.5	| 
0555   D76E 3C          			INC	A					;1		|				|
0556   D76F 28 0E       			JR	Z,BWAITING			;3/1.75	|				| t=HL(41.5C+6.5)+1.25
0557   D771 79          			LD	A,C					;1		|				|
0558   D772 0D          			DEC	C					;1		|				|
0559   D773 20 F6       			JR	NZ,LOOP2			;3/1.75	/				| with HL=685 and c=35,
0560   D775 2B          			DEC	HL					;1						|  t=0.9994sec (WOW!!!)
0561   D776 7C          			LD	A,H					;1						|
0562   D777 B5          			OR	L					;1						|
0563   D778 20 EF       			JR	NZ,LOOP1			;3/1.75					/
0564   D77A 10 EA       			DJNZ	LOOP0			;3.25/2
0565   D77C 37          			SCF
0566   D77D 18 05       			JR	TOUT
0567   D77F CD 09 E6    BWAITING:	CALL CONIN
0568   D782 37          			SCF						; Reset carry flag
0569   D783 3F          			CCF
0570   D784 E1          TOUT:		POP	HL
0571   D785 C1          			POP	BC
0572   D786 C9          			RET
0573   D787             
0574   D787             ;==================================================================================
0575   D787             ; Purge console input.
0576   D787             ;==================================================================================
0577   D787 06 03       PURGE:		LD	B,3
0578   D789 CD 5D D7    			CALL TOCONIN
0579   D78C 30 F9       			JR	NC,PURGE
0580   D78E C9          			RET
0581   D78F             
0582   D78F             ;================================================================================================
0583   D78F             ; Hexadecimal to Executable conversion command HEX2COM AAAA
0584   D78F             ; Record structure:
0585   D78F             ;	<start_code> <byte_count> <address> <record_type> <data>...<data> <checksum>
0586   D78F             ;		':'	        1 byte     2 bytes    00h or 01h       n bytes	    1 byte
0587   D78F             ;
0588   D78F             ; Register usage:
0589   D78F             ;	IX = source address 
0590   D78F             ;	IY = target address
0591   D78F             ;================================================================================================
0592   D78F 11 88 00    HEX2COM:	LD	DE,DMA+8
0593   D792 CD 3F DC    			CALL GETWORD		
0594   D795 FE 01       			CP	1					; Is the argument OK?
0595   D797 C2 00 D0    			JP	NZ,CYCLE
0596   D79A C5          			PUSH BC					; IX holds the source address
0597   D79B DD E1       			POP	IX
0598   D79D             			
0599   D79D DD 7E 00    FINDSC:		LD	A,(IX+0)
0600   D7A0 DD 23       			INC IX
0601   D7A2 FE 3A       			CP	':'					; Do we have a start code?
0602   D7A4 20 F7       			JR	NZ,FINDSC
0603   D7A6 3E 00       			LD	A,0					; Reset checksum
0604   D7A8 32 C6 DD    			LD	(CHKSUM),A
0605   D7AB CD 38 D8    			CALL HGB				; Get byte count
0606   D7AE 78          			LD	A,B
0607   D7AF FE 00       			CP	0
0608   D7B1 CA 00 D0    			JP	Z,CYCLE				; If byte count=0, we're done.
0609   D7B4 32 C7 DD    			LD	(BYTECNT),A			; Save byte count
0610   D7B7 CD 1A D8    			CALL UPCHKSUM			; Update checksum
0611   D7BA DD 23       			INC	IX
0612   D7BC CD 42 D8    			CALL HGW				; Get target address
0613   D7BF C5          			PUSH BC
0614   D7C0 FD E1       			POP IY					; IY holds the target address
0615   D7C2 CD 1A D8    			CALL UPCHKSUM			; Update checksum
0616   D7C5 41          			LD	B,C
0617   D7C6 CD 1A D8    			CALL UPCHKSUM			; Update checksum
0618   D7C9 CD 22 D8    			CALL PRTADDR			; Print target address
0619   D7CC CD 38 D8    			CALL HGB				; Get record type (just for checksum update)
0620   D7CF CD 1A D8    			CALL UPCHKSUM			; Update checksum
0621   D7D2 DD 23       			INC	IX
0622   D7D4 3A C7 DD    			LD	A,(BYTECNT)
0623   D7D7 47          			LD	B,A
0624   D7D8 C5          GETDATA:	PUSH BC
0625   D7D9 CD 38 D8    			CALL HGB				; Get data byte
0626   D7DC FD 70 00    			LD	(IY+0),B
0627   D7DF CD 1A D8    			CALL UPCHKSUM			; Update checksum
0628   D7E2 FD 23       			INC	IY
0629   D7E4 DD 23       			INC IX
0630   D7E6 C1          			POP BC
0631   D7E7 10 EF       			DJNZ GETDATA
0632   D7E9 CD 38 D8    			CALL HGB				; Get checksum
0633   D7EC 3A C6 DD    			LD	A,(CHKSUM)
0634   D7EF ED 44       			NEG
0635   D7F1 B8          			CP	B
0636   D7F2 20 0D       			JR	NZ,CHKSUMER
0637   D7F4 CD 33 E6    			CALL PRINTSEQ
0638   D7F7 3A 20 4F 4B 			.DB	": OK.",CR,LF,0
0638   D7FB 2E 0D 0A 00 
0639   D7FF 18 9C       			JR	FINDSC
0640   D801 CD 33 E6    CHKSUMER:	CALL PRINTSEQ
0641   D804 3A 20 43 68 			.DB	": Checksum Error.",CR,LF,0
0641   D808 65 63 6B 73 
0641   D80C 75 6D 20 45 
0641   D810 72 72 6F 72 
0641   D814 2E 0D 0A 00 
0642   D818 18 83       			JR	FINDSC
0643   D81A             
0644   D81A 3A C6 DD    UPCHKSUM:	LD	A,(CHKSUM)
0645   D81D 80          			ADD	A,B
0646   D81E 32 C6 DD    			LD	(CHKSUM),A
0647   D821 C9          			RET
0648   D822             
0649   D822 CD AD DC    PRTADDR:	CALL PRINTENV
0650   D825 DD 2B       			DEC IX
0651   D827 DD 2B       			DEC IX
0652   D829 DD 2B       			DEC IX
0653   D82B 06 04       			LD	B,4
0654   D82D DD 4E 00    NXTA:		LD	C,(IX+0)
0655   D830 CD 0C E6    			CALL CONOUT
0656   D833 DD 23       			INC	IX
0657   D835 10 F6       			DJNZ NXTA
0658   D837 C9          			RET
0659   D838             			
0660   D838 DD E5       HGB:		PUSH IX
0661   D83A D1          			POP	DE
0662   D83B CD 53 DC    			CALL GETBYTE
0663   D83E D5          			PUSH DE
0664   D83F DD E1       			POP IX
0665   D841 C9          			RET
0666   D842             
0667   D842 DD E5       HGW:		PUSH IX
0668   D844 D1          			POP	DE
0669   D845 CD 3F DC    			CALL GETWORD
0670   D848 D5          			PUSH DE
0671   D849 DD E1       			POP IX
0672   D84B C9          			RET
0673   D84C             
0674   D84C             ;================================================================================================
0675   D84C             ; ASCII to Executable conversion command - ASCII2COM AAAA
0676   D84C             ; Each pair of characters is converted to one byte. The executable is loaded @ 0100h (TPA).
0677   D84C             ;	IX = source address 
0678   D84C             ;	IY = target address
0679   D84C             ;================================================================================================
0680   D84C 11 8A 00    ASCII2COM:	LD	DE,DMA+10
0681   D84F CD 3F DC    			CALL GETWORD		
0682   D852 FE 01       			CP	1					; Is the argument OK?
0683   D854 C2 00 D0    			JP	NZ,CYCLE
0684   D857 C5          			PUSH BC					; IX holds the source address
0685   D858 DD E1       			POP	IX
0686   D85A FD 21 00 01 			LD	IY,0100H
0687   D85E             
0688   D85E DD 7E 00    A2CNB:		LD	A,(IX+0)
0689   D861 CD B3 DC    			CALL ISITHEX
0690   D864 FE 01       			CP	1
0691   D866 20 10       			JR	NZ,A2CEND
0692   D868 CD 38 D8    			CALL HGB
0693   D86B FE 01       			CP	1
0694   D86D 20 09       			JR	NZ,A2CEND
0695   D86F FD 70 00    			LD	(IY+0),B
0696   D872 FD 23       			INC	IY
0697   D874 DD 23       			INC IX
0698   D876 18 E6       			JR	A2CNB
0699   D878             			
0700   D878 CD 33 E6    A2CEND:		CALL PRINTSEQ
0701   D87B 3E 54 61 72 			.DB	">Target contains ",0
0701   D87F 67 65 74 20 
0701   D883 63 6F 6E 74 
0701   D887 61 69 6E 73 
0701   D88B 20 00 
0702   D88D 01 00 01    			LD	BC,0100H
0703   D890 FD E5       			PUSH IY
0704   D892 E1          			POP	HL
0705   D893 37          			SCF
0706   D894 3F          			CCF
0707   D895 ED 42       			SBC	HL,BC
0708   D897 22 C0 DD    			LD	(AAAA),HL			; AAAA contains total bytes written.
0709   D89A 44          			LD	B,H
0710   D89B CD 03 DD    			CALL B2HL				; Convert MSByte to ASCII
0711   D89E 4C          			LD	C,H
0712   D89F CD 0C E6    			CALL CONOUT
0713   D8A2 4D          			LD	C,L
0714   D8A3 CD 0C E6    			CALL CONOUT
0715   D8A6 2A C0 DD    			LD	HL,(AAAA)
0716   D8A9 45          			LD	B,L
0717   D8AA CD 03 DD    			CALL B2HL				; Convert LSByte to ASCII
0718   D8AD 4C          			LD	C,H
0719   D8AE CD 0C E6    			CALL CONOUT
0720   D8B1 4D          			LD	C,L
0721   D8B2 CD 0C E6    			CALL CONOUT
0722   D8B5 CD 33 E6    			CALL PRINTSEQ
0723   D8B8 68 20 62 79 			.DB	"h bytes.",CR,LF,0
0723   D8BC 74 65 73 2E 
0723   D8C0 0D 0A 00 
0724   D8C3 C9          			RET
0725   D8C4             			
0726   D8C4             ;================================================================================================
0727   D8C4             ; Read disk operation - READ D,TTT,SS
0728   D8C4             ;================================================================================================
0729   D8C4 11 86 00    DREAD:		LD	DE,DMA+6
0730   D8C7 CD C5 D9    			CALL GETDTS
0731   D8CA FE 01       			CP	1				; Is the argument OK?
0732   D8CC C2 00 D0    			JP	NZ,CYCLE
0733   D8CF CD 2A DA    NEXTSEC:	CALL DTS2LBA
0734   D8D2 CD EF D8    			CALL PRINTDTS
0735   D8D5 CD 7E D3    			CALL PRINTHDR
0736   D8D8 CD 67 D9    			CALL PRINTDSEC
0737   D8DB CD 09 E6    TAGAIN:		CALL CONIN			; Wait for user's decision
0738   D8DE FE 0D       			CP	CR
0739   D8E0 20 06       			JR	NZ,NOTCR
0740   D8E2 CD 76 D9    			CALL INCDTS
0741   D8E5 C3 CF D8    			JP	NEXTSEC
0742   D8E8 FE 1B       NOTCR:		CP	ESC
0743   D8EA CA 00 D0    			JP	Z,CYCLE
0744   D8ED 18 EC       			JR	TAGAIN
0745   D8EF             
0746   D8EF             
0747   D8EF CD 33 E6    PRINTDTS:	CALL PRINTSEQ
0748   D8F2 3E 20 44 54 			.DB	"> DTS: ",0
0748   D8F6 53 3A 20 00 
0749   D8FA 3A CA DD    			LD	A,(DSK)
0750   D8FD C6 41       			ADD	A,41H
0751   D8FF 4F          			LD	C,A
0752   D900 CD 0C E6    			CALL CONOUT
0753   D903 0E 2D       			LD	C,'-'
0754   D905 CD 0C E6    			CALL CONOUT
0755   D908 3A CC DD    			LD	A,(TRK+1)
0756   D90B CD 5A D9    			CALL PRINTBYTE
0757   D90E 3A CB DD    			LD	A,(TRK)
0758   D911 CD 5A D9    			CALL PRINTBYTE
0759   D914 0E 2D       			LD	C,'-'
0760   D916 CD 0C E6    			CALL CONOUT
0761   D919 3A CD DD    			LD	A,(SEC)
0762   D91C CD 5A D9    			CALL PRINTBYTE
0763   D91F CD 33 E6    			CALL PRINTSEQ
0764   D922 20 2C 4C 42 			.DB	" ,LBA: ",0
0764   D926 41 3A 20 00 
0765   D92A 3A CE DD    			LD	A,(LBA3)
0766   D92D CD 5A D9    			CALL PRINTBYTE
0767   D930 3A CF DD    			LD	A,(LBA2)
0768   D933 CD 5A D9    			CALL PRINTBYTE
0769   D936 3A D0 DD    			LD	A,(LBA1)
0770   D939 CD 5A D9    			CALL PRINTBYTE
0771   D93C 3A D1 DD    			LD	A,(LBA0)
0772   D93F CD 5A D9    			CALL PRINTBYTE
0773   D942 CD 33 E6    			CALL PRINTSEQ
0774   D945 20 28 44 49 			.DB	" (DISKPAD = E000)",CR,LF,0
0774   D949 53 4B 50 41 
0774   D94D 44 20 3D 20 
0774   D951 45 30 30 30 
0774   D955 29 0D 0A 00 
0775   D959             
0776   D959 C9          			RET
0777   D95A             
0778   D95A 47          PRINTBYTE:	LD	B,A
0779   D95B CD 03 DD    			CALL B2HL
0780   D95E 4C          			LD	C,H
0781   D95F CD 0C E6    			CALL CONOUT
0782   D962 4D          			LD	C,L
0783   D963 CD 0C E6    			CALL CONOUT
0784   D966 C9          			RET
0785   D967             
0786   D967 CD A9 DA    PRINTDSEC:	CALL DISKREAD
0787   D96A 11 00 E0    			LD	DE,DISKPAD
0788   D96D 3E 20       			LD	A,32
0789   D96F 32 BE DD    			LD	(LINNUM),A
0790   D972 CD 67 D4    			CALL SUBMPRN
0791   D975 C9          			RET
0792   D976             
0793   D976 3A CD DD    INCDTS:		LD	A,(SEC)
0794   D979 FE 1F       			CP	1FH
0795   D97B 28 05       			JR	Z,ZSEC
0796   D97D 3C          			INC	A
0797   D97E 32 CD DD    			LD	(SEC),A
0798   D981 C9          			RET
0799   D982 AF          ZSEC:		XOR	A
0800   D983 32 CD DD    			LD	(SEC),A
0801   D986 2A CB DD    			LD	HL,(TRK)
0802   D989 01 FF 01    			LD	BC,1FFH
0803   D98C 37          			SCF
0804   D98D 3F          			CCF
0805   D98E ED 42       			SBC	HL,BC
0806   D990 28 08       			JR	Z,ZTRK
0807   D992 2A CB DD    			LD	HL,(TRK)
0808   D995 23          			INC	HL
0809   D996 22 CB DD    			LD	(TRK),HL
0810   D999 C9          			RET
0811   D99A 21 00 00    ZTRK:		LD	HL,0
0812   D99D 22 CB DD    			LD	(TRK),HL
0813   D9A0 3A CA DD    			LD	A,(DSK)
0814   D9A3 FE 0F       			CP	0FH
0815   D9A5 28 05       			JR	Z,ZDSK
0816   D9A7 3C          			INC	A
0817   D9A8 32 CA DD    			LD	(DSK),A
0818   D9AB C9          			RET
0819   D9AC AF          ZDSK:		XOR	A
0820   D9AD 32 CA DD    			LD	(DSK),A
0821   D9B0 C9          			RET
0822   D9B1             			
0823   D9B1             ;================================================================================================
0824   D9B1             ; Download 1 sector from disk to memory (@ DMIRROR)
0825   D9B1             ;================================================================================================
0826   D9B1 11 85 00    DDOWN:		LD	DE,DMA+5
0827   D9B4 CD C5 D9    			CALL GETDTS
0828   D9B7 FE 01       			CP	1				; Is the argument OK?
0829   D9B9 C2 00 D0    			JP	NZ,CYCLE
0830   D9BC CD 2A DA    			CALL DTS2LBA
0831   D9BF CD A9 DA    			CALL DISKREAD
0832   D9C2 C3 00 D0    			JP	CYCLE
0833   D9C5             
0834   D9C5             ;================================================================================================
0835   D9C5             ; Routine to get DTS from command line. DE=line_buf_ptr(should point to where DTS starts).
0836   D9C5             ; Returns A=0 if missing arg, A=1 if OK, A=2 if invalid arg. 
0837   D9C5             ;================================================================================================
0838   D9C5 CD E1 D9    GETDTS:		CALL GETDISK
0839   D9C8 FE 01       			CP	1				; Is the argument OK?
0840   D9CA C2 00 D0    			JP	NZ,CYCLE
0841   D9CD 13          			INC DE
0842   D9CE CD FC D9    			CALL GETTRACK
0843   D9D1 FE 01       			CP	1				; Is the argument OK?
0844   D9D3 C2 00 D0    			JP	NZ,CYCLE
0845   D9D6 13          			INC	DE
0846   D9D7 13          			INC DE
0847   D9D8 CD 17 DA    			CALL GETSECTOR
0848   D9DB FE 01       			CP	1				; Is the argument OK?
0849   D9DD C2 00 D0    			JP	NZ,CYCLE
0850   D9E0 C9          			RET
0851   D9E1             
0852   D9E1 1A          GETDISK:	LD	A,(DE)
0853   D9E2 FE 00       			CP	0
0854   D9E4 C2 EB D9    			JP	NZ,GD1
0855   D9E7 CD 74 DC    			CALL GBNA
0856   D9EA C9          			RET
0857   D9EB D6 41       GD1:		SUB	'A'
0858   D9ED 32 CA DD    			LD	(DSK),A
0859   D9F0 FE 10       			CP	10H
0860   D9F2 FA F9 D9    			JP	M,GD2
0861   D9F5 CD 92 DC    			CALL GBIA
0862   D9F8 C9          			RET
0863   D9F9 3E 01       GD2:		LD	A,1
0864   D9FB C9          			RET
0865   D9FC             
0866   D9FC 3E 30       GETTRACK:	LD	A,'0'
0867   D9FE 12          			LD	(DE),A
0868   D9FF CD 3F DC    			CALL GETWORD
0869   DA02 FE 01       			CP	1
0870   DA04 C0          			RET	NZ
0871   DA05 ED 43 CB DD 			LD	(TRK),BC
0872   DA09 21 FF 01    			LD	HL,1FFH
0873   DA0C 37          			SCF
0874   DA0D 3F          			CCF
0875   DA0E ED 42       			SBC	HL,BC
0876   DA10 3E 01       			LD	A,1
0877   DA12 F0          			RET	P
0878   DA13 CD 92 DC    			CALL GBIA
0879   DA16 C9          			RET
0880   DA17             
0881   DA17 CD 53 DC    GETSECTOR:	CALL GETBYTE
0882   DA1A FE 01       			CP	1
0883   DA1C C0          			RET	NZ
0884   DA1D 78          			LD	A,B
0885   DA1E 32 CD DD    			LD	(SEC),A
0886   DA21 FE 20       			CP	20H
0887   DA23 3E 01       			LD	A,1
0888   DA25 F8          			RET	M
0889   DA26 CD 92 DC    			CALL GBIA
0890   DA29 C9          			RET
0891   DA2A             			
0892   DA2A             ;================================================================================================
0893   DA2A             ; Convert disk/track/sector to LBA0,1,2,3.
0894   DA2A             ;================================================================================================
0895   DA2A 2A CB DD    DTS2LBA:	LD	HL,(TRK)
0896   DA2D CB 05       			RLC	L
0897   DA2F CB 05       			RLC	L
0898   DA31 CB 05       			RLC	L
0899   DA33 CB 05       			RLC	L
0900   DA35 CB 05       			RLC	L
0901   DA37 7D          			LD	A,L
0902   DA38 E6 E0       			AND	0E0H
0903   DA3A 6F          			LD	L,A
0904   DA3B 3A CD DD    			LD	A,(SEC)
0905   DA3E 85          			ADD	A,L
0906   DA3F 32 D1 DD    			LD	(LBA0),A
0907   DA42 2A CB DD    			LD	HL,(TRK)
0908   DA45 CB 0D       			RRC	L
0909   DA47 CB 0D       			RRC	L
0910   DA49 CB 0D       			RRC	L
0911   DA4B 7D          			LD	A,L
0912   DA4C E6 1F       			AND	01FH
0913   DA4E 6F          			LD	L,A
0914   DA4F CB 04       			RLC	H
0915   DA51 CB 04       			RLC	H
0916   DA53 CB 04       			RLC	H
0917   DA55 CB 04       			RLC	H
0918   DA57 CB 04       			RLC	H
0919   DA59 7C          			LD	A,H
0920   DA5A E6 20       			AND	020H
0921   DA5C 67          			LD	H,A
0922   DA5D 3A CA DD    			LD	A,(DSK)
0923   DA60 CB 07       			RLC	A
0924   DA62 CB 07       			RLC	A
0925   DA64 CB 07       			RLC	A
0926   DA66 CB 07       			RLC	A
0927   DA68 CB 07       			RLC	A
0928   DA6A CB 07       			RLC	A
0929   DA6C E6 C0       			AND	0C0H
0930   DA6E 84          			ADD	A,H
0931   DA6F 85          			ADD	A,L
0932   DA70 32 D0 DD    			LD	(LBA1),A
0933   DA73 3A CA DD    			LD	A,(DSK)
0934   DA76 CB 0F       			RRC	A
0935   DA78 CB 0F       			RRC	A
0936   DA7A E6 03       			AND	03H
0937   DA7C 32 CF DD    			LD	(LBA2),A
0938   DA7F 3E E0       			LD	A,0E0H
0939   DA81 32 CE DD    			LD	(LBA3),A
0940   DA84 C9          			RET
0941   DA85             			
0942   DA85             ;================================================================================================
0943   DA85             ; Wait for disk to be ready (busy=0,ready=1)
0944   DA85             ;================================================================================================
0945   DA85 F5          DWAIT:		PUSH AF
0946   DA86 DB B7       DWAIT1:		IN 	A,(CF_STATUS)
0947   DA88 E6 80       			AND	080H
0948   DA8A FE 80       			CP 	080H
0949   DA8C 28 F8       			JR	Z,DWAIT1
0950   DA8E F1          			POP	AF
0951   DA8F C9          			RET
0952   DA90             
0953   DA90             ;================================================================================================
0954   DA90             ; Set LBA on CF
0955   DA90             ;================================================================================================
0956   DA90 3A D1 DD    SETLBA:		LD	A,(LBA0)
0957   DA93 D3 B3       			OUT (CF_LBA0),A
0958   DA95 3A D0 DD    			LD	A,(LBA1)
0959   DA98 D3 B4       			OUT (CF_LBA1),A
0960   DA9A 3A CF DD    			LD	A,(LBA2)
0961   DA9D D3 B5       			OUT (CF_LBA2),A
0962   DA9F 3A CE DD    			LD	A,(LBA3)
0963   DAA2 D3 B6       			OUT (CF_LBA3),A
0964   DAA4 3E 01       			LD 	A,1
0965   DAA6 D3 B2       			OUT (CF_SECCOUNT),A
0966   DAA8 C9          			RET				
0967   DAA9             
0968   DAA9             ;================================================================================================
0969   DAA9             ; Read physical one sector from disk and write it on DISKPAD
0970   DAA9             ;================================================================================================
0971   DAA9 F5          DISKREAD:	PUSH AF
0972   DAAA C5          			PUSH BC
0973   DAAB E5          			PUSH HL
0974   DAAC             
0975   DAAC CD 85 DA    			CALL DWAIT
0976   DAAF CD 90 DA    			CALL SETLBA
0977   DAB2 3E 20       			LD 	A,CF_READ_SEC
0978   DAB4 D3 B7       			OUT (CF_COMMAND),A
0979   DAB6 CD 85 DA    			CALL DWAIT
0980   DAB9 0E 04       			LD 	C,4
0981   DABB 21 00 E0    			LD 	HL,DISKPAD
0982   DABE 06 80       rd4secs:	LD 	B,128
0983   DAC0 00          rdByte:		NOP
0984   DAC1 00          			NOP
0985   DAC2 00          			NOP
0986   DAC3 DB B0       			IN 	A,(CF_DATA)
0987   DAC5 77          			LD 	(HL),A
0988   DAC6 23          			INC HL
0989   DAC7 05          			DEC B
0990   DAC8 20 F6       			JR 	NZ, rdByte
0991   DACA 0D          			DEC C
0992   DACB 20 F1       			JR 	NZ,rd4secs
0993   DACD             
0994   DACD E1          			POP HL
0995   DACE C1          			POP BC
0996   DACF F1          			POP AF
0997   DAD0 C9          			RET
0998   DAD1             
0999   DAD1             ;================================================================================================
1000   DAD1             ; Write physical sector from DISKPAD to host.
1001   DAD1             ;================================================================================================
1002   DAD1 F5          DISKWRITE:	PUSH AF
1003   DAD2 C5          			PUSH BC
1004   DAD3 E5          			PUSH HL
1005   DAD4             
1006   DAD4 CD 85 DA    			CALL DWAIT
1007   DAD7 CD 90 DA    			CALL SETLBA
1008   DADA 3E 30       			LD 	A,CF_WRITE_SEC
1009   DADC D3 B7       			OUT (CF_COMMAND),A
1010   DADE CD 85 DA    			CALL DWAIT
1011   DAE1 0E 04       			LD 	C,4
1012   DAE3 21 00 E0    			LD 	HL,DISKPAD
1013   DAE6 06 80       wr4secs:	LD 	B,128
1014   DAE8 00          wrByte:		NOP
1015   DAE9 00          			NOP
1016   DAEA 00          			NOP
1017   DAEB 7E          			LD 	A,(HL)
1018   DAEC D3 B0       			OUT (CF_DATA),A
1019   DAEE 23          			INC HL
1020   DAEF 05          			DEC B
1021   DAF0 20 F6       			JR 	NZ,wrByte
1022   DAF2 0D          			DEC C
1023   DAF3 20 F1       			JR 	NZ,wr4secs
1024   DAF5             
1025   DAF5 E1          			POP HL
1026   DAF6 C1          			POP BC
1027   DAF7 F1          			POP AF
1028   DAF8 C9          			RET
1029   DAF9             
1030   DAF9             ;================================================================================================
1031   DAF9             ; Upload 1 sector from memory (@ DMIRROR) to disk - UP D,TTT,SS
1032   DAF9             ;================================================================================================
1033   DAF9 11 83 00    DUP:		LD	DE,DMA+3
1034   DAFC CD C5 D9    			CALL GETDTS
1035   DAFF FE 01       			CP	1				; Is the argument OK?
1036   DB01 C2 00 D0    			JP	NZ,CYCLE
1037   DB04 CD 2A DA    			CALL DTS2LBA
1038   DB07 CD D1 DA    			CALL DISKWRITE
1039   DB0A C3 00 D0    			JP	CYCLE
1040   DB0D             
1041   DB0D             ;================================================================================================
1042   DB0D             ; Verify disk. Do this on on all sectors of the disk - VERIFY D
1043   DB0D             ;
1044   DB0D             ;	1. copy sector to DISKPAD
1045   DB0D             ;	2. fill sector with 00
1046   DB0D             ;	3. verify if all bytes are 00
1047   DB0D             ;	4. fill sector with 0FFh
1048   DB0D             ;	5. verify if all bytes are 0FFh
1049   DB0D             ;	6. copy DISKPAD back to sector
1050   DB0D             ;
1051   DB0D             ; If during the verification a byte doesn't match, print error message and continue.
1052   DB0D             ;================================================================================================
1053   DB0D C9          DVERIFY:	RET
1054   DB0E             
1055   DB0E             ;================================================================================================
1056   DB0E             ; Format a disk - FORMAT D
1057   DB0E             ;================================================================================================
1058   DB0E C9          DFORMAT:	RET
1059   DB0F             
1060   DB0F             ;================================================================================================
1061   DB0F             ; Run (Execute) Command - RUN AAAA
1062   DB0F             ;================================================================================================
1063   DB0F 11 83 00    RUN:		LD	DE,DMA+3
1064   DB12 CD 3F DC    			CALL GETWORD		
1065   DB15 FE 01       			CP	1				; Is the argument OK?
1066   DB17 C2 00 D0    			JP	NZ,CYCLE
1067   DB1A C5          			PUSH BC
1068   DB1B E1          			POP	HL
1069   DB1C E9          			JP	(HL)			; Continue execution where user requested. His responsability!
1070   DB1D             
1071   DB1D             ;================================================================================================
1072   DB1D             ; Unknown Command message. HL has the address of the line buffer.
1073   DB1D             ;================================================================================================
1074   DB1D CD AD DC    UNKNOWN:	CALL PRINTENV
1075   DB20 21 80 00    			LD	HL,DMA
1076   DB23 7E          UNEXT:		LD	A,(HL)
1077   DB24 FE 00       			CP	0
1078   DB26 28 07       			JR	Z,UEND
1079   DB28 4F          			LD	C,A
1080   DB29 CD 0C E6    			CALL CONOUT
1081   DB2C 23          			INC	HL
1082   DB2D 18 F4       			JR	UNEXT
1083   DB2F 0E 3F       UEND:		LD	C,'?'
1084   DB31 CD 0C E6    			CALL CONOUT
1085   DB34 CD 91 DB    			CALL CRLF
1086   DB37 C9          			RET
1087   DB38             
1088   DB38             ;================================================================================================
1089   DB38             ; Routine to manage line input from console. Returns A=0FFh if user typed Ctrl-Z (ETX).
1090   DB38             ;================================================================================================
1091   DB38 21 80 00    LINER:		LD	HL,DMA
1092   DB3B 22 BC DD    			LD	(LBUFPTR),HL			; Init line buffer pointer.
1093   DB3E CD 09 E6    WAITCHAR:	CALL CONIN					; Wait till user types something.
1094   DB41 FE 03       			CP	ETX						; Is it Ctrl-C?
1095   DB43 28 42       			JR	Z,GOTETX
1096   DB45 FE 1A       			CP	SUB						; Is is Ctrl-Z?
1097   DB47 28 3E       			JR	Z,GOTSUB
1098   DB49 FE 18       			CP	CAN
1099   DB4B 28 40       			JR	Z,GOTCAN				; Is it <CAN>? (= delete line).
1100   DB4D FE 0D       			CP	CR
1101   DB4F 28 29       			JR	Z,GOTCR					; Is it <ENTER>?
1102   DB51 FE 08       			CP	BS
1103   DB53 28 1E       			JR	Z,GOTBS					; Is it <BS>? (= backspace).
1104   DB55 2A BC DD    			LD	HL,(LBUFPTR)			; None of the above options, so let's put it in the buffer.
1105   DB58 01 D0 00    			LD	BC,MAXLBUF				; But 1st, we have to check if we still have space.
1106   DB5B 37          			SCF
1107   DB5C 3F          			CCF
1108   DB5D ED 42       			SBC	HL,BC
1109   DB5F 28 0E       			JR	Z,LBUFFULL				; Is buffer full?
1110   DB61 2A BC DD    			LD	HL,(LBUFPTR)
1111   DB64 77          			LD	(HL),A
1112   DB65 23          			INC	HL
1113   DB66 22 BC DD    			LD	(LBUFPTR),HL
1114   DB69 4F          			LD	C,A
1115   DB6A CD 0C E6    OUTWAIT:	CALL CONOUT
1116   DB6D 18 CF       			JR	WAITCHAR
1117   DB6F             
1118   DB6F 0E 07       LBUFFULL:	LD	C,BEL					; Buffer is full. Just ring the bell.
1119   DB71 18 F7       			JR	OUTWAIT
1120   DB73             
1121   DB73 16 01       GOTBS:		LD	D,1						; We got a backspace.
1122   DB75 CD 9C DB    AFTGOTBS:	CALL BSPROC
1123   DB78 18 C4       			JR	WAITCHAR
1124   DB7A             
1125   DB7A 2A BC DD    GOTCR:		LD	HL,(LBUFPTR)			; We got an ENTER, which means the the user
1126   DB7D 3E 00       			LD	A,0						; has finished typing the command line.
1127   DB7F 77          			LD	(HL),A
1128   DB80 CD 91 DB    			CALL CRLF
1129   DB83 CD CA DB    			CALL UPPER					; Convert line to uppercase before parsing.
1130   DB86 C9          			RET
1131   DB87             GOTETX:
1132   DB87 CD 91 DB    GOTSUB:		CALL CRLF					; User abort request (Ctrl-C or Ctrl-Z).
1133   DB8A 3E 0C       			LD	A,FF
1134   DB8C C9          			RET
1135   DB8D             			
1136   DB8D 16 00       GOTCAN:		LD	D,0						; We got a line delete.
1137   DB8F 18 E4       			JR	AFTGOTBS
1138   DB91             			
1139   DB91 0E 0D       CRLF:		LD	C,CR
1140   DB93 CD 0C E6    			CALL CONOUT
1141   DB96 0E 0A       			LD	C,LF
1142   DB98 CD 0C E6    			CALL CONOUT					; Output <CR><LF>.
1143   DB9B C9          			RET
1144   DB9C             
1145   DB9C             ;================================================================================================
1146   DB9C             ; Routine to do the backspace and line delete. D=1, backspace; D=0, delete line.
1147   DB9C             ;================================================================================================
1148   DB9C 2A BC DD    BSPROC:		LD	HL,(LBUFPTR)
1149   DB9F 01 80 00    			LD	BC,DMA
1150   DBA2 37          			SCF
1151   DBA3 3F          			CCF
1152   DBA4 ED 42       			SBC	HL,BC
1153   DBA6 28 1C       			JR	Z,LBUFEMPTY
1154   DBA8 2A BC DD    			LD	HL,(LBUFPTR)
1155   DBAB 2B          			DEC	HL
1156   DBAC 22 BC DD    			LD	(LBUFPTR),HL
1157   DBAF 0E 08       			LD	C,BS
1158   DBB1 CD 0C E6    			CALL CONOUT
1159   DBB4 0E 20       			LD	C,' '
1160   DBB6 CD 0C E6    			CALL CONOUT
1161   DBB9 0E 08       			LD	C,BS
1162   DBBB CD 0C E6    			CALL CONOUT
1163   DBBE 7A          			LD	A,D
1164   DBBF FE 01       			CP	1
1165   DBC1 C8          			RET	Z
1166   DBC2 18 D8       			JR	BSPROC
1167   DBC4             
1168   DBC4 0E 07       LBUFEMPTY:	LD	C,BEL
1169   DBC6 CD 0C E6    			CALL CONOUT
1170   DBC9 C9          			RET
1171   DBCA             			
1172   DBCA             ;================================================================================================
1173   DBCA             ; Routine to convert line buffer content to upper case
1174   DBCA             ;================================================================================================
1175   DBCA 21 7F 00    UPPER:		LD	HL,DMA-1
1176   DBCD 23          NEXT2UP:	INC	HL
1177   DBCE 7E          			LD	A,(HL)
1178   DBCF FE 00       			CP	0
1179   DBD1 C8          			RET	Z
1180   DBD2 FE 61       			CP	'a'
1181   DBD4 FA CD DB    			JP	M,NEXT2UP
1182   DBD7 FE 7B       			CP	'{'
1183   DBD9 F2 CD DB    			JP	P,NEXT2UP
1184   DBDC D6 20       			SUB	20H
1185   DBDE 77          			LD	(HL),A
1186   DBDF 18 EC       			JR	NEXT2UP
1187   DBE1             			
1188   DBE1             ;================================================================================================
1189   DBE1             ; Routine to parse command. HL=cmd_table_pointer.
1190   DBE1             ; regA=cmd_num or FFh if no match. HL=jump_address or 0000 if no match.
1191   DBE1             ;================================================================================================
1192   DBE1 C5          PARSER:		PUSH BC
1193   DBE2 D5          			PUSH DE
1194   DBE3 11 80 00    			LD	DE,DMA
1195   DBE6 3E 00       			LD	A,0
1196   DBE8 32 BB DD    			LD	(CMDNUM),A		; Init command number.
1197   DBEB 1A          NEXT2PARS:	LD	A,(DE)
1198   DBEC BE          			CP	(HL)
1199   DBED 20 04       			JR	NZ,NOTEQU
1200   DBEF 23          			INC	HL
1201   DBF0 13          			INC	DE
1202   DBF1 18 F8       			JR	NEXT2PARS
1203   DBF3 7E          NOTEQU:		LD	A,(HL)
1204   DBF4 FE 1E       			CP	RS
1205   DBF6 28 04       			JR	Z,ISRS
1206   DBF8 FE 03       			CP	ETX
1207   DBFA 20 22       			JR	NZ,NEXTCMD
1208   DBFC 1A          ISRS:		LD	A,(DE)
1209   DBFD FE 00       			CP	0
1210   DBFF 28 04       			JR	Z,ISZERO
1211   DC01 FE 20       			CP	' '
1212   DC03 20 19       			JR	NZ,NEXTCMD
1213   DC05 7E          ISZERO:		LD	A,(HL)
1214   DC06 FE 03       			CP	ETX
1215   DC08 28 03       			JR	Z,CMDMATCH
1216   DC0A 23          			INC	HL
1217   DC0B 18 F8       			JR	ISZERO
1218   DC0D 23          CMDMATCH:	INC	HL
1219   DC0E E5          			PUSH HL
1220   DC0F D1          			POP	DE				; DE=addr of jump table
1221   DC10 26 00       			LD	H,0
1222   DC12 3A BB DD    			LD	A,(CMDNUM)
1223   DC15 6F          			LD	L,A
1224   DC16 E5          			PUSH HL
1225   DC17 C1          			POP	BC
1226   DC18 09          			ADD	HL,BC			; command_number * 2
1227   DC19 09          			ADD	HL,BC			; command_number * 3
1228   DC1A 19          			ADD HL,DE
1229   DC1B D1          			POP	DE
1230   DC1C C1          			POP	BC
1231   DC1D C9          			RET					; A=command_number, HL=jump_address
1232   DC1E 7E          NEXTCMD:	LD	A,(HL)
1233   DC1F FE 1E       			CP	RS
1234   DC21 28 07       			JR	Z,ISRS2
1235   DC23 FE 03       			CP	ETX
1236   DC25 28 10       			JR	Z,NOMATCH
1237   DC27 23          			INC	HL
1238   DC28 18 F4       			JR	NEXTCMD
1239   DC2A 23          ISRS2:		INC	HL
1240   DC2B 3A BB DD    			LD	A,(CMDNUM)
1241   DC2E 3C          			INC	A
1242   DC2F 32 BB DD    			LD	(CMDNUM),A
1243   DC32 11 80 00    			LD	DE,DMA
1244   DC35 18 B4       			JR	NEXT2PARS
1245   DC37 21 00 00    NOMATCH:	LD	HL,0
1246   DC3A 3E FF       			LD	A,0FFH
1247   DC3C D1          			POP	DE
1248   DC3D C1          			POP	BC
1249   DC3E C9          			RET
1250   DC3F             
1251   DC3F             ;================================================================================================
1252   DC3F             ; Routine to get word from command line. DE=line_buf_ptr(should point to where word starts).
1253   DC3F             ; If successfull, return word in BC. A=0 if missing arg, A=1 if OK, A=2 if invalid arg. 
1254   DC3F             ;================================================================================================
1255   DC3F CD 53 DC    GETWORD:	CALL GETBYTE
1256   DC42 FE 01       			CP	1
1257   DC44 C0          			RET	NZ
1258   DC45 48          			LD	C,B
1259   DC46 13          			INC	DE
1260   DC47 CD 53 DC    			CALL GETBYTE
1261   DC4A FE 01       			CP	1
1262   DC4C C0          			RET NZ
1263   DC4D 78          			LD	A,B
1264   DC4E 41          			LD	B,C
1265   DC4F 4F          			LD	C,A
1266   DC50 3E 01       			LD	A,1
1267   DC52 C9          			RET
1268   DC53             			
1269   DC53             ;================================================================================================
1270   DC53             ; Routine to get byte from command line. DE=line_buf_ptr(should point to where byte starts).
1271   DC53             ; If successfull, return byte in regB. A=0 if missing arg, A=1 if OK, A=2 if invalid arg. 
1272   DC53             ;================================================================================================
1273   DC53 1A          GETBYTE:	LD	A,(DE)
1274   DC54 FE 00       			CP	0
1275   DC56 28 1C       			JR	Z,GBNA				; End of buffer and no arg found.
1276   DC58 FE 20       			CP	' '
1277   DC5A 28 33       			JR	Z,GBSPC				; Trim the space.
1278   DC5C 67          			LD	H,A
1279   DC5D CD B3 DC    			CALL ISITHEX
1280   DC60 FE 01       			CP	1
1281   DC62 20 2E       			JR	NZ,GBIA				; Invalid arg.
1282   DC64 13          			INC	DE
1283   DC65 1A          			LD	A,(DE)
1284   DC66 6F          			LD	L,A
1285   DC67 CD B3 DC    			CALL ISITHEX
1286   DC6A FE 01       			CP	1
1287   DC6C 20 24       			JR	NZ,GBIA				; Invalid arg.
1288   DC6E CD CD DC    			CALL HL2B				; Convert ASCII pair to byte
1289   DC71 3E 01       			LD	A,1
1290   DC73 C9          			RET
1291   DC74 CD 33 E6    GBNA:		CALL PRINTSEQ
1292   DC77 3E 4D 69 73 			.DB	">Missing argument.",CR,LF,0
1292   DC7B 73 69 6E 67 
1292   DC7F 20 61 72 67 
1292   DC83 75 6D 65 6E 
1292   DC87 74 2E 0D 0A 
1292   DC8B 00 
1293   DC8C 3E 00       			LD	A,0
1294   DC8E C9          			RET
1295   DC8F 13          GBSPC:		INC	DE
1296   DC90 18 C1       			JR	GETBYTE
1297   DC92 CD 33 E6    GBIA:		CALL PRINTSEQ
1298   DC95 3E 49 6E 76 			.DB	">Invalid argument.",CR,LF,0
1298   DC99 61 6C 69 64 
1298   DC9D 20 61 72 67 
1298   DCA1 75 6D 65 6E 
1298   DCA5 74 2E 0D 0A 
1298   DCA9 00 
1299   DCAA 3E 02       			LD	A,2
1300   DCAC C9          			RET
1301   DCAD             
1302   DCAD 0E 3E       PRINTENV:	LD	C,PROMPT
1303   DCAF CD 0C E6    			CALL CONOUT
1304   DCB2 C9          			RET
1305   DCB3             
1306   DCB3 FE 47       ISITHEX:	CP	'G'
1307   DCB5 F2 C7 DC    			JP	P,NOTHEX
1308   DCB8 FE 41       			CP	'A'
1309   DCBA F2 CA DC    			JP	P,ISHEX
1310   DCBD FE 40       			CP	040H
1311   DCBF F2 C7 DC    			JP	P,NOTHEX
1312   DCC2 FE 30       			CP	'0'
1313   DCC4 F2 CA DC    			JP	P,ISHEX
1314   DCC7 3E 00       NOTHEX:		LD	A,0
1315   DCC9 C9          			RET
1316   DCCA 3E 01       ISHEX:		LD	A,1
1317   DCCC C9          			RET
1318   DCCD             
1319   DCCD             ;================================================================================================
1320   DCCD             ; Convert ASCII to HEX (HL --> B)
1321   DCCD             ;================================================================================================
1322   DCCD C5          HL2B:		PUSH BC
1323   DCCE 3E 60       			LD	A,060H
1324   DCD0 94          			SUB	H
1325   DCD1 0E 57       			LD	C,057H
1326   DCD3 DA E0 DC    			JP	C,DISCOUNT
1327   DCD6 3E 40       			LD	A,040H
1328   DCD8 94          			SUB	H
1329   DCD9 0E 37       			LD	C,037H
1330   DCDB DA E0 DC    			JP	C,DISCOUNT
1331   DCDE 0E 30       			LD	C,030H
1332   DCE0 7C          DISCOUNT:	LD	A,H
1333   DCE1 91          			SUB	C
1334   DCE2 47          CONVL:		LD	B,A
1335   DCE3 CB 20       			SLA	B
1336   DCE5 CB 20       			SLA	B
1337   DCE7 CB 20       			SLA	B
1338   DCE9 CB 20       			SLA	B
1339   DCEB 3E 60       			LD	A,060H
1340   DCED 95          			SUB	L
1341   DCEE 0E 57       			LD	C,057H
1342   DCF0 DA FD DC    			JP	C,DISCOUNT2
1343   DCF3 3E 40       			LD	A,040H
1344   DCF5 95          			SUB	L
1345   DCF6 0E 37       			LD	C,037H
1346   DCF8 DA FD DC    			JP	C,DISCOUNT2
1347   DCFB 0E 30       			LD	C,030H
1348   DCFD 7D          DISCOUNT2:	LD	A,L
1349   DCFE 91          			SUB	C
1350   DCFF B0          			OR	B
1351   DD00 C1          			POP	BC
1352   DD01 47          			LD	B,A
1353   DD02 C9          			RET
1354   DD03             
1355   DD03             ;================================================================================================
1356   DD03             ; Convert HEX to ASCII (B --> HL)
1357   DD03             ;================================================================================================
1358   DD03 C5          B2HL:		PUSH	BC
1359   DD04 78          			LD	A,B
1360   DD05 E6 0F       			AND	0FH
1361   DD07 6F          			LD	L,A
1362   DD08 D6 0A       			SUB	0AH
1363   DD0A 0E 30       			LD	C,030H
1364   DD0C DA 11 DD    			JP	C,COMPENSE
1365   DD0F 0E 37       			LD	C,037H
1366   DD11 7D          COMPENSE:	LD	A,L
1367   DD12 81          			ADD	A,C
1368   DD13 6F          			LD	L,A
1369   DD14 78          			LD	A,B
1370   DD15 E6 F0       			AND	0F0H
1371   DD17 CB 3F       			SRL	A
1372   DD19 CB 3F       			SRL	A
1373   DD1B CB 3F       			SRL	A
1374   DD1D CB 3F       			SRL	A
1375   DD1F 67          			LD	H,A
1376   DD20 D6 0A       			SUB	0AH
1377   DD22 0E 30       			LD	C,030H
1378   DD24 DA 29 DD    			JP	C,COMPENSE2
1379   DD27 0E 37       			LD	C,037H
1380   DD29 7C          COMPENSE2:	LD	A,H
1381   DD2A 81          			ADD	A,C
1382   DD2B 67          			LD	H,A
1383   DD2C C1          			POP	BC
1384   DD2D C9          			RET
1385   DD2E             
1386   DD2E             ;================================================================================================
1387   DD2E 3F 1E       CMDTBL:		.DB	"?",RS
1388   DD30 42 4F 4F 54 			.DB	"BOOT",RS
1388   DD34 1E 
1389   DD35 58 4D 4F 44 			.DB	"XMODEM",RS
1389   DD39 45 4D 1E 
1390   DD3C 48 45 58 32 			.DB	"HEX2COM",RS
1390   DD40 43 4F 4D 1E 
1391   DD44 41 53 43 49 			.DB	"ASCII2COM",RS
1391   DD48 49 32 43 4F 
1391   DD4C 4D 1E 
1392   DD4E 43 4F 4D 50 			.DB	"COMPARE",RS
1392   DD52 41 52 45 1E 
1393   DD56 52 55 4E 1E 			.DB	"RUN",RS
1394   DD5A 52 45 41 44 			.DB	"READ",RS
1394   DD5E 1E 
1395   DD5F 44 52 45 41 			.DB	"DREAD",RS
1395   DD63 44 1E 
1396   DD65 57 52 49 54 			.DB	"WRITE",RS
1396   DD69 45 1E 
1397   DD6B 43 4F 50 59 			.DB	"COPY",RS
1397   DD6F 1E 
1398   DD70 46 49 4C 4C 			.DB	"FILL",RS
1398   DD74 1E 
1399   DD75 44 4F 57 4E 			.DB	"DOWN",RS
1399   DD79 1E 
1400   DD7A 55 50 1E    			.DB	"UP",RS
1401   DD7D 46 4F 52 4D 			.DB	"FORMAT",RS
1401   DD81 41 54 1E 
1402   DD84 56 45 52 49 			.DB	"VERIFY",ETX
1402   DD88 46 59 03 
1403   DD8B             
1404   DD8B C3 1C D0    JMPTBL:		JP	HELP
1405   DD8E C3 03 E6    			JP	WBOOT
1406   DD91 C3 74 D6    			JP	XMODEM
1407   DD94 C3 8F D7    			JP	HEX2COM
1408   DD97 C3 4C D8    			JP	ASCII2COM
1409   DD9A C3 8D D5    			JP	MCOMP
1410   DD9D C3 0F DB    			JP	RUN
1411   DDA0 C3 54 D3    			JP	MREAD
1412   DDA3 C3 C4 D8    			JP	DREAD
1413   DDA6 C3 DC D4    			JP	MWRITE
1414   DDA9 C3 07 D5    			JP	MCOPY
1415   DDAC C3 4B D5    			JP	MFILL
1416   DDAF C3 B1 D9    			JP	DDOWN
1417   DDB2 C3 F9 DA    			JP	DUP
1418   DDB5 C3 0E DB    			JP	DFORMAT
1419   DDB8 C3 0D DB    			JP	DVERIFY
1420   DDBB             			
1421   DDBB             ;================================================================================================
1422   DDBB 00          CMDNUM		.DB	0
1423   DDBC 00 00       LBUFPTR		.DW	0
1424   DDBE 00          LINNUM		.DB	0
1425   DDBF 00          COLNUM		.DB	0
1426   DDC0 00 00       AAAA		.DW	0
1427   DDC2 00 00       BBBB		.DW	0
1428   DDC4 00 00       CCCC		.DW	0
1429   DDC6 00          CHKSUM	 	.DB	0					; Checksum for xmodem
1430   DDC7 00          BYTECNT		.DB	0					; Byte counter for xmodem and hex2com
1431   DDC8 00          RETRY		.DB 0					; Retry counter for xmodem
1432   DDC9 00          BLOCK		.DB	0					; Block counter for xmodem
1433   DDCA 00          DSK			.DB	0					; Disk number [00,0F]
1434   DDCB 00 00       TRK			.DW	0					; Track number [0,1FF]
1435   DDCD 00          SEC			.DB	0					; Sector number [0,1F]
1436   DDCE 00          LBA3		.DB	0
1437   DDCF 00          LBA2		.DB	0
1438   DDD0 00          LBA1		.DB	0
1439   DDD1 00          LBA0		.DB	0
1440   DDD2             
1441   DDD2             			.END
tasm: Number of errors = 0
